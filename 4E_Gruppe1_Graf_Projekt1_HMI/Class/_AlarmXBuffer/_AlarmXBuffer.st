//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include <.\lsl_st_mt.h>
#include "..\..\Class\_AlarmXBuffer\AlarmXBuffer.h"

(*!
<Class
	Name               = "_AlarmXBuffer"
	Revision           = "0.14"
	GUID               = "{526E2C4B-797D-4675-91FA-3685FAA594F8}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{A6F2702D-9666-4DA3-89F9-96C9F19A69F9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="QuitAll" GUID="{798EE51A-0E95-40E5-A0BA-8595E1583710}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="QuitGroup" GUID="{DC4D016C-4A0F-46C6-8C23-DD26DB6395C6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="No" Required="true" Internal="false" DefValue="64"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_mt.h" Include="true"/>
			<File Path=".\Class\_AlarmXBuffer\AlarmXBuffer.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.14" Date="2015-10-15" Author="HubChr" Company="sigmatek" Description="Changes in headerfile for better compatibility with new OpMode Alarm Classes."/>
		<Dokumentation Revision="0.13" Date="2015-02-02" Author="obechr" Company="sigmatek" Description="sa30232: initialisation will be done in first (instead of last) Init() run"/>
		<Dokumentation Revision="0.12" Date="2013-10-30" Author="kolott" Company="sigmatek" Description="sa26144: instances of class _AlarmX0Para will work without instance of class _AlarmXBuffer"/>
		<Dokumentation Revision="0.11" Date="2013-03-19" Author="kolott" Company="sigmatek" Description="innovation: global pointer to object of class is in use"/>
		<Dokumentation Revision="0.10" Date="2012-10-09" Author="kolott" Company="sigmatek" Description="ask for unregistered alarms (command 6 and 7) will work"/>
		<Dokumentation Revision="0.9" Date="2011-06-07" Author="kolott" Company="sigmatek" Description="improve communication to win-kernel to ensure overflowflag in ringbuffer"/>
	</RevDoku>
</Class>
*)
_AlarmXBuffer : CLASS
	TYPE
	  _AB_ALARM : STRUCT
	    alano : UDINT;
	    group : UDINT;
	    lasalid : UDINT;
	    dateTime : UDINT;
	    para : ARRAY [0..MAX_ALARMPARA-1] OF DINT;
	    state : USINT;
	    parano : USINT;
	  END_STRUCT;
	  _AB_CONFIG : STRUCT
	    pThis : UDINT;
	    config : UDINT;
	    group : UDINT;
	    nopara : USINT;
	    para : ARRAY [0..MAX_ALARMPARA-1] OF UDINT;
	    configDone : BOOL;
	  END_STRUCT;
	  _AB_MEM_ALARM : STRUCT
	    no : UDINT;
	    size : UDINT;
	    ptr : ^_AB_ALARM;
	  END_STRUCT;
	  _AB_MEM_CONFIG : STRUCT
	    no : UDINT;
	    size : UDINT;
	    ptr : ^_AB_CONFIG;
	  END_STRUCT;
	  _HMI_MAP : STRUCT
	    no : UDINT;
	    id : UDINT;
	  END_STRUCT;
	  xxx : ^_AlarmX0Para;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_UDINT;
	QuitAll 	: SvrCh_DINT;
	QuitGroup 	: SvrCh_DINT;
  //Clients:
	No 	: CltCh_DINT;
  //Variables:
		Mutex 	: MT_SEMAHANDLE;
		mt_api 	: ^LSL_MT_TYPE;
		MemConfig 	: _AB_MEM_CONFIG;
		MemAlarm 	: _AB_MEM_ALARM;
		HmiMap : ARRAY [0..15] OF _HMI_MAP;

		HmiNo 	: UDINT;
		bInit 	: BOOL;
  //Functions:
	
	FUNCTION _AlarmXBuffer
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION MakeDateTime
		VAR_OUTPUT
			datetime 	: UDINT;
		END_VAR;
	
	FUNCTION DoMutex
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION SeekHmi
		VAR_INPUT
			id 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION CreateTXBuffer
		VAR_INPUT
			tx 	: ^USINT;
			txsize 	: UDINT;
			pno 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GetConfig
		VAR_INPUT
			pDst 	: ^USINT;
			pThis 	: UDINT;
			xcmd 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmGroup
		VAR_INPUT
			group 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmSingle
		VAR_INPUT
			alano 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmAll
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RegisterAlarmXPara
		VAR_INPUT
			pThis 	: ^void;
			config 	: UDINT;
			group 	: UDINT;
			no 	: UDINT;
			paras 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActionAlarm
		VAR_INPUT
			pThis 	: UDINT;
			config 	: UDINT;
			group 	: UDINT;
			state 	: DINT;
			parano 	: UDINT;
			ppara 	: ^DINT;
		END_VAR;
	
	FUNCTION CreateTXBuffer200
		VAR_INPUT
			tx 	: ^USINT;
			txsize 	: UDINT;
			index 	: UDINT;
			anz 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetVersion
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CreateUnregTXBuffer
		VAR_INPUT
			pres 	: ^USINT;
			startidx 	: UDINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitAll::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitGroup::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AlarmXBuffer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ALARMXBUFFER
0$UINT, 14$UINT, (SIZEOF(::_AlarmXBuffer))$UINT, 
3$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2835625764), "_AlarmXBuffer", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_AlarmXBuffer.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_AlarmXBuffer.QuitAll.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(134212785), "QuitAll", 
(::_AlarmXBuffer.QuitGroup.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2229057306), "QuitGroup", 
//Clients:
(::_AlarmXBuffer.No.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3376426101), "No", 
END_FUNCTION


#define USER_CNT__AlarmXBuffer 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AlarmXBuffer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AlarmXBuffer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__AlarmXBuffer, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Quit_AlarmGroup();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Quit_AlarmSingle();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #Quit_AlarmAll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #RegisterAlarmXPara();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ActionAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetVersion();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitAll.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitAll::Write() );
	IF QuitAll.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitGroup.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitGroup::Write() );
	IF QuitGroup.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _AlarmXBuffer();

END_FUNCTION

#pragma usingLtd _AlarmX0Para

//{{LSL_IMPLEMENTATION
#pragma using _AlarmX0Para

#include <Lsl_st_ifssr.h>

VAR_GLOBAL
  PV_AlarmBuffer : ^_AlarmXBuffer;
END_VAR

FUNCTION _AlarmXBuffer::_AlarmXBuffer
  VAR_OUTPUT
    ret_code 	: ConfStates;
  END_VAR

  bInit          := false;
  PV_AlarmBuffer := NIL; 
  Mutex          := NIL;
  mt_api         := NIL;
  if(OS_CILGet("LSL_MULTITASK", #mt_api$void)) then
    mt_api := NIL; 
  end_if; 
  if(mt_api <> NIL) then
    Mutex := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "HMI_ALABUF");
  end_if;

  // init configdata
  MemConfig.no   := 0;   // no of entries
  MemConfig.size := 0;   // buffersize
  MemConfig.ptr  := NIL; // --> to buffer

  // init databuffer
  MemAlarm.no    := 0;   // no of entries
  MemAlarm.size  := 0;   // buffersize
  MemAlarm.ptr   := NIL; // --> to buffer
  
  // init hmi
  _memset(#HmiMap[0], 0, sizeof(HmiMap));
  
  // init no of hmi's
  HmiNo          := 0;
  
	ret_code := C_OK;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::Init
  VAR
    anz : udint;
  END_VAR

  PV_AlarmBuffer := this; // set global this

  // first init-run
  if(bInit = false) then
    // allocate memory for internal alarmbuffer
    anz          := to_udint(No.Read());
    MemAlarm.ptr := OS_SSR_Malloc(anz * sizeof(_AB_ALARM))$^_AB_ALARM;
    if(MemAlarm.ptr <> NIL) then
      MemAlarm.size := anz; // max no of entries
      MemAlarm.no   := 0;   // act no of entries 
    end_if;
    
    No := to_dint(MemAlarm.size);
    
    // init done
    bInit := true;
    
  end_if;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::RegisterAlarmXPara
	VAR_INPUT
		pThis 	: ^void;
		config 	: UDINT;
		group 	: UDINT;
		no 	: UDINT;
		paras 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
    ptr : ^_AB_CONFIG;
  END_VAR

  retcode := 0;

  if(MemConfig.no >= MemConfig.size) then
    if(MemConfig.ptr = NIL) then
      ptr := OS_SSR_Malloc(32 * sizeof(_AB_CONFIG))$^_AB_CONFIG;
      MemConfig.size := 0;
    else
      ptr := OS_SSR_Realloc(MemConfig.ptr, (MemConfig.no + 32) * sizeof(_AB_CONFIG))$^_AB_CONFIG;
    end_if;
    if(ptr <> NIL) then
      _memset(ptr+MemConfig.size*sizeof(_AB_CONFIG), 0, 32*sizeof(_AB_CONFIG)); // init new memory
      MemConfig.ptr  := ptr;
      MemConfig.size += 32;
    end_if;
  end_if;
  
  if(MemConfig.no < MemConfig.size) then
    if(config = 0) then
      config := 16#FFFE - MemConfig.no;
    end_if;
    retcode         := config;
    ptr             := MemConfig.ptr + (MemConfig.no * sizeof(_AB_CONFIG));
    ptr^.pThis      := pThis$UDINT;
    ptr^.config     := config;
    ptr^.group      := group;
    ptr^.configDone := false;

    if(no > MAX_ALARMPARA) then
      no := MAX_ALARMPARA;
    end_if;

    ptr^.nopara := to_usint(no);
    _memcpy(#ptr^.para[0], paras, no * sizeof(udint));
    MemConfig.no += 1;
  end_if;
  
END_FUNCTION
FUNCTION _AlarmXBuffer::MakeDateTime
  VAR_OUTPUT
    datetime 	: UDINT;
  END_VAR
  VAR
    xdate : SYSDATE;
    xtime : SYSTIME;
  END_VAR

  OS_SSR_GetSysDate(#xdate);
  OS_SSR_GetSysTime(#xtime);

  datetime := xtime.wSecond;
  datetime := datetime or (xtime.wMinute shl 6);
  datetime := datetime or (xtime.wHour shl 12);
  datetime := datetime or (xdate.wDay shl 17);
  datetime := datetime or (xdate.wMonth shl 22);
  datetime := datetime or ((xdate.wYear-2000) shl 26);

END_FUNCTION
FUNCTION _AlarmXBuffer::DoMutex
  VAR_INPUT
    state 	: BOOL;
  END_VAR

  if(Mutex <> NIL) then
    if(state = TRUE) then
      OS_MT_Wait(Mutex);
    else
      OS_MT_Signal(Mutex);
    end_if;
  end_if;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::ActionAlarm
	VAR_INPUT
		pThis 	: UDINT;
		config 	: UDINT;
		group 	: UDINT;
		state 	: DINT;
		parano 	: UDINT;
		ppara 	: ^DINT;
	END_VAR
  VAR
    index : UDINT;
    ptr   : ^_AB_ALARM;
    datim : UDINT;
  END_VAR

  datim := MakeDateTime();

  DoMutex(TRUE);

  if(MemAlarm.size > 0) then
    index := ClassSvr mod MemAlarm.size;                 // make wpos
    ptr   := MemAlarm.ptr + (index * sizeof(_AB_ALARM)); // --> to dst
    _memset(ptr, 0, sizeof(_AB_ALARM));                  // init

    ptr^.alano    := config;
    ptr^.group    := group;
    ptr^.lasalid  := pThis;
    ptr^.dateTime := datim;
    ptr^.parano   := to_usint(parano);
    
    if(state = -1) then
      ptr^.state := 255; // acknowledge
    else
      ptr^.state := state$USINT and 1;
    end_if;
    
    if(parano <> 0) then
      _memcpy(#ptr^.para[0], ppara, parano * sizeof(udint));
    end_if;
    
    ClassSvr      += 1;
    if(MemAlarm.no < MemAlarm.size) then
      MemAlarm.no += 1;
    end_if;
    
    // inc cout of previously missed alarms
    HmiMap[ 0].no += 1; 
    HmiMap[ 1].no += 1;
    HmiMap[ 2].no += 1;
    HmiMap[ 3].no += 1;
    HmiMap[ 4].no += 1; 
    HmiMap[ 5].no += 1;
    HmiMap[ 6].no += 1;
    HmiMap[ 7].no += 1;
    HmiMap[ 8].no += 1; 
    HmiMap[ 9].no += 1;
    HmiMap[10].no += 1;
    HmiMap[11].no += 1;
    HmiMap[12].no += 1; 
    HmiMap[13].no += 1;
    HmiMap[14].no += 1;
    HmiMap[15].no += 1;
    
  end_if;
  
  DoMutex(FALSE);

END_FUNCTION
FUNCTION _AlarmXBuffer::SeekHmi
  VAR_INPUT
    id 	: UDINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR
  VAR
    ii : udint;
  END_VAR

  retcode := 16#FF;
  
  if(MemAlarm.size > 0) then
    if(HmiNo > 0) then
      ii := HmiNo;
      while(ii) do
        ii -= 1;
        if(HmiMap[ii].id = id) then
          retcode := to_usint(ii);
          return;
        end_if;
      end_while;
    end_if;
  
    if(HmiNo < (sizeof(HmiMap)/sizeof(HmiMap[0]))) then
      HmiMap[HmiNo].id := id;
//      HmiMap[HmiNo].no := 0;
      retcode          := to_usint(HmiNo);
      HmiNo += 1;
    end_if;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::CreateTXBuffer
  VAR_INPUT
    tx 	: ^USINT;
    txsize 	: UDINT;
    pno 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: UINT;
  END_VAR
  VAR
    i, xno, sno, index : UDINT;
    txno    : UINT;
    txindex : UINT;
    pala    : ^_AB_ALARM;
    tmp     : usint;
  END_VAR

  // [4] .... alano
  // [4] .... date and time
  // [1] .... state, parano, group
  // [4] .... group (optional)
  // [4] .... lasalid (optional)
  // [n*4] .. parameter

  retcode := 0;
  xno     := pno^;
  sno     := 0;
  txindex := 1;

  i := 0;
  while(i < xno) do
    index := (ClassSvr - xno + i) mod MemAlarm.size;
    i     += 1;
    pala  := MemAlarm.ptr + (index * sizeof(_AB_ALARM));
    txno  := 9 + (pala^.parano * sizeof(pala^.para[0]));
    
    if(pala^.group <> 0) then
      txno += 8;
    end_if;
    
    if((txindex + txno) < txsize) then
      (tx + txindex)^$UDINT := pala^.alano;
      txindex += sizeof(UDINT);
      (tx + txindex)^$UDINT := pala^.dateTime;
      txindex += sizeof(UDINT);
      
      if(pala^.state = 255) then
        (tx + txindex)^$USINT := 255;
      else
        tmp := pala^.parano shl 1;
        if(pala^.state <> 0) then
          tmp := tmp or 1;
        end_if;
        if(pala^.group <> 0) then
          tmp := tmp or 16#80;
        end_if;
        (tx + txindex)^$USINT := tmp;
      end_if;
      
      txindex += sizeof(USINT);
      if(pala^.group <> 0) then
        (tx + txindex)^$UDINT := pala^.group;
        txindex += sizeof(UDINT);
        (tx + txindex)^$UDINT := pala^.lasalid;
        txindex += sizeof(UDINT);
      end_if;
      
      if(pala^.state <> 255) then 
        // keine parameter beim quittieren
        tmp := pala^.parano * sizeof(DINT);
        _memcpy(tx + txindex, #pala^.para[0], tmp);
        txindex += tmp;
      end_if;
      
      sno     += 1;
    else
      i := xno;
    end_if;
  end_while;

  pno^    := sno; // anzahl der eingetragenen alarme
  retcode := txindex;

END_FUNCTION


FUNCTION _AlarmXBuffer::GetConfig
	VAR_INPUT
		pDst 	: ^USINT;
		pThis 	: UDINT;
		xcmd 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
    i : UDINT;
	  anz : UINT;
    ptr : ^_AB_CONFIG;
  END_VAR

  retcode := 0;

  i := 0;
  ptr := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pThis = ptr^.pThis) then
      anz := ptr^.nopara;
      pDst^$UDINT := ptr^.config;   pDst += 4;
      pDst^$USINT := to_usint(anz); pDst += 1;
      if(xcmd = 1) then
        ptr^.configDone := true;
      end_if;
      anz := anz * 4;
      _memcpy(pDst, #ptr^.para[0], anz);
      retcode := anz + 5;
      exit;
    end_if;
    ptr += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmSingle
	VAR_INPUT
		alano 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := FALSE;
  //alano   := alano shl 16;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pConfig^.config$UINT = alano) then
      pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pAlarmXPara^.QuitAlarm();
        retcode := TRUE;
        exit;
      end_if;
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmAll
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := TRUE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
    if(pAlarmXPara <> NIL) then
      pAlarmXPara^.QuitAlarm();
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmGroup
	VAR_INPUT
		group 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := FALSE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pConfig^.group = group) then
      pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pAlarmXPara^.QuitAlarm();
        retcode := TRUE;
      end_if;
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitAll::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR

  QuitAll := input;
  result := QuitAll;
  
  DoMutex(true);
  Quit_AlarmAll();
  DoMutex(false);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitGroup::Write
  VAR_INPUT
    input		: DINT;
  END_VAR
  VAR_OUTPUT
    result		: DINT;
  END_VAR

  QuitGroup := input;
  result    := QuitGroup;

  DoMutex(true);
  Quit_AlarmGroup(input$udint);
  DoMutex(false);

END_FUNCTION


FUNCTION _AlarmXBuffer::CreateTXBuffer200
	VAR_INPUT
		tx 	: ^USINT;
		txsize 	: UDINT;
		index 	: UDINT;
    anz     : UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
    tmp     : usint;
    idx, maxanz : udint;
    pala    : ^_AB_ALARM;
    overflow : bool;
  END_VAR

  // out: [4] ................. index of first entry in resultbuffer
  //      [4] ................. number of entries in resultbuffer + (msb is set if overflow occured)
  //      *[4] ................ alano
  //      *[4] ................ date and time
  //      *[1] ................ state, parano, group
  //      *[4] ................ group
  //      *[4] ................ lasalid
  //      *[MAX_ALARMPARA*4] .. parameter

  retcode := 0;
  overflow := false;
  
  maxanz := No$udint;
  if(index >= ClassSvr) then
    anz := 0;
    index := 0;
    if(ClassSvr > 0) then
      index := ClassSvr - 1;
    end_if;
  elsif(ClassSvr > maxanz) then
    if(index < (ClassSvr - maxanz)) then
      index := ClassSvr - No$udint;
      anz   := No$udint;
      overflow := true;
    end_if;
  end_if;
  
  if((index + anz) > ClassSvr) then
    anz := ClassSvr - index;
  end_if;
  
  tx^$udint := index; tx += 4; // index of first entry
  tx^$udint := 0; // number of entries
  
  if(index < ClassSvr) then
    maxanz := (txsize - 8) / (17 + 4 * MAX_ALARMPARA);
    if(anz > maxanz) then
      anz := maxanz;
    end_if;
    if((index + anz) > ClassSvr) then
      anz := ClassSvr - index;
    end_if;
  
    retcode    := anz;
    tx$^udint^ := anz; // number of entries
    if(overflow = true) then
      tx$^udint^ := 16#80000000 or anz; // number of entries + overflowflag
    end_if;
    tx += 4;
  
    _memset(tx, 0, txsize - 8); // clear tx-buffer
  
    while(anz) do
      anz   -= 1;
      idx   := index mod MemAlarm.size;
      index += 1;
      pala  := MemAlarm.ptr + (idx * sizeof(_AB_ALARM));
    
      tx^$udint := pala^.alano;    tx += 4; // alano
      tx^$udint := pala^.dateTime; tx += 4; // date and time
    
      if(pala^.state = 255) then
        tmp := 255;
      else
        tmp := pala^.parano shl 1;
        if(pala^.state <> 0) then
          tmp := tmp or 1;
        end_if;
        if(pala^.group <> 0) then
          tmp := tmp or 16#80;
        end_if;
      end_if;
      tx^$usint := tmp;           tx += 1; // state, parano, group
      tx^$udint := pala^.group;   tx += 4; // group
      tx^$udint := pala^.lasalid; tx += 4; // lasalid
      
      _memcpy(tx, #pala^.para[0], pala^.parano * sizeof(DINT)); // parameter
      tx += (4 * MAX_ALARMPARA);
    end_while;
  end_if;
  
END_FUNCTION


FUNCTION _AlarmXBuffer::CreateUnregTXBuffer
	VAR_INPUT
		pres 	: ^USINT;
		startidx 	: UDINT;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
  	pidx : ^udint;
    panz : ^usint;
    plid : ^udint;
    ptr : ^_AB_CONFIG;  
  END_VAR

  pidx := pres$^udint; 
  pres += 4;
  panz := pres;
  pres += 1;
  plid := pres$^udint;
  
  
  pidx^ := 16#FFFFFFFF;
  panz^ := 0;
  
  size    -= 5;
  retcode := 5;
  
  if(startidx < MemConfig.no) then
    ptr := MemConfig.ptr + startidx * sizeof(_AB_CONFIG);
    while(startidx < MemConfig.no) do
      startidx += 1;
      
      if(ptr^.configDone = false) then
        panz^   += 1;
        size    -= 4;
        retcode += 4;
        plid^   := ptr^.pThis;
        plid    += 4;
        if(size < 4) then
          pidx^ := startidx;
          return;
        end_if;
      end_if;
    
      ptr += sizeof(_AB_CONFIG);
    
    end_while;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::ClassSvr::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: iprStates;
  END_VAR
  VAR
    index, ii, tmp1, tmp2 : udint;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  case pPara^.uiCmd of
    0:// COMMAND_SETID ... terminal anmelden
      // in:   [4] ... unique id of hmi
        
      // out:  [1] ... handle to get access (error = 16#FF)
      DoMutex(true);
      pResult^.aData[0]$usint := SeekHmi(pPara^.aPara[0]$UDINT);
      pResult^.uiLng          := 3;
      DoMutex(false);

    1,7:// COMMAND_GETALARMCONFIG, COMMAND_GETALARMCONFIGEX ... get alarmconfig
      // in:   [4] ... lasalid of alarmserver
      
      // out:  [4] ... alarmconfiguration
      //       [1] ... number of parameterid
      //       *[4] .. parameterid
      DoMutex(true);
      pResult^.uiLng := 2;
      pAlarmXPara    := pPara^.aPara[0]$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pResult^.uiLng := 2 + to_usint(GetConfig(#pResult^.aData[0], pAlarmXPara$UDINT, pPara^.uiCmd));
//          pResult^.uiLng := 2 + pAlarmXPara^.GetConfig(#pResult^.aData[0]);
//        end_if;
      end_if;
      DoMutex(false);

    2:// COMMAND_GETALARMS ... get alarms
      // in:   [4] ... handle
      
      // out:  [1] ... number of records
      //       ??
      DoMutex(true);
      pResult^.uiLng    := 2;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        ii := HmiMap[index].no;
        //if(ii > 255) then
        //  ii := 255;
        //end_if;
        if(ii > MemAlarm.no) then
          ii               := MemAlarm.no;
          HmiMap[index].no := ii;
        end_if;
        if(ii > 0) then
          pResult^.uiLng    += CreateTXBuffer(#pResult^.aData[0], sizeof(pResult^.aData) - 2, #ii);
          HmiMap[index].no  -= ii;
          pResult^.aData[0] := to_usint(ii); // anzahl der einträge
        else
          pResult^.uiLng    += 1;
          pResult^.aData[0] := 0; // keine einträge vorhanden
        end_if;
      end_if;
      DoMutex(false);
    
    3:// COMMAND_QUITALARM ... quit alarm
      // in:   [4] ... handle
      //       [4] ... alarmnumber to quit or 0xFFFFFFFF to quit all
      
      // out:  [1] ... 0 = false, 1 = true
      DoMutex(true);
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        ii := pPara^.aPara[1]$UDINT;
        if(ii = 0xFFFFFFFF) then
          if(Quit_AlarmAll() = true) then
            pResult^.aData[0] := 1;
          end_if;
        else
          if(Quit_AlarmSingle(ii) = true) then
            pResult^.aData[0] := 1;
          end_if;
        end_if;
      end_if;
      DoMutex(false);

    4:// COMMAND_QUITGROUP ... quit alarmgroup
      // in:   [4] ... handle
      //       [4] ... groupnumber to quit
      
      // out:  [1] ... 0 = false, 1 = true
      DoMutex(true);
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        ii := pPara^.aPara[1]$UDINT;
        if(Quit_AlarmGroup(ii) = true) then
          pResult^.aData[0] := 1;
        end_if;
      end_if;
      DoMutex(false);
      
    5:// COMMAND_RESETNOSENT ... reset number of already sent alarms
      // in:   [4] ... handle
      
      // out:  [1] ... 0 = false, 1 = true
      DoMutex(true);
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].no := MemAlarm.no;
        pResult^.aData[0] := 1;
      end_if;
      DoMutex(false);
      
    6:// COMMAND_GETUNREGID ... get lasalid from all alarms which are actual not asked for their configuration
      // in:   [4] ... handle
      //       [4] ... startindex (initial 0, further request use endindex)
      
      // out:  [4] ... endindex (used for next request (startindex), 0xFFFFFFFF when finished)
      //       [1] ... anzahl
      //       [ ..... lasalids
      DoMutex(true);
      pResult^.uiLng          := 7;
      pResult^.aData[0]$UDINT := 16#FFFFFFFF;
      pResult^.aData[4]       := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        pResult^.uiLng += CreateUnregTXBuffer(#pResult^.aData[0], pPara^.aPara[1]$udint, sizeof(pResult^.aData) - 10);
      end_if;
      DoMutex(false);
     
		200 : // register hmi
        // in:   [4] ... unique id of hmi
        //       [4] ... hmi style (1 = seperate set of index counter)
        
        // out:  [4] ... handle to get access (error = 16#FFFFFFFF)
        //       [4] ... index of last validated element
        //       [4] ... number of buffered elements
        //       [4] ... size of single element in byte
        //       [4] ... max. count of entries in buffer
        DoMutex(true);
        pResult^.uiLng           := 2 + 20;
        pResult^.aData[0]$udint  := 16#FFFFFFFF;
        pResult^.aData[4]$udint  := 0;
        pResult^.aData[8]$udint  := 0;
        pResult^.aData[12]$udint := 17 + 4 * MAX_ALARMPARA;
        pResult^.aData[16]$udint := No$udint;
        index := SeekHmi(pPara^.aPara[0]$UDINT);
        if(index < HmiNo) then
          pResult^.aData[0]$udint := index;
          pResult^.aData[4]$udint := ClassSvr - HmiMap[index].no;
          pResult^.aData[8]$udint := ClassSvr;
        end_if;
        DoMutex(false);

             
    202 : // read arbitrary entries
        // in:   [4] ... handle
        //       [4] ... startindex of entry
        //       [4] ... number of entries 

        // out:  [4] ... index of first entry in resultbuffer
        //       [4] ... number of entries in resultbuffer + (msb is set if overflow occured)
        //       [ ..... recordstream
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          ii := CreateTXBuffer200(#pResult^.aData[0], sizeof(pResult^.aData)-2, pPara^.aPara[1]$UDINT, pPara^.aPara[2]$UDINT); 
          pResult^.uiLng := to_uint(2 + 8 + ii * (17 + 4 * MAX_ALARMPARA));
          if(ii <> 0) then
            tmp1 := ClassSvr - HmiMap[index].no;
            tmp2 := pPara^.aPara[1]$UDINT + ii;
            if(tmp2 > tmp1) then
              HmiMap[index].no -= tmp2 - tmp1;
            end_if;
          end_if;
        end_if;
        DoMutex(false);

    204 : // get number of entries in databuffer
        // out:  [4] ... actual catch_no value
        DoMutex(true);
        pResult^.aData[0]$udint := ClassSvr;
        pResult^.uiLng := 2 + 4;
        DoMutex(false);

    205 : // get version of DataQueueBuffer
        // out:  [4] ... versionnumber of recordbuffer
        pResult^.aData[0]$udint := GetVersion();
        pResult^.uiLng := 2 + 4;

  end_case;

  ret_code:= READY;

END_FUNCTION


FUNCTION VIRTUAL _AlarmXBuffer::GetVersion
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 2;
  // from version 2 command 6 (COMMAND_GETUNREGID) and 7 (COMMAND_GETALARMCONFIGEX) are available

END_FUNCTION
