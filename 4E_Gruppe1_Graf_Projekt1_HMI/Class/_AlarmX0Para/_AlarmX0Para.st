//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_AlarmX0Para\_AlarmX0Para.h"

(*!
<Class
	Name               = "_AlarmX0Para"
	Revision           = "0.7"
	GUID               = "{858D5524-F314-4ED8-975A-A123450BF12B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{BE689487-005D-4C4C-8B98-759BCFF5A930}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Acknow" Required="false" Internal="false"/>
		<Client Name="Config" Required="true" Internal="false" DefValue="0"/>
		<Client Name="Group" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_AlarmX0Para\_AlarmX0Para.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="HubChr"/>
		<Dokumentation Revision="0.7" Date="2015-07-30" Author="HubChr" Company="sigmatek" Description="Method QuitAlarm() is now virtual"/>
		<Dokumentation Revision="0.6" Date="2015-06-02" Author="HubChr" Company="sigmatek" Description="sa30792: User can now choose, in which init-run the initialisation will be done"/>
		<Dokumentation Revision="0.5" Date="2015-02-02" Author="obechr" Company="sigmatek" Description="sa30232: initialisation will be done in first (instead of last) Init() run"/>
		<Dokumentation Revision="0.4" Date="2013-10-30" Author="kolott" Company="sigmatek" Description="sa26144: instances of class _AlarmX0Para will work without instance of class _AlarmXBuffer"/>
		<Dokumentation Revision="0.3" Date="2013-03-19" Author="kolott" Company="sigmatek" Description="innovation: global pointer to _AlarmXBuffer is in use"/>
	</RevDoku>
</Class>
*)
_AlarmX0Para : CLASS
	TYPE
	  yyyy : ^_AlarmXBuffer;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	Config 	: CltCh_DINT;
	Acknow 	: CltCh_DINT;
	Group 	: CltCh_DINT;
  //Variables:
		bInit 	: BOOL;
		sInitCnt 	: SINT;
  //Functions:
	
	FUNCTION _AlarmX0Para
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL GetParaID
		VAR_INPUT
			ppara 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetParaVal
		VAR_INPUT
			ppara 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitAlarm;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AlarmX0Para::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ALARMX0PARA
0$UINT, 7$UINT, (SIZEOF(::_AlarmX0Para))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(800276940), "_AlarmX0Para", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_AlarmX0Para.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::_AlarmX0Para.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(611510522), "Config", 
(::_AlarmX0Para.Acknow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3731534488), "Acknow", 
(::_AlarmX0Para.Group.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2593425013), "Group", 
END_FUNCTION


#define USER_CNT__AlarmX0Para 3

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AlarmX0Para] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AlarmX0Para::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__AlarmX0Para, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetParaID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetParaVal();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #QuitAlarm();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _AlarmX0Para();

END_FUNCTION

#pragma usingLtd _AlarmXBuffer

//{{LSL_IMPLEMENTATION
#pragma using _AlarmXBuffer

VAR_EXTERNAL
  PV_AlarmBuffer : ^_AlarmXBuffer;
END_VAR

FUNCTION  _AlarmX0Para::_AlarmX0Para
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

  bInit          := false;
  Acknow         := 0;
  PV_AlarmBuffer := NIL;
  ret_code       := C_OK;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmX0Para::Init
  VAR
    p0    : ^VirtualBase;
    paras : ARRAY[0..MAX_ALARMPARA-1] of UDINT; 
    anz   : UDINT;
  END_VAR

  // increase init-counter
  sInitCnt += 1;
  
  if  ((sInitCnt = ALARM_INITCALL) | (_FirstScan = true)) // HubChr V0.6 user can choose a sooner init-run
    & (bInit = false)
  then
    _memset(#paras[0], 0, sizeof(paras));
    Config := Config.Read();
    Group  := Group.Read();
    anz    := GetParaID(#paras[0]);

    if(PV_AlarmBuffer = NIL) then
      _LookUpEmbed_C("_AlarmXBuffer1", #PV_AlarmBuffer, #p0);
    end_if;

    if(PV_AlarmBuffer <> NIL) then
      Config$UDINT := PV_AlarmBuffer^.RegisterAlarmXPara(this, Config$UDINT, Group$UDINT, anz, #paras[0]);
    end_if;
    
    // init is done
    bInit := true;
  end_if;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmX0Para::QuitAlarm

  if(Acknow = 0) then
    Acknow := 1;
    if(IsClientConnected(#Acknow) = TRUE) then
      Acknow.Write(Acknow);
    end_if;

    if(PV_AlarmBuffer <> NIL) then
      Config := Config.Read();
      PV_AlarmBuffer^.ActionAlarm(this$UDINT, Config$UDINT, 0, -1, 0, NIL);
    end_if;
  end_if;
  
END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmX0Para::ClassSvr::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
  paras : ARRAY[0..MAX_ALARMPARA-1] of DINT;
  anz : udint;
END_VAR

  if(input = 255) then
    QuitAlarm();
  else 
    if(ClassSvr <> input) then
      if(PV_AlarmBuffer <> NIL) then
        Acknow   := 0; // prepaire alarm to quit
        ClassSvr := input;
        Group    := Group.Read();
        anz      := GetParaVal(#paras[0]);
        PV_AlarmBuffer^.ActionAlarm(this$UDINT, Config$UDINT, Group$UDINT, ClassSvr, anz, #paras[0]);
      end_if;
    end_if;
  end_if;

  result := 0;

END_FUNCTION
#pragma warning (disable:73)
FUNCTION VIRTUAL GLOBAL _AlarmX0Para::GetParaID
  VAR_INPUT
    ppara		: ^UDINT;
  END_VAR
  VAR_OUTPUT
    retcode		: UDINT;
  END_VAR

  retcode := 0;

END_FUNCTION
FUNCTION VIRTUAL GLOBAL _AlarmX0Para::GetParaVal
VAR_INPUT
	ppara		: ^DINT;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  retcode := 0;

END_FUNCTION
#pragma warning (default:73)
