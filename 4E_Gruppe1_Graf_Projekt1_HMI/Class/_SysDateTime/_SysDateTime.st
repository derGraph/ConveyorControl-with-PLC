//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_SysDateTime"
	Revision           = "0.5"
	GUID               = "{CBF432E1-D3B3-439C-B706-A16641D03D70}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "provides SystemTime and SystemDate">
	<Channels>
		<Server Name="DayOfWeek" GUID="{9932021F-6C7A-41A0-8E00-CEBE786433C1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SysDate" GUID="{0B477768-BD5B-4C0B-BCA5-9E3AA91B2C1D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="SysTime" GUID="{01AA06EB-72AD-4AE7-ACC7-2A3FF23A3213}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="DoSummerTime" Required="true" Internal="false" DefValue="0" Comment="Summertime: 0..Off; 1..Europe; 2..USA, Canada, Mexico"/>
		<Client Name="SummerTime" Required="true" Internal="true"/>
		<Client Name="System" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.5" Date="2011-09-28" Author="kolott" Company="sigmatek" Description="betterment datatypeconversion"/>
	</RevDoku>
	<Network Name="_SysDateTime">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "SummerTime"
				GUID       = "{8D5F918A-029E-4326-8E46-99E55244583F}"
				Class      = "Ram"
				Position   = "(270,150)"
				Visualized = "false">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SummerTime" Destination="SummerTime.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_SysDateTime : CLASS
  //Servers:
	SysDate 	: SvrChCmd_HDINT;
	SysTime 	: SvrCh_HDINT;
	DayOfWeek 	: SvrCh_DINT;
  //Clients:
	SummerTime 	: CltChCmd_Ram;
	System 	: CltChCmd_System;
	DoSummerTime 	: CltCh_DINT;
  //Variables:
		OldHour 	: UINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GetDayOfWeek
		VAR_INPUT
			day 	: UINT;
			month 	: UINT;
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GetDayOfMonth
		VAR_INPUT
			month 	: UINT;
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION DateSet
		VAR_INPUT
			dte 	: UDINT;
		END_VAR;
	
	FUNCTION TimeSet
		VAR_INPUT
			tme 	: UDINT;
		END_VAR;
	
	FUNCTION DoSetNeeds;
	
	FUNCTION Emboly
		VAR_INPUT
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SummerWinterTime
		VAR_INPUT
			xdate 	: UDINT;
			xtime 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION IncDecDate
		VAR_INPUT
			pdte 	: ^UDINT;
			day 	: DINT;
		END_VAR;
	
	FUNCTION CheckSummerTime
		VAR_INPUT
			dte 	: UDINT;
			tme 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetDatePart
		VAR_INPUT
			part 	: UINT;
			value 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetTimePart
		VAR_INPUT
			part 	: UINT;
			value 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SysDate::Write
		VAR_INPUT
			input (EAX) 	: HDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SysTime::Write
		VAR_INPUT
			input (EAX) 	: HDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: HDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Ram
#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _SysDateTime::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__SYSDATETIME
0$UINT, 5$UINT, (SIZEOF(::_SysDateTime))$UINT, 
3$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3931827689), "_SysDateTime", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_SysDateTime.SysDate.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1714210210), "SysDate", 
(::_SysDateTime.SysTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2737203869), "SysTime", 
(::_SysDateTime.DayOfWeek.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1396401802), "DayOfWeek", 
//Clients:
(::_SysDateTime.SummerTime.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2066431768), "SummerTime", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::_SysDateTime.System.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(968218125), "System", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
(::_SysDateTime.DoSummerTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2510418087), "DoSummerTime", 
END_FUNCTION


#define USER_CNT__SysDateTime 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__SysDateTime] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _SysDateTime::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__SysDateTime, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	SysDate.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SysDate.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SysTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SysTime::Write() );
	IF SysTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\_SysDateTime\_SysDateTime_00_00.st*********************



 



#define IS_CLOCK

#define SUMTIM_FALSE 16#7FABCDE0
#define SUMTIM_TRUE  16#7FABCDE1


FUNCTION VIRTUAL GLOBAL _SysDateTime::Init
 #ifdef IS_CLOCK
  var
    dte : SYSDATE;
    tmp : uint; 
    val : dint;
  end_var

  if(_firstscan) then
    System.GetSysDate(#dte);
    tmp := GetDayOfWeek(dte.wDay, dte.wMonth, dte.wYear); 
    if(tmp <> dte.wDayOfWeek) then
      dte.wDayOfWeek := tmp;
      System.SetSysDate(#dte);
    end_if;
    
    Background(0);
    
    DoSummerTime := DoSummerTime.Read();
    
    if(DoSummerTime) then
      val := SummerTime.Read();
      if((val <> SUMTIM_TRUE)&(val <> SUMTIM_FALSE)) then
        SummerTime.Write(SummerWinterTime(SysDate, SysTime));
      else
        CheckSummerTime(SysDate, SysTime);
      end_if;
    end_if;
  end_if; 
 #endif
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SysDateTime::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
 #ifdef IS_CLOCK
  VAR
    tme : SYSTIME;  
    dte : SYSDATE;
    tmp  : UDINT;  
  END_VAR

  // YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW
  // HHHHHHHHNNNNNNNNSSSSSSSSxxxxxxxx
  
  // y .... year
  // m .... month
  // d .... day
  // w .... day of week
  // h .... hour
  // n .... minutes
  // s .... second
  // x .... initialized with 0

  System.GetSysTime(#tme); 
  System.GetSysDate(#dte);

//  SHour     := tme.wHour;
//  SMinute   := tme.wMinute;
//  SSecond   := tme.wSecond;

//  SDay      := tme.wHour;
//  SMonth    := tme.wMinute;
//  SYear     := tme.wSecond;


  tmp       := tme.wHour and 16#FF; 
  tmp       := (tmp shl 8) or (tme.wMinute and 16#FF); 
  tmp       := (tmp shl 8) or (tme.wSecond and 16#FF);
  SysTime   := (tmp shl 8); 

  tmp       := dte.wYear; 
  tmp       := (tmp shl 4) or dte.wMonth; 
  tmp       := (tmp shl 8) or dte.wDay;
  tmp       := (tmp shl 4) or dte.wDayOfWeek; 
  SysDate   := tmp;

  DayOfWeek := dte.wDayOfWeek;
  
  DoSummerTime := DoSummerTime.Read();
  
  if(DoSummerTime) then
    if(tme.wHour <> OldHour) then
      OldHour := tme.wHour;
      if((OldHour = 2)|(OldHour = 3)) then
        CheckSummerTime(SysDate, SysTime);
      end_if;
    end_if;
  end_if;
  
 #else
  VAR
    tmp  : UDINT;  
    th : udint;
    tm : udint;
    ts : udint;
  END_VAR
  
  tmp := ops.tabsolute / 1000;
  ts  := tmp mod 60; tmp := tmp / 60;
  tm  := tmp mod 60; tmp := tmp / 60;
  th  := tmp mod 24;

  tmp      := th; 
  tmp      := (tmp shl 8) or (tm); 
  tmp      := (tmp shl 8) or (ts);
  SysTime  := (tmp shl 8); 
 #endif
 
	state     := READY;

END_FUNCTION


FUNCTION _SysDateTime::GetDayOfWeek
	VAR_INPUT
		day 	: UINT;
		month 	: UINT;
		year 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
    days : udint; 
    maxs : uint; 
  END_VAR

  year  -= 1;
  maxs  := year / 4;
  maxs  -= year / 100;
  maxs  += year / 400;
  days  := ((TO_UDINT(year)) * 365) + maxs;

  while(month > 1) do
	  month -= 1;
    days  += GetDayOfMonth(month, year+1);
  end_while;
  
  days += day;

  retcode := TO_UINT(days mod 7);

END_FUNCTION


FUNCTION _SysDateTime::GetDayOfMonth
	VAR_INPUT
		month 	: UINT;
		year 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR

  retcode := 30;
  case month of
    1,3,5,7,8,10,12: retcode := 31;
                  2: retcode := 28;
                     if(Emboly(year) = true) then
                       retcode := 29;
                     end_if;
  end_case;

END_FUNCTION


FUNCTION _SysDateTime::Emboly
	VAR_INPUT
		year 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;

  if((year mod 4) = 0) then
    retcode := TRUE; 
    if((year mod 100) = 0) then
      retcode := FALSE; 
      if((year mod 400) = 0) then
        retcode := TRUE; 
      end_if; 
    end_if; 
  end_if; 

END_FUNCTION


FUNCTION _SysDateTime::TimeSet
	VAR_INPUT
		tme 	: UDINT;
	END_VAR
  VAR
    t : SYSTIME;
  END_VAR

  t.wHour   := TO_USINT((TO_UDINT(tme) shr 24) and 16#00FF);
  t.wMinute := TO_USINT((TO_UDINT(tme) shr 16) and 16#00FF);
  t.wSecond := TO_USINT((TO_UDINT(tme) shr  8) and 16#00FF); 
  System.SetSysTime(#t); 
  OldHour   := t.wHour;

END_FUNCTION


FUNCTION _SysDateTime::DateSet
	VAR_INPUT
		dte 	: UDINT;
	END_VAR
  VAR
    t : SYSDATE; 
  END_VAR
  
  t.wDay       := TO_USINT((TO_UDINT(dte) shr  4) and 16#00FF);
  t.wMonth     := TO_USINT((TO_UDINT(dte) shr 12) and 16#000F); 
  t.wYear      := TO_UINT((TO_UDINT(dte)  shr 16) and 16#FFFF);  
  t.wDayOfWeek := (TO_USINT(dte) and 16#0F) mod 7;
  t.wDayOfWeek := GetDayOfWeek(t.wDay, t.wMonth, t.wYear); 
  System.SetSysDate(#t);

END_FUNCTION


FUNCTION _SysDateTime::DoSetNeeds

  Background(0); 
  if(DoSummerTime) then
    SummerTime.Write(SummerWinterTime(SysDate, SysTime));
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SysDateTime::SysDate::Write
	VAR_INPUT
		input (EAX) 	: HDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: HDINT;
	END_VAR
  
  result := 0;
  
 #ifdef IS_CLOCK
  if(input$dint <> -1) then
    DateSet(input$udint);
    DoSetNeeds();
  else
    result := ACCESS_DENIED;
  end_if;
 #endif
 
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SysDateTime::SysTime::Write
	VAR_INPUT
		input (EAX) 	: HDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: HDINT;
	END_VAR
  
  result := 0;
  
 #ifdef IS_CLOCK
  if(input$dint <> -1) then
    TimeSet(input$udint);
    DoSetNeeds();
  else
    result := ACCESS_DENIED;
  end_if;
 #endif


END_FUNCTION


FUNCTION _SysDateTime::SummerWinterTime
	VAR_INPUT
		xdate 	: UDINT;
		xtime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    dow : uint;
    day, year : uint;
    bdate, edate : udint;
  END_VAR
  
  retcode := SUMTIM_FALSE;  // normaltime (winter)

  if(DoSummerTime > 0) then
    year := to_uint((xdate shr 16) and 16#0000FFFF);

    if(DoSummerTime = 2) then
      // first sunday in april
      day := 1;
      dow := GetDayOfWeek(day, 4, year);
      if(dow > 0) then
        day := 8 - dow;
      end_if;
      bdate := ((xdate and 16#FFFF0000) or 16#4000) or (day shl 4);
    else
      // last sunday in march
      day := 25;
      dow := GetDayOfWeek(day, 3, year);
      if(dow > 0) then 
        day := 32 - dow;
      end_if;
      bdate := ((xdate and 16#FFFF0000) or 16#3000) or (day shl 4);
    end_if;
   
    // last sunday in october
    day := 25;
    dow := GetDayOfWeek(day, 10, year);
    if(dow > 0) then 
      day := 32 - dow;
    end_if;
    edate := ((xdate and 16#FFFF0000) or 16#A000) or (day shl 4);
  
    if((xdate = bdate)&(xtime >= 16#02000000)) then
      retcode := SUMTIM_TRUE;
    elsif(xdate > bdate) then
      retcode := SUMTIM_TRUE;
    end_if;
    
    if((xdate = edate)&(xtime >= 16#03000000)) then
      retcode := SUMTIM_FALSE;
    elsif(xdate > edate) then
      retcode := SUMTIM_FALSE;
    end_if;
  
  end_if;
  
END_FUNCTION


FUNCTION _SysDateTime::CheckSummerTime
	VAR_INPUT
		dte 	: UDINT;
		tme 	: UDINT;
	END_VAR
  VAR
    val : dint;
  END_VAR

  val := SummerWinterTime(dte, tme);
  if(val <> SummerTime.Read()) then
    if(val = SUMTIM_TRUE) then
      // turn to summertime
      if((tme and 16#FF000000) < 16#17000000) then
        tme += 16#01000000;
      else
        tme := tme and 16#00FFFFFF;
        IncDecDate(#dte, 1);
        DateSet(dte);
      end_if;
      TimeSet(tme);
      SummerTime.Write(SUMTIM_TRUE);
    else
      // turn to wintertime
      if((tme and 16#FF000000) > 16#00000000) then
        tme -= 16#01000000;
      else
        tme := (tme and 16#00FFFFFF) or 16#17000000;
        IncDecDate(#dte, -1);
        DateSet(dte);
      end_if;
      TimeSet(tme);
      SummerTime.Write(SUMTIM_FALSE);
    end_if;
  end_if;

END_FUNCTION


FUNCTION _SysDateTime::IncDecDate
	VAR_INPUT
		pdte 	: ^UDINT;
		day 	: DINT;
	END_VAR
  VAR
    t : SYSDATE;
    dte : udint;
    no : uint;
  END_VAR
  
  dte := pdte^;
  
  t.wDay   := TO_USINT((TO_UDINT(dte) shr  4) and 16#00FF);
  t.wMonth := TO_USINT((TO_UDINT(dte) shr 12) and 16#000F); 
  t.wYear  := TO_UINT((TO_UDINT(dte)  shr 16) and 16#FFFF);  

  if(day > 0) then
    no := GetDayOfMonth(t.wMonth, t.wYear);
    if(t.wDay >= no) then
      t.wDay   := 1;
      t.wMonth += 1;
      if(t.wMonth > 12) then
        t.wMonth := 1;
        t.wYear += 1;
      end_if;
    else
      t.wDay += 1;
    end_if;
  else
    if(t.wDay <= 1) then
      t.wMonth -= 1;
      if(t.wMonth = 0) then
        t.wMonth := 12;
        t.wYear  -= 1;
      end_if;
      t.wDay   := GetDayOfMonth(t.wMonth, t.wYear);
    else
      t.wDay -= 1;
    end_if;
  end_if;
  
  dte := GetDayOfWeek(t.wDay, t.wMonth, t.wYear);
  dte := (dte shl 4) or t.wMonth; 
  dte := (dte shl 8) or t.wDay;
  dte := (dte shl 4) or t.wDayOfWeek; 
  
  pdte^ := dte;

END_FUNCTION


FUNCTION GLOBAL _SysDateTime::SetDatePart
	VAR_INPUT
		part 	: UINT;
		value 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    dte : SYSDATE;
  END_VAR

  retcode := false;
  System.GetSysDate(#dte);
  
  if(part = 0) then
    dte.wYear := value;
  elsif(part = 1) then
    dte.wMonth := value;
  elsif(part = 2) then
    dte.wDay := value;
  end_if;
  
  if((dte.wYear >= 1990) & (dte.wYear <= 2100)) then
    if((dte.wMonth > 0) & (dte.wMonth < 13)) then
      if((dte.wDay > 0)&(dte.wDay <= GetDayOfMonth(dte.wMonth, dte.wYear))) then
  
        dte.wDayOfWeek := GetDayOfWeek(dte.wDay, dte.wMonth, dte.wYear); 
        System.SetSysDate(#dte); 
        DoSetNeeds();
        retcode := true;
        
      end_if;
    end_if;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _SysDateTime::SetTimePart
	VAR_INPUT
		part 	: UINT;
		value 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    tme : SYSTIME;  
  END_VAR

  retcode := false;
  System.GetSysTime(#tme);

  if(part = 0) then
    tme.wHour := value;
  elsif(part = 1) then
    tme.wMinute := value;
  elsif(part = 2) then
    tme.wSecond := value;
  end_if;
  
  if((tme.wHour >= 0) & (tme.wHour <= 23)) then
    if((tme.wMinute >= 0) & (tme.wMinute <= 59)) then
      if((tme.wSecond >= 0) & (tme.wSecond <= 59)) then
    
        System.SetSysTime(#tme); 
        OldHour := tme.wHour;
        DoSetNeeds();
        retcode := true;
        
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

