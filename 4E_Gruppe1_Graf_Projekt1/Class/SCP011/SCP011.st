//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SCP011_DEVICE_ID 1000 
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SCP011"
	Revision           = "1.31"
	GUID               = "{B1CDB801-2B72-435F-87B2-575C3868739A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\scp.ico"
	SharedCommandTable = "true"
	Objectsize         = "(690,120)">
	<Channels>
		<Server Name="CanOut" GUID="{B40697D2-72DD-4373-9EBB-356D663D901A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassState">
		</Server>
		<Server Name="DesignerPrjConfigCRC" GUID="{BDD5466D-9884-490D-935E-1FE5999851A3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the CRC of the SafetyDesigner project.&#13;&#10;Compare this with the CRC shown in the SafetyDesigner when printing the project (in the preview or on paper)"/>
		<Server Name="DesignerPrjName" GUID="{56DD23E8-9CF2-44D9-A6CD-E4ED9249DEB4}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the name of the actual safety designer project"/>
		<Server Name="DesignerPrjRev" GUID="{49EFA2FB-5452-4D41-9DD8-F00D66129074}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the revision of the actual safety designer project"/>
		<Server Name="ErrorState" GUID="{AF7FA2CA-DC6C-45B2-9642-C98F6A715A01}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: no error&#13;&#10;1: error&#13;&#10;2: communication timeout on input data from other safety modules"/>
		<Server Name="FastUnsafeInputs" GUID="{23403FF9-AC1A-4AAC-9260-8AB672215B62}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="write the 32 fast unsafe inputs to this server (bit coded)"/>
		<Server Name="FastUnsafeOutputs" GUID="{5CD92126-DD07-4E5E-BC53-253B9C238A39}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="this server shows the actual state of the 32 fast unsafe outputs (bit coded)"/>
		<Server Name="FirmwareVersion" GUID="{7B4D27A3-FAD2-4A9E-B965-241BA82CB674}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware version&#13;&#10;&#13;&#10;Format:&#13;&#10;16#XXXXYYYY&#13;&#10;&#13;&#10;XXXX = Major Revision&#13;&#10;YYYY = Minor Revision"/>
		<Server Name="QuitComError" GUID="{E36A3D78-7192-4865-9924-19F6C8B8C872}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write to this server to quit communication errors (indicated if Server ErrorState = 2)&#13;&#10;This server can also quit general errors (Server ErrorState = 1) if the safety.dlm is used.&#13;&#10;&#13;&#10;To detect the used quit method, read the server directly after writing. In both cases the error quitting is done asynchronously (= not immediately).&#13;&#10;&#13;&#10;Server shows actual quit-state&#13;&#10;  2..busy with quitting general errors (safety dll version 6 or higher required)&#13;&#10;  1..busy with quitting communication error&#13;&#10;  0..ready&#13;&#10; -1..error at creating a new safety state&#13;&#10; -2..failed to disable user prompt for quit error&#13;&#10; -3..failed to select module via safety number&#13;&#10; -4..error at establishing connection to module (safety designer must not be online at the same time!)&#13;&#10; -5..failed to send the quit error command to the module&#13;&#10; -6..failed to delete the created safety state"/>
		<Server Name="RunState" GUID="{AF354317-7AA5-413D-BCF8-F66DE696052C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: not running&#13;&#10;1: running in operational or temporary operational mode"/>
		<Server Name="SafetyNumber" GUID="{4D5F6195-39E9-4C6C-A472-0766346C7A77}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the unique safety number of this module"/>
		<Server Name="SafetyRetryCounter" GUID="{3B4D0CFA-9F84-461A-8952-DBBD577A2C0E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the amount of all retries on the safety bus."/>
		<Server Name="SafetyState" GUID="{2172B99B-54F1-4A0D-A51C-FFA0FE1206E6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of safety module&#13;&#10;&#13;&#10;_ModuleNotFound:&#13;&#10; - Module has not been found at the given position&#13;&#10;&#13;&#10;_WaitForSynchronicity:&#13;&#10; - Waiting to get synchrony with interacting modules&#13;&#10;&#13;&#10;_SafetyClassOK:&#13;&#10; - Module has been found and no errors reported&#13;&#10;&#13;&#10;_MemAllocFailed: &#13;&#10; - Failed to allocate or reallocate some memory for the module&#13;&#10;&#13;&#10;_ReadFWVerFailed:&#13;&#10; - Failed to read firmware version of module&#13;&#10;&#13;&#10;_ReinitConfig:&#13;&#10; - Only for CPU: Config of CPU has changed and update is in progress&#13;&#10;&#13;&#10;_ModFromCfgNotFound (Only for CPU):&#13;&#10; - Module in configuration, which is not physically available and HW-Class is placed&#13;&#10; - Module in configuration, which is not physically available and no HW-Class is placed&#13;&#10; - Module in configuration, which is not a CDIAS module (according to it&apos;s HW-Path)&#13;&#10;&#13;&#10;_UnsafeVarNotFound (Only for CPU):&#13;&#10; - Couldn&apos;t find an unsafe variable in the project. Compare spelling in Designer and in project.&#13;&#10;&#13;&#10;_UnknownCfgError (Only for CPU):&#13;&#10; - Error in reading config or creating routing tables occured.&#13;&#10;&#13;&#10;_AsyncComError: &#13;&#10; - Too many consecutive asynchronous commands failed! Please contact Sigmatek Support! &#13;&#10; &#13;&#10;_DOsIncreasedRestartApp: &#13;&#10; - Number or size of module accesses increased with new safety project! &#13;&#10; - =&gt; Can&apos;t continue, because the new data is not covered by the actual accesses! Restart Application! &#13;&#10; &#13;&#10;_LostPowerSupply: &#13;&#10; - The power supply of the safe CPU has been lost. &#13;&#10; &#13;&#10;_WrongSafetyHW: &#13;&#10; - The Safety objects in the project do not match the physical modules. &#13;&#10; - For every physical module a safety object must be placed in the project!"/>
		<Server Name="SdiasSafetyOut" GUID="{54985FE6-C9A9-466E-A89F-A7870C304709}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ServiceMode" GUID="{34BDABFC-5252-4C0F-A017-322BA6E69CF9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: operational mode&#13;&#10;1: service mode or temporary operational mode&#13;&#10;2: check configuration phase"/>
		<Server Name="ValidationButtonState" GUID="{908447C4-934E-4CA7-A488-198506188D9D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the validation button&#13;&#10;0: Validation button not used at the moment&#13;&#10;1: Select a command by pressing the button&#13;&#10;2: Command is executed&#13;&#10;3: Error in module"/>
		<Client Name="SdiasSafetyManager1" Required="true" Internal="true"/>
		<Client Name="ServerUpdateTime" Required="false" Internal="false" Comment="Time in ms, how long the Servers (unsafe variables in Safety Designer) should take to update.&#13;&#10;This Client is automatically updated, if the given time is too short to handle with the current amount of servers."/>
	</Channels>
	<RevDoku>
		<Owner Company=" Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.31" Date="31.08.2015" Author="RamAnd" Company="Sigmatek" Description="If no configuration is available at the CPU, the optional settings are now ignored since they are not available in this state. This could have lead to SDIAS errors if safety modules were set to required."/>
		<Dokumentation Revision="1.30" Date="31.07.2015" Author="RamAnd" Company="Sigmatek" Description="Added server DesignerPrjConfigCRC to show the CRC of the SafetyDesigner project.&#13;&#10;Added support for optional Safe-IOs (configured in SafetyDesigner)."/>
		<Dokumentation Revision="1.29" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.28" Date="08.06.2015" Author="PieSte" Company="Sigmatek" Description="Changes at Lhd-file for &quot;TypeId&quot; were not taken over."/>
		<Dokumentation Revision="1.27" Date="21.05.2015" Author="PieSte" Company="Sigmatek" Description="Corrected spelling attribute &quot;TypeId&quot; at lhd-file."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic" Company="Sigmatek" Description="Added support for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="14.04.2015" Author="RamAnd" Company="Sigmatek" Description="Configured sync out of pll so firmware can detect a reset of the application."/>
		<Dokumentation Revision="1.23" Date="11.02.2015" Author="RamAnd&#13;&#10;&#13;&#10;EisMic&#13;&#10;PieSte" Company="Sigmatek" Description="If slave configurations have been used, it has been necessary to restart the application more than once.&#13;&#10;SDO Requests of the SafetyCPU now get disabled during initialisation of the module to prevent timeouts at the SDO transfer. (Safety CIL-Version 1.2 needed)&#13;&#10;Wrong State at server SafetyState if an HBG was connected to the SCP.&#13;&#10;Corrected read spi data for hardwaretree in methode GetSPIDataFromID from SdiasBase."/>
		<Dokumentation Revision="1.22" Date="31.10.2014" Author="lanste" Company="Sigmatek" Description="Fixed error: Safe IO were displayed on wrong safety hardwareclass if the class is not required and not online.&#13;&#10;Fixed error: Safe IO were displayed on wrong safety hardwareclass if the hardware configuration did not match the project configuration."/>
		<Dokumentation Revision="1.21" Date="08.10.2014" Author="RamAnd" Company="Sigmatek" Description="If the project name or one of the unsafe variable names had more than 56 characters, the string has not been fetched correctly from the firmware."/>
		<Dokumentation Revision="1.20" Date="25.08.2014" Author="LanSte" Company="Sigmatek" Description="Moved defaut call of &apos;GetPointer2ObjectPath&apos; to last init phase, so that it can be overwritten by other classes. This allows the &apos;SdiasSafetyManager&apos; Class to correctly set its callbackpointer again."/>
		<Dokumentation Revision="1.19" Date="31.07.2014" Author="PieSte" Company="Sigmatek" Description="Added NewInst command in SdiasSafetyManager class to quit error from connected safety modules."/>
		<Dokumentation Revision="1.18" Date="21.07.2014" Author="LanSte" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.17" Date="17.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to quit other errors than communication errors server QuitComError."/>
		<Dokumentation Revision="1.16" Date="04.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to detect a periphery reset which may be caused by a lost power supply.&#13;&#10;Crash fixed, if there is no IO module or HGB projected."/>
		<Dokumentation Revision="1.15" Date="25.04.2014" Author="RamAnd" Company="Sigmatek" Description="If a module is plugged via VARAN during runtime, the state of the class was set to _SafetyClassOK too early. This could have caused problems with the PDOs."/>
		<Dokumentation Revision="1.14" Date="28.03.2014" Author="EisMic" Company="Sigmatek" Description="Added server SafetyRetryCounter which shows all retries of the safetybus."/>
		<Dokumentation Revision="1.13" Date="25.03.2014" Author="RamAnd" Company="Sigmatek" Description="Changed read out of SafetyConfiguration to speed up startup time."/>
		<Dokumentation Revision="1.12" Date="26.03.2014" Author="ZoePat" Company="Sigmatek" Description="A connected HBG didn&apos;t work if no other safetymodul was use."/>
		<Dokumentation Revision="1.11" Date="27.02.2014" Author="ZoePat" Company="Sigmatek" Description="Removed server LEDControl because this is not avaliable for this hardware."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;PieSte" Company="Sigmatek" Description="Invalid SDO Responses on the first SDO request to a module are now discarded. Now only a log message is shown instead of canceling the initialisation.&#13;&#10;Debug message if the number or size of DOs increased was too long and is now split up in 2 messages.&#13;&#10;Removed double assignment which could lead to a problem on ARM targets.&#13;&#10;Corrected handling of REAL variable which could lead to a memory problem on ARM targets.&#13;&#10;Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.0" Date="04.12.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SCP011">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{0AC3EFD3-D38E-407A-983F-BCC85BFC88DC}"
				Class      = "BusInterfaceSdias"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="CallCommand"/>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
				</Channels>
			</Object>
			<Object
				Name           = "SdiasSafetyManager1"
				GUID           = "{D23799B1-95D7-49AE-854F-7AE729DDEF49}"
				Class          = "SdiasSafetyManager"
				Position       = "(990,570)"
				Visualized     = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="CanOut"/>
					<Server Name="ClassSvr"/>
					<Server Name="DesignerPrjConfigCRC"/>
					<Server Name="DesignerPrjName"/>
					<Server Name="DesignerPrjRev"/>
					<Server Name="ErrorState"/>
					<Server Name="FastUnsafeInputs"/>
					<Server Name="FastUnsafeOutputs"/>
					<Server Name="FirmwareVersion"/>
					<Server Name="QuitComError"/>
					<Server Name="RunState"/>
					<Server Name="SafetyNumber"/>
					<Server Name="SafetyRetryCounter"/>
					<Server Name="SafetyState"/>
					<Server Name="SdiasSafetyOut"/>
					<Server Name="ServiceMode"/>
					<Server Name="ValidationButtonState"/>
					<Server Name="VoltageOK"/>
					<Client Name="DeviceID" Value="SCP011_DEVICE_ID"/>
					<Client Name="ServerUpdateTime" Value="50"/>
					<Client Name="ToBusInterface"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(1848,210),(736,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1848,270),(736,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1848,450),(736,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1848,510),(736,510),"/>
			<Connection Source="this.SdiasSafetyOut" Destination="SdiasSafetyManager1.SdiasSafetyOut" Vertices="(1848,1350),(1676,1620),"/>
			<Connection Source="this.SdiasSafetyManager1" Destination="SdiasSafetyManager1.ClassSvr"/>
			<Connection Source="SdiasSafetyManager1.ServerUpdateTime" Destination="this.ServerUpdateTime" Vertices="(990,720),(38,570),"/>
			<Connection Source="SdiasSafetyManager1.ToBusInterface" Destination="_base.CallCommand" Vertices="(990,660),(736,630),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(1848,330),(736,330),"/>
			<Connection Source="this.SafetyState" Destination="SdiasSafetyManager1.SafetyState" Vertices="(1848,570),(1676,720),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.QuitComError" Destination="SdiasSafetyManager1.QuitComError" Vertices="(1848,810),(1676,1020),"/>
			<Connection Source="this.FirmwareVersion" Destination="SdiasSafetyManager1.FirmwareVersion" Vertices="(1848,870),(1676,1080),"/>
			<Connection Source="this.SafetyNumber" Destination="SdiasSafetyManager1.SafetyNumber" Vertices="(1848,930),(1676,1140),"/>
			<Connection Source="this.DesignerPrjName" Destination="SdiasSafetyManager1.DesignerPrjName" Vertices="(1848,1050),(1676,1320),"/>
			<Connection Source="this.DesignerPrjRev" Destination="SdiasSafetyManager1.DesignerPrjRev" Vertices="(1848,1110),(1676,1380),"/>
			<Connection Source="this.CanOut" Destination="SdiasSafetyManager1.CanOut" Vertices="(1848,1410),(1676,1680),"/>
			<Connection Source="this.SafetyRetryCounter" Destination="SdiasSafetyManager1.SafetyRetryCounter" Vertices="(1848,1470),(1676,1200),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(1848,390),(736,390),"/>
			<Connection Source="this.DesignerPrjConfigCRC" Destination="SdiasSafetyManager1.DesignerPrjConfigCRC" Vertices="(1848,990),(1676,1260),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using BusInterfaceSdias

SCP011 : CLASS
: BusInterfaceSdias
  //Servers:
	SafetyState 	: SvrCh_SafetyConfigStateType;
	RunState 	: SvrCh_DINT;
	ServiceMode 	: SvrCh_DINT;
	ErrorState 	: SvrCh_DINT;
	QuitComError 	: SvrCh_DINT;
	FirmwareVersion 	: SvrCh_HDINT;
	SafetyNumber 	: SvrCh_HDINT;
	DesignerPrjConfigCRC 	: SvrCh_HDINT;
	DesignerPrjName 	: SvrChCmd_UDINT;
	DesignerPrjRev 	: SvrChCmd_UDINT;
	ValidationButtonState 	: SvrCh_DINT;
	FastUnsafeInputs 	: SvrCh_BDINT;
	FastUnsafeOutputs 	: SvrCh_BDINT;
	SdiasSafetyOut 	: SvrChCmd_DINT;
	CanOut 	: SvrChCmd_DINT;
	SafetyRetryCounter 	: SvrCh_DINT;
  //Clients:
	SdiasSafetyManager1 	: CltChCmd_SdiasSafetyManager;
	ServerUpdateTime 	: CltCh_UDINT;
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FetchDiagState;
	
	FUNCTION VIRTUAL GLOBAL GetDiagState
		VAR_INPUT
			pDiagState 	: ^SafetyDiagState;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FetchDiagInfo
		VAR_INPUT
			ucChoice 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDiagInfo
		VAR_INPUT
			pDiagInfo 	: ^SafetyDiagInfo;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyState::Read
		VAR_OUTPUT
			output (EAX) 	: SafetyConfigStateType;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitComError::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitComError::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FirmwareVersion::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyNumber::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DesignerPrjConfigCRC::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeInputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeOutputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyRetryCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using SdiasSafetyManager


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SCP011::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SCP011
1$UINT, 31$UINT, (SIZEOF(::SCP011))$UINT, 
16$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1550718169), "SCP011", //Class
TO_UDINT(2368828999), "BusInterfaceSdias", 1$UINT, 17$UINT, //Baseclass
//Servers:
(::SCP011.SafetyState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1504224158), "SafetyState", 
(::SCP011.RunState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2759549320), "RunState", 
(::SCP011.ServiceMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1978843086), "ServiceMode", 
(::SCP011.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::SCP011.QuitComError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1389350282), "QuitComError", 
(::SCP011.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SCP011.SafetyNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2430374202), "SafetyNumber", 
(::SCP011.DesignerPrjConfigCRC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(349909197), "DesignerPrjConfigCRC", 
(::SCP011.DesignerPrjName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2397083450), "DesignerPrjName", 
(::SCP011.DesignerPrjRev.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2854741250), "DesignerPrjRev", 
(::SCP011.ValidationButtonState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2335086012), "ValidationButtonState", 
(::SCP011.FastUnsafeInputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1891345754), "FastUnsafeInputs", 
(::SCP011.FastUnsafeOutputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(766673388), "FastUnsafeOutputs", 
(::SCP011.SdiasSafetyOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1660330439), "SdiasSafetyOut", 
(::SCP011.CanOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4133122455), "CanOut", 
(::SCP011.SafetyRetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1159647258), "SafetyRetryCounter", 
//Clients:
(::SCP011.SdiasSafetyManager1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(837370902), "SdiasSafetyManager1", TO_UDINT(2292222393), "SdiasSafetyManager", 1$UINT, 25$UINT, 
(::SCP011.ServerUpdateTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(247674937), "ServerUpdateTime", 
END_FUNCTION


#define USER_CNT_SCP011 24

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SCP011] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SCP011::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= BusInterfaceSdias::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SCP011;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #FetchDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #GetDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #FetchDiagInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetDiagInfo();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyState.pMeth			:= StoreMethod( #SafetyState::Read(), #M_NO_F() );
	IF SafetyState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitComError.pMeth			:= StoreMethod( #QuitComError::Read(), #QuitComError::Write() );
	IF QuitComError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FirmwareVersion.pMeth			:= StoreMethod( #FirmwareVersion::Read(), #M_NO_F() );
	IF FirmwareVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyNumber.pMeth			:= StoreMethod( #SafetyNumber::Read(), #M_NO_F() );
	IF SafetyNumber.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DesignerPrjConfigCRC.pMeth			:= StoreMethod( #DesignerPrjConfigCRC::Read(), #M_NO_F() );
	IF DesignerPrjConfigCRC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjRev.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjRev.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjRev.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeInputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeInputs::Write() );
	IF FastUnsafeInputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeOutputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeOutputs::Write() );
	IF FastUnsafeOutputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SdiasSafetyOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SdiasSafetyOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasSafetyOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CanOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CanOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyRetryCounter.pMeth			:= StoreMethod( #SafetyRetryCounter::Read(), #M_NO_F() );
	IF SafetyRetryCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SCP011::SafetyState::Read
	VAR_OUTPUT
		output (EAX) 	: SafetyConfigStateType;
	END_VAR

	SafetyState := SdiasSafetyManager1.SafetyState.Read();
	output := SafetyState;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::QuitComError::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	QuitComError := SdiasSafetyManager1.QuitComError.Read();
	output := QuitComError;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::QuitComError::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	QuitComError := input;
	result := SdiasSafetyManager1.QuitComError.Write(QuitComError);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::FirmwareVersion::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	FirmwareVersion := SdiasSafetyManager1.FirmwareVersion.Read();
	output := FirmwareVersion;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::SafetyNumber::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	SafetyNumber := SdiasSafetyManager1.SafetyNumber.Read();
	output := SafetyNumber;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::FastUnsafeInputs::Write
	VAR_INPUT
		input (EAX) 	: BDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: BDINT;
	END_VAR

	FastUnsafeInputs := input;
	result := SdiasSafetyManager1.FastUnsafeInputs.Write(FastUnsafeInputs);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	pRtRefreshData : ^t_RtRefresh;
  END_VAR

	ret_code := READY;
  
	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		SDIAS_SET_RT_DATA:
      pRtRefreshData        := pPara^.aPara[0]$^t_RtRefresh;
      RunState              := pRtRefreshData^.LEDRunState;
      ServiceMode           := pRtRefreshData^.LEDServiceMode;
      ErrorState            := pRtRefreshData^.LEDErrorState;
      ValidationButtonState := pRtRefreshData^.LEDValidationButtonState;
      FastUnsafeOutputs     := pRtRefreshData^.FastUnsafeOutputs;
      
//**********************************************************************************************************************************************************
		SDIAS_SET_SAFETY_STATE:
      SafetyState := pPara^.aPara[0]$SafetyConfigStateType;
      
//**********************************************************************************************************************************************************
		SDIAS_SET_ASY_STATE:
      QuitComError := pPara^.aPara[0]$^t_AsyRefresh^.QuitComError;
  
//**********************************************************************************************************************************************************

  ELSE
    ret_code := BusInterfaceSdias::ClassState::NewInst(pPara, pResult);
	END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::FastUnsafeOutputs::Write
	VAR_INPUT
		input (EAX) 	: BDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: BDINT;
	END_VAR

	result := SdiasSafetyManager1.FastUnsafeOutputs.Write(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::SafetyRetryCounter::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SafetyRetryCounter := SdiasSafetyManager1.SafetyRetryCounter.Read();
	output := SafetyRetryCounter;

END_FUNCTION


FUNCTION VIRTUAL SCP011::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := SCP011_DEVICE_ID;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SCP011::FetchDiagState

  SdiasSafetyManager1.FetchDiagState();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::GetDiagState
	VAR_INPUT
		pDiagState 	: ^SafetyDiagState;
	END_VAR
	VAR_OUTPUT
		StateReady 	: BOOL;
	END_VAR
  
  StateReady := SdiasSafetyManager1.GetDiagState(pDiagState);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::FetchDiagInfo
	VAR_INPUT
		ucChoice 	: USINT;
	END_VAR

  SdiasSafetyManager1.FetchDiagInfo(ucChoice);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCP011::GetDiagInfo
	VAR_INPUT
		pDiagInfo 	: ^SafetyDiagInfo;
	END_VAR
	VAR_OUTPUT
		StateReady 	: BOOL;
	END_VAR
  
  StateReady := SdiasSafetyManager1.GetDiagInfo(pDiagInfo);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SCP011::DesignerPrjConfigCRC::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	DesignerPrjConfigCRC := SdiasSafetyManager1.DesignerPrjConfigCRC.Read();
	output := DesignerPrjConfigCRC;

END_FUNCTION
