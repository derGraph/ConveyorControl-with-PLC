//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

// always allocate blocks for 5 more SDOs
#define SB_SDO_BUFFER_ALLOC_BLOCK 5

// time between the CRC-Checks (CRC-Check to find out if configuration has changed)
#define SB_CRC_CHECK_TIME  5000

// time between we read out the retrycounter from the module.
#define SB_RETRY_COUNTER_WAIT_TIME 10000

#define SB_TDO_BUFFER_SIZE 50

// time for SDO transfer
#define SB_SDO_TRANSFERTIME 30 // maximum measured time at mover was 22ms + 3ms reserve

// timeout for optional modules to be synchron
#define SB_OPTIONAL_MODULE_SYNC_TIMEOUT  5000

// maximum number of tries to execute an asynchronous command (5 = if 5 consecutive tries to make an asynchronous communication fail, the class goes into error _AsyncComError)
#define SB_SDO_MAX_TRIES 5

#define SB_RETRY_COUNTER_AVAILABLE_MAJOR_REV 1000
#define SB_RETRY_COUNTER_AVAILABLE_MINOR_REV 338

// if defined, the DO traffic is monitored
//#define DO_DEBUG
#ifdef DO_DEBUG
#pragma message("DO_DEBUG for Safety-Modules activated! Needs more CPU ressources!")
#endif
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include <.\lsl_st_safety.h>
#include "..\..\Class\SafetyManager\SafetyManager.h"
#include "..\..\Source\BusInterface.h"
#include <.\lsl_st_hardwaretree.h>
#include "..\..\Class\SafetyBase\SafetyBase.h"

(*!
<Class
	Name               = "SafetyBase"
	Revision           = "1.22"
	GUID               = "{DE113197-BA62-455D-972A-E86142490F19}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Safety.ico"
	SharedCommandTable = "true"
	Objectsize         = "(670,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{67AB2696-3263-4F45-BD48-D4D369A97C90}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="DesignerPrjConfigCRC" GUID="{3038A812-E957-49FC-8BF9-CE3F83724A8D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the CRC of the SafetyDesigner project.&#13;&#10;Compare this with the CRC shown in the SafetyDesigner when printing the project (in the preview or on paper)"/>
		<Server Name="ErrorState" GUID="{6C6502C8-DF9F-4132-873F-A34F9C7C3DA1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: no error&#13;&#10;1: error&#13;&#10;2: communication timeout on input data from other safety modules"/>
		<Server Name="FirmwareVersion" GUID="{E1AAA303-83A0-47BE-AC10-992514492ACE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware version&#13;&#10;&#13;&#10;Format:&#13;&#10;16#XXXXYYYY&#13;&#10;&#13;&#10;XXXX = Major Revision&#13;&#10;YYYY = Minor Revision"/>
		<Server Name="QuitComError" GUID="{0EBD0694-A5FF-4CB3-A61D-BF36093C80EC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write to this server to quit communication errors (indicated if Server ErrorState = 2)&#13;&#10;This server can also quit general errors (Server ErrorState = 1) if the safety.dlm is used.&#13;&#10;&#13;&#10;To detect the used quit method, read the server directly after writing. In both cases the error quitting is done asynchronously (= not immediately).&#13;&#10;&#13;&#10;Server shows actual quit-state&#13;&#10;  2..busy with quitting general errors (safety dll version 6 or higher required)&#13;&#10;  1..busy with quitting communication error&#13;&#10;  0..ready&#13;&#10; -1..error at creating a new safety state&#13;&#10; -2..failed to disable user prompt for quit error&#13;&#10; -3..failed to select module via safety number&#13;&#10; -4..error at establishing connection to module (safety designer must not be online at the same time!)&#13;&#10; -5..failed to send the quit error command to the module&#13;&#10; -6..failed to delete the created safety state"/>
		<Server Name="RunState" GUID="{C99BF07C-1BC3-42E0-94FB-EA630CC89640}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: not running&#13;&#10;1: running in operational or temporary operational mode"/>
		<Server Name="SafetyNumber" GUID="{321485A3-7324-4CCC-8782-9E9706187414}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the unique safety number of this module"/>
		<Server Name="SafetyRetryCounter" GUID="{BEAB07B8-808E-49B2-A7A0-1ECD7F02709C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the amount of all retries on the safety bus.&#13;&#10;-1 ... Retrycounter read out is not supported by this firmware version."/>
		<Server Name="SafetyState" GUID="{CB52C983-4A48-4E00-897F-ECF999D79DDF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of safety module&#13;&#10;&#13;&#10;_ModuleNotFound:&#13;&#10; - Module has not been found at the given position&#13;&#10;&#13;&#10;_WaitForSynchronicity:&#13;&#10; - Waiting to get synchrony with interacting modules&#13;&#10;&#13;&#10;_SafetyClassOK:&#13;&#10; - Module has been found and no errors reported&#13;&#10;&#13;&#10;_MemAllocFailed: &#13;&#10; - Failed to allocate or reallocate some memory for the module&#13;&#10;&#13;&#10;_ReadFWVerFailed:&#13;&#10; - Failed to read firmware version of module&#13;&#10;&#13;&#10;_ReinitConfig:&#13;&#10; - Only for CPU: Config of CPU has changed and update is in progress&#13;&#10;&#13;&#10;_ModFromCfgNotFound (Only for CPU):&#13;&#10; - Module in configuration, which is not physically available and HW-Class is placed&#13;&#10; - Module in configuration, which is not physically available and no HW-Class is placed&#13;&#10; - Module in configuration, which is not a CDIAS module (according to it&apos;s HW-Path)&#13;&#10;&#13;&#10;_UnsafeVarNotFound (Only for CPU):&#13;&#10; - Couldn&apos;t find an unsafe variable in the project. Compare spelling in Designer and in project.&#13;&#10;&#13;&#10;_UnknownCfgError (Only for CPU):&#13;&#10; - Error in reading config or creating routing tables occured.&#13;&#10;&#13;&#10;_AsyncComError: &#13;&#10; - Too many consecutive asynchronous commands failed! Please contact Sigmatek Support! &#13;&#10; &#13;&#10;_DOsIncreasedRestartApp: &#13;&#10; - Number or size of module accesses increased with new safety project! &#13;&#10; - =&gt; Can&apos;t continue, because the new data is not covered by the actual accesses! Restart Application! &#13;&#10; &#13;&#10;_LostPowerSupply: &#13;&#10; - The power supply of the safe CPU has been lost. &#13;&#10; &#13;&#10;_WrongSafetyHW: &#13;&#10; - The Safety objects in the project do not match the physical modules. &#13;&#10; - For every physical module a safety object must be placed in the project!"/>
		<Server Name="ServiceMode" GUID="{51045F15-D930-46AF-A124-ABCA55F4A3C5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: operational mode&#13;&#10;1: service mode or temporary operational mode&#13;&#10;2: check configuration phase"/>
		<Server Name="VoltageOK" GUID="{7BAF51E0-5487-49AA-B7CF-4C72E6316E08}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0: voltage of output/pulse output supply not ok&#13;&#10;1: voltage of output/pulse output supply ok"/>
		<Client Name="DeviceID" Required="true" Internal="false"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="ServerUpdateTime" Required="false" Internal="false" DefValue="50" Comment="Time in ms, how long the Servers (unsafe variables in Safety Designer) should take to update.&#13;&#10;This Client is automatically updated, if the given time is too short to handle with the current amount of servers."/>
		<Client Name="ToBusInterface" Required="true" Internal="false"/>
		<Client Name="ToStdLib" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_safety.h" Include="true"/>
			<File Path=".\Class\VaranManager_Base\VaranManager_Base.h" Include="false"/>
			<File Path=".\Class\SafetyManager\SafetyManager.h" Include="true"/>
			<File Path=".\Source\BusInterface.h" Include="true"/>
			<File Path=".\lsl_st_hardwaretree.h" Include="true"/>
			<File Path=".\Class\SafetyBase\SafetyBase.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.22" Date="31.07.2015" Author="RamAnd" Company="Sigmatek" Description="Added server DesignerPrjConfigCRC to show the CRC of the SafetyDesigner project."/>
		<Dokumentation Revision="1.21" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Improved Method DtoH."/>
		<Dokumentation Revision="1.20" Date="10.12.2014" Author="RamAnd" Company="Sigmatek" Description="If slave configurations have been used, it has been necessary to restart the application more than once."/>
		<Dokumentation Revision="1.19" Date="03.11.2014" Author="LanSte" Company="Sigmatek" Description="Prevented PostInitend overwritting previously set errorstates."/>
		<Dokumentation Revision="1.18" Date="08.10.2014" Author="RamAnd" Company="Sigmatek" Description="If the project name or one of the unsafe variable names had more than 56 characters, the string has not been fetched correctly from the firmware."/>
		<Dokumentation Revision="1.17" Date="17.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to quit other errors than communication errors server QuitComError."/>
		<Dokumentation Revision="1.16" Date="04.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to detect a periphery reset which may be caused by a lost power supply."/>
		<Dokumentation Revision="1.15" Date="25.04.2014" Author="RamAnd" Company="Sigmatek" Description="If a module is plugged via VARAN during runtime, the state of the class was set to _SafetyClassOK too early. This could have caused problems with the PDOs."/>
		<Dokumentation Revision="1.14" Date="22.04.2014" Author="EisMic" Company="Sigmatek" Description="Only readout safetyretrycounter when it is available from the firmware."/>
		<Dokumentation Revision="1.13" Date="10.04.2014" Author="RamAnd" Company="Sigmatek" Description="Removed test code from config acceleration change."/>
		<Dokumentation Revision="1.12" Date="28.03.2014" Author="EisMic" Company="Sigmatek" Description="Added Safety Retrycoutner."/>
		<Dokumentation Revision="1.11" Date="25.03.2014" Author="RamAnd" Company="Sigmatek" Description="Changed read out of SafetyConfiguration to speed up startup time."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Debug message if the number or size of DOs increased was too long and is now split up in 2 messages.&#13;&#10;Removed double assignment which could lead to a problem on ARM targets."/>
		<Dokumentation Revision="1.0" Date="19.08.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
</Class>
*)
SafetyBase : CLASS
	TYPE
#pragma pack(push, 1)
	  t_MoveSettings : STRUCT
	    EnableState : t_BusIFRunState;
	    MoveSettingsBusIF : t_UpdateDOMoveCfg;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  AdditionalPDOsType : STRUCT
	    InputMovSettings : t_MoveSettings;
	    HandlePDOWrite : UDINT;
	    pPDOWriteData : ^USINT;
	    ud_LocalMoveDestAddr : HDINT;
	    ud_LocalWriteHandle : HDINT;
	    ud_LocalWriteOffset : HDINT;
	  END_STRUCT;
#pragma pack(pop)
	  DiagLogSaveSSW :
	  (
	    GetLogHeader,
	    GetLogFileBlocks,
	    GetLogHeader2,
	    SaveLogFile
	  )$UDINT;
#pragma pack(push, 1)
	  GetStateResponseType : STRUCT
	    RuntimeState : USINT;
	    ConfigState : USINT;
	    LoginLevel : USINT;
	    ConfigCRC : UDINT;
	    ListHeaderCRC : UDINT;
	    ErrorCount : UINT;
	    InterfaceCRC : HDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  DiagStructType : STRUCT
	    UserWantsDiagState : BOOL;
	    UserDiagStateReady : BOOL;
	    UserGetStateResp : GetStateResponseType;
	    UserWantsDiagInfo : BOOL;
	    UserDiagInfoReady : BOOL;
	    UserGetDiagInfoResp : SafetyDiagInfo;
	    ucChoiceDiagInfo : USINT;
	    ucChoiceSaveLog : USINT;
	    DPNE : ARRAY [0..99] OF CHAR;
	    SavingLogInProgress : BOOL;
	    SavingLogSSW : DiagLogSaveSSW;
	    LogHeader : STRUCT
	      uControllerID : USINT;  //! <Type Comment="ID of µController (0 = µC1, else µC2)" Name="DiagStructType.LogHeader.uControllerID"/>
	      LogMemSize : UDINT;  //! <Type Comment="in Bytes" Name="DiagStructType.LogHeader.LogMemSize"/>
	      WriteCounter : UDINT;
	    END_STRUCT;
	    pLogFileMem : ^USINT;
	    LogMemToGet : UDINT;
	    ReadBaseAdr : UDINT;
	    BytesToGet : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  FirmwareVersionType : STRUCT
	    RevMinor : UDINT;
	    RevMajor : UINT;
	    ModuleType : UINT;
	    BootLoaderVer : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  FrameTypeType : BSINT
	  [
	    1 Cfg,
	    2 ToP,
	    3 Standard,
	    4 PDO,
	    5 TDO,
	    6 Reserved1,
	    7 Reserved2,
	    8 Response,
	  ];
#pragma pack(push, 1)
	  PathInfoType : STRUCT
	    p_us_Path : ^USINT;
	    p_us_PathComp : ^USINT;
	    ui_PathCompLen : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  PDOInputBuffer : STRUCT
	    ud_p2Buffer : UDINT;
	    us_PDOLen : USINT;
	    ud_HandleSourceDO : UDINT;
	    ud_MoveSourceAddr : UDINT;
	    ud_MoveSourceOffset : UDINT;
	    b_TimeSynchron : BOOL;
	    ud_SafetyNr : HDINT;
	    b_IsOptional : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  PDOMoverList : STRUCT
	    pThis : pVirtualBase;
	    pNext : ^PDOMoverList;
	  END_STRUCT;
#pragma pack(pop)
	  PDOMoveState :
	  (
	    _Invalid,
	    _Active,
	    _Inactive
	  )$UDINT;
#pragma pack(push, 1)
	  PDOType : STRUCT
	    CRC : HDINT;
	    Byte5_Zero : USINT;
	    FrameType : FrameTypeType;
	    Byte7_Zero : USINT;
	    Length : USINT;
	    SourceAdr : HDINT;
	    SourceAdrCopy : HDINT;
	    msTimeStamp : DINT;
	    DataAndCopy : ARRAY [0..107] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
	  pPDOMoverList : ^PDOMoverList;
#pragma pack(push, 1)
	  UnsafeIORoutingElement : STRUCT
	    ud_Thisp : UDINT;
	    ud_Address : HDINT;
	    sd_OldValue : DINT;
	    sd_NewValue4External : DINT;
	    UnsafeType : t_UnsafeVarType;
	    BitMask : BDINT
	    [
	    ];
	    NameLength : UINT;
	    pName : ^CHAR;
	    b_AlreadyTransmitted : BOOL;
	    b_IsValid : BOOL;
	    pNext : ^UnsafeIORoutingElement;
	  END_STRUCT;
#pragma pack(pop)
	  pUnsafeIORoutingElement : ^UnsafeIORoutingElement;
	  RequestType :
	  (
	    _NoOpenRequest,
	    _ReadData,
	    _ReadValues,
	    _WriteValues,
	    _GetCRC,
	    _SetBusReady,
	    _DiagState,
	    _DiagInfo,
	    _GetSafetyNbr:=8,
	    _GetFWVersion:=9,
	    _ReadRetryCounter
	  )$UDINT;
#pragma pack(push, 1)
	  RoutElement : STRUCT
	    ud_SafeNumber : HDINT;
	    ud_Thisp : UDINT;
	    p_CompressedPath : ^USINT;
	    ui_ComprPathLen : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDOHeader : STRUCT  //! <Type Public="true" Name="SDOHeader"/>
	    StdHeader : t_SDOStdHeader;
	    SrcAdr : HDINT;
	    DstAdr : HDINT;
	    SessId : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDORespStd : STRUCT
	    SDOHeader : SDOHeader;
	    us_Returncode : USINT;
	    us_Data : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDOBufferStructure : STRUCT
	    us_Status : USINT;
	    SDOStructure : SDORespStd;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDORequReadConfig : STRUCT
	    StdHeader : t_SDOStdHeader;
	    ud_Address : HDINT;
	    us_Length : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDORespReadConfig : STRUCT
	    StdHeader : t_SDOStdHeader;
	    us_Returncode : USINT;
	    us_Length : USINT;
	    ud_Data : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDOStdResp : STRUCT
	    StdHeader : t_SDOStdHeader;
	    us_Returncode : USINT;
	    us_Data : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDOviaPath : STRUCT
	    StdHeader : t_SDOStdHeader;
	    ZeroBytes : DINT;
	    TopologyPath : ARRAY [0..35] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
	  SetBusReadySSW :
	  (
	    WaitPDOsSyncron:=0,
	    WaitAllModulesSyncron:=1,
	    SendSetBusReady:=2,
	    SetBusReadyFinished:=3
	  )$UDINT;
#pragma pack(push, 1)
	  StandardFrameType : STRUCT
	    SDOHeader : t_SDOStdHeader;
	    aData : ARRAY [0..63] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DataObjectCheck : STRUCT
	    LastTime : UDINT;
	    TimeDiff : UDINT;
	    TimeDiffMin : UDINT;
	    TimeDiffMax : UDINT;
	    SameFrameCnt : DINT;
	    LastHeader : t_SDOStdHeader;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DynamicParameterHeader : STRUCT
	    Place : UDINT;
	    ID : UDINT;
	    Length : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_FastUnsafeIOs : BDINT
	  [
	  ];
#pragma pack(push, 1)
	  t_LastSDOCmd : STRUCT
	    StructItem : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_LogOnceMarker : BDINT
	  [
	    1 NoThisForUnsafeIn,
	    2 WrongUnsafeVarType,
	  ];
#pragma pack(push, 1)
	  t_PDOSizeInfo : STRUCT
	    Version : UDINT;
	    PDORdLen : USINT;
	    PDOIFRdLen : USINT;
	    PDOWrLen : USINT;
	    WrDONrFastUnsafe : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StatusInfo : STRUCT
	    TDOReadState : USINT;
	    TDOWriteState : USINT;
	    PDOReadLength : USINT;
	    PDOIFReadLength : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_TimeSyncDOActiveType : STRUCT
	    Wait4ResponseNo : UINT;
	    OwnSyncActive : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_TimeSyncHandshake : BSINT
	  [
	    1 NewTimeSyncActive,
	    2 StartTimeSync1,
	    3 StartTimeSync2,
	  ];
#pragma pack(push, 1)
	  TDOType : STRUCT
	    StdHeader : t_SDOStdHeader;
	    SrcAdr : HDINT;
	    DstAdr : HDINT;
	    TimeInfo1 : UDINT;
	    TimeInfo2 : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  TDORingbuffer : STRUCT
	    ud_ReadPos : UDINT;
	    ud_WritePos : DINT;
	    ud_Entries : UDINT;
	    b_ErrorTriggered : DINT;
	    Entry : ARRAY [0..SB_TDO_BUFFER_SIZE-1] OF TDOType;
	    ud_maxEntries : UDINT;
	    b_RequestAvailable : BOOL;
	    RequestTDO : TDOType;
	  END_STRUCT;
#pragma pack(pop)
	  UnsafeReadPackages : ARRAY [0..14] OF HDINT;
	  UnsafeSchedulerSSW :
	  (
	    UnsafeSchedulerSetBusReady,
	    UnsafeSchedulerGetDiagVars,
	    UnsafeSchedulerGetCRC,
	    UnsafeSchedulerWriteData,
	    UnsafeSchedulerReadData,
	    UnsafeSchedulerDiagState,
	    UnsafeSchedulerDiagInfo,
	    UnsafeSchedulerGetRetryCounter
	  )$UDINT;
#pragma pack(push, 1)
	  UnsafeWritePackage : STRUCT
	    ud_Address : HDINT;
	    Value : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  UnsafeWritePackages : ARRAY [0..SB_MAX_UNSAFE_WRITE_PACKAGES-1] OF UnsafeWritePackage;
#pragma pack(push, 1)
	  VaranDOSettingsRd : STRUCT
	    us_Command : USINT;
	    ud_Address : UDINT;
	    us_ByteCnt : USINT;
	    us_CommandRecv : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  VaranDOSettingsWr : STRUCT
	    us_Command : USINT;
	    ud_Address : UDINT;
	    us_ByteCnt : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	SafetyState 	: SvrCh_SafetyConfigStateType;
	VoltageOK 	: SvrCh_DINT;
	RunState 	: SvrCh_DINT;
	ServiceMode 	: SvrCh_DINT;
	ErrorState 	: SvrCh_DINT;
	QuitComError 	: SvrCh_DINT;
	FirmwareVersion 	: SvrCh_HDINT;
	SafetyNumber 	: SvrCh_HDINT;
	SafetyRetryCounter 	: SvrCh_DINT;
	DesignerPrjConfigCRC 	: SvrCh_HDINT;
  //Clients:
	ToBusInterface 	: CltChCmd_DINT;
	ServerUpdateTime 	: CltCh_UDINT;
	DeviceID 	: CltCh_UDINT;
	FileSys 	: CltChCmd__FileSys;
	ToStdLib 	: CltChCmd__StdLib;
  //Variables:
		sFirmwareVersion 	: SafetyBase::FirmwareVersionType;
		ui_cnt_PDOInputBuffer 	: UINT;
		aPDOInputBuffer : ARRAY [0..SB_PDO_MAX_NUMBER-1] OF SafetyBase::PDOInputBuffer;

		PDOOutputIsUsed 	: BOOL;
		PDOOutputBuffer 	: SafetyBase::PDOType;
		IFPDOOutputIsUsed 	: BOOL;
		IFPDOOutputBuffer 	: PDOType;
		ui_cnt_SDOInputBuffer 	: UINT;
		p_SDOInputBuffer 	: ^UDINT;
		InputBufferAllocatedNo 	: UDINT;
		p_SDOOutputBuffer 	: ^SafetyBase::SDORespStd;
		a_RoutTable : ARRAY [0..SB_MAX_NUMBER_ROUT_ELEMENTS-1] OF SafetyBase::RoutElement;

		p_RoutTable 	: ^SafetyBase::RoutElement;
		ui_CntRoutElements 	: UINT;
		ui_cnt_PDOInBufferAct 	: UINT;
		us_FirstScan 	: USINT;
		HandlePDORead 	: UDINT;
		pPDOReadData 	: ^USINT;
		HandlePDOWrite 	: UDINT;
		pPDOWriteData 	: ^USINT;
		aAdditionalPDOs : ARRAY [0..8] OF SafetyBase::AdditionalPDOsType;

		HandlePDOReadIF 	: UDINT;
		pPDOIFReadData 	: ^USINT;
		HandleStatusInfo 	: UDINT;
		pStatusInfoRd 	: ^t_StatusInfo;
		HandleTimeSyncRead 	: UDINT;
		pTempTimeSyncRead 	: ^USINT;
		pFastUnsafeOutputs 	: ^UDINT;
		pLEDandIOStates 	: ^USINT;
		pTimeSyncHS_ReadData 	: ^t_TimeSyncHandshake;
		HandleTDORead 	: UDINT;
		pTDOReadData 	: ^USINT;
		HandleTDOWrite 	: UDINT;
		pTDOWriteData 	: ^USINT;
		HandleTimeSyncHSWrite 	: UDINT;
		pTimeSyncHS_WriteData 	: ^t_TimeSyncHandshake;
		HandleUnsafeOutWrite 	: UDINT;
		pTempUnsafeWrData 	: ^USINT;
		pFastUnsafeInputs 	: ^UDINT;
		pUnsafeOutWrData 	: ^USINT;			//! <Variable Comment="pointer to unsafe enable signals (only valid if outputs are available)" Name="pUnsafeOutWrData"/>
		p_Handle_SDO_Read 	: ^SafetyBase::SDOBufferStructure;
		p_Handle_SDO_Write 	: ^SafetyBase::SDOBufferStructure;
		pISafety 	: ^LSL_SAFETY;
		us_CntSequNr 	: USINT;
		p_KernelLog 	: ^DINT;
		ui_CntUnsafeInputs 	: UINT;
		MaxVarsPerWritePackage 	: USINT;
		WriteFramesNeeded 	: UDINT;
		p_UnsafeInputsTable 	: ^SafetyBase::UnsafeIORoutingElement;
		ui_CntUnsafeOutputs 	: UINT;
		MaxVarsPerReadPackage 	: USINT;
		ReadFramesNeeded 	: UDINT;
		p_UnsafeOutputsTable 	: ^SafetyBase::UnsafeIORoutingElement;
		StandardRequest 	: SafetyBase::StandardFrameType;
		StandardResponse 	: SafetyBase::StandardFrameType;
		StandardSeqNr 	: USINT;
		UnsafeReadTransNr 	: UDINT;
		UnsafeWriteTransNr 	: UDINT;
		UnsafeWritingActive 	: BOOL;
		LastUnsafeUpdate 	: UDINT;
		pUnsafeOutElement 	: ^SafetyBase::UnsafeIORoutingElement;
		pUnsafeInElement 	: ^SafetyBase::UnsafeIORoutingElement;
		TDOInfo 	: USINT;
		TDOFrame 	: SafetyBase::TDOType;
		pSafetyCDIASBase 	: ^SafetyCDIAS_Base;			//! <Variable Comment="this pointer exists just to create a dependency to class SafetyCDIAS_Base (we need the global variables)" Name="pSafetyCDIASBase"/>
		b_CheckCRC 	: BOOL;
		ud_LastCrcCheck 	: UDINT;
		b_GetNewConfiguration 	: BOOL;
		b_CheckConfigured 	: BOOL;
		ud_LastCheckConfig 	: UDINT;
		LastRequest 	: SafetyBase::RequestType;
		TDOSingleRunActive 	: BOOL;
		PDOSingleRunActive 	: USINT;
		DiagVars 	: SafetyBase::DiagStructType;
		us_SetBusReadyState 	: SafetyBase::SetBusReadySSW;
		UnsafeScheduler 	: SafetyBase::UnsafeSchedulerSSW;
		ud_UnsafeTimeoutCounter 	: UDINT;
		ud_TransfertimePerPackage 	: UDINT;
		p_BlockedTransferMemory 	: ^void;
		ud_BlockedTransferMemorySize 	: UDINT;
		b_ReadConfigFailed 	: BOOL;
		ud_ServerUpdateTime 	: UDINT;
		b_MoveCommandInputActive 	: SafetyBase::PDOMoveState;
		b_MoveCommandOutputActive 	: SafetyBase::PDOMoveState;
		InputMovSettings 	: t_MoveSettings;
		ud_LocalMoveSourceAddr 	: HDINT;			//! <Variable Comment="address offset in FPGA of pdo read data of this module" Name="ud_LocalMoveSourceAddr"/>
		ud_LocalMoveDestAddr 	: HDINT;			//! <Variable Comment="address offset in FPGA of pdo write data of this module" Name="ud_LocalMoveDestAddr"/>
		ud_LocalMoveIFSourceAddr 	: HDINT;
		ud_LocalReadHandle 	: HDINT;
		ud_LocalReadOffset 	: UDINT;
		ud_LocalWriteHandle 	: HDINT;
		ud_LocalWriteOffset 	: UDINT;
		ud_LocalIFReadHandle 	: HDINT;
		ud_LocalIFReadOffset 	: UDINT;
		pPDOMoverListInputs 	: ^SafetyBase::PDOMoverList;			//! <Variable Comment="pointer to a linked list with modules to communicate with via pdo mover (inputs)&#13;&#10;the list is cleared after the configuration readout (only needed to set or reset the move possibility)" Name="pPDOMoverListInputs"/>
		pPDOMoverListOutputs 	: ^SafetyBase::PDOMoverList;			//! <Variable Comment="pointer to a linked list with modules to communicate with via pdo mover (outputs)&#13;&#10;the list is cleared after the configuration readout (only needed to set or reset the move possibility)" Name="pPDOMoverListOutputs"/>
		s_TDORingbuffer 	: SafetyBase::TDORingbuffer;			//! <Variable Comment="buffer to store a tdo request and up to 50 responses" Name="s_TDORingbuffer"/>
		ud_UnsafeVarsNotFound 	: UDINT;			//! <Variable Comment="remembers how many servers for unsafe variables could not be found during the readout of the configuration (is reset after showing the error _UnsafeVarNotFound)" Name="ud_UnsafeVarsNotFound"/>
		InitStep 	: DINT;			//! <Variable Comment="contains the actual init step (0-2)" Name="InitStep"/>
		sd_RequestDropCounter 	: DINT;			//! <Variable Comment="counts up everytime a response could not be written to a module, because there was a request waiting (which has priority)&#13;&#10;only possible with old time sync (modules send time sync request uncoordinated)" Name="sd_RequestDropCounter"/>
		b_NewSyncMode 	: BOOL;			//! <Variable Comment="shows the sync mode setting selected by the safety manager&#13;&#10;TRUE = new time sync method (classes tell the firmware 1 by 1 when to synchronize)&#13;&#10;FALSE = old time sync method (every module sends out the requests whenever it thinks =&gt; collision possibility)" Name="b_NewSyncMode"/>
		b_TimeSyncActive 	: BOOL;			//! <Variable Comment="is set to TRUE by the safety manager to start the timesynchronsation of this module (this safety module gets a handshake and then starts to synchronize all necessary modules)&#13;&#10;is set to FALSE when the firmware quits the handshake and signals that it has finished time synchronizing" Name="b_TimeSyncActive"/>
		b_ManagerInitialisationFinished 	: BOOL;			//! <Variable Comment="TRUE means the safety manager is ready and we can start with PDO and TDO transfers as well as standard SDO transfers (before only SSDOs between modules are possible)" Name="b_ManagerInitialisationFinished"/>
		PrjNameMemLen 	: UDINT;			//! <Variable Comment="length of memory for project name and project revision (is combined in 1 string, seperated by a zero termination)" Name="PrjNameMemLen"/>
		PrjNameStrLen 	: UDINT;			//! <Variable Comment="length of project name string (pPrjNameStr)" Name="PrjNameStrLen"/>
		pPrjNameStr 	: ^CHAR;			//! <Variable Comment="pointer to a project name string if available" Name="pPrjNameStr"/>
		PrjRevStrLen 	: UDINT;			//! <Variable Comment="length of project revision string (pPrjRevStr)" Name="PrjRevStrLen"/>
		pPrjRevStr 	: ^CHAR;			//! <Variable Comment="pointer to a project revision string if available" Name="pPrjRevStr"/>
		b_GotNewRevision 	: BOOL;			//! <Variable Comment="remembers if there was a block SB_BLKTYPE_CFG_REV in the configuration which holds a valid project name and revision to display on servers&#13;&#10;if there is none, the servers show &quot;&lt;not available&gt;&quot;" Name="b_GotNewRevision"/>
		PDOWrite 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="PDOWrite"/>
		PDORead 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="PDORead"/>
		PDOIFRead 	: t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="PDOIFRead"/>
		SDOWrite 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="SDOWrite"/>
		SDORead 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="SDORead"/>
		TDOWrite 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="TDOWrite"/>
		TDORead 	: SafetyBase::t_DataObjectCheck;			//! <Variable Comment="only for debug reasons to check for different frames and the time difference between them (including mininum and maximum)" Name="TDORead"/>
		TimeSyncHSSingleRunActive 	: USINT;			//! <Variable Comment="counts down during the write access to the time sync handshake register is active. at 0 the access is being disabled." Name="TimeSyncHSSingleRunActive"/>
		NewHandShakeValue 	: t_TimeSyncHandshake;			//! <Variable Comment="is unequal to zero if a handshake value should be written to the safety module (used for time synchronisation)" Name="NewHandShakeValue"/>
		pConfigMem 	: ^void;			//! <Variable Comment="pointer to memory to hold the local configuration (extended in 512 byte block steps)" Name="pConfigMem"/>
		ConfigMemSize 	: UDINT;			//! <Variable Comment="size allocated for the config memory at pConfigMem" Name="ConfigMemSize"/>
		ConfigMemSizeUsed 	: UDINT;			//! <Variable Comment="size used from the config memory (pConfigMem)" Name="ConfigMemSizeUsed"/>
		ModuleCfgNo 	: USINT;			//! <Variable Comment="number of modules found in the configuration. for the linked list of them see pFirstModuleCfg" Name="ModuleCfgNo"/>
		pFirstModuleCfg 	: ^t_ModuleListElem;			//! <Variable Comment="pointer to a linked list where the modules found in the configuration are stored" Name="pFirstModuleCfg"/>
		PdoCfgNo 	: USINT;			//! <Variable Comment="number of PDO informations in the linked list (pFirstPdoCfg)" Name="PdoCfgNo"/>
		pFirstPdoCfg 	: ^t_PdoListElem;			//! <Variable Comment="if the configurations holds PDO information, it will be stored in this linked list" Name="pFirstPdoCfg"/>
		SlaveCfgNo 	: USINT;			//! <Variable Comment="if this module holds slave configurations (organized as linked list), this is the number of slave configurations available in the linked list (pFirstSlaveCfg)" Name="SlaveCfgNo"/>
		pFirstSlaveCfg 	: ^t_SlaveListElem;			//! <Variable Comment="if this module holds slave configurations (organized as linked list), this is the pointer to the first" Name="pFirstSlaveCfg"/>
		MyPDOReadSize 	: USINT;			//! <Variable Comment="contains the size needed for the read interface PDO. this value is used to create the data object." Name="MyPDOReadSize"/>
		MyIFPDOReadSize 	: USINT;			//! <Variable Comment="contains the size needed for the read interface PDO. this value is used to create the data object." Name="MyIFPDOReadSize"/>
		MyPDOWriteSize 	: USINT;			//! <Variable Comment="contains the size needed for the write PDOs. this value is used to create the data object." Name="MyPDOWriteSize"/>
		OldRunState 	: DINT;			//! <Variable Comment="remembers the oldrunstate&#13;&#10;&#13;&#10;necessary to detect the positive edge, which means the safety cpu has started running&#13;&#10;in this case all unsafe input variables (actual server values) are sent to the safety cpu" Name="OldRunState"/>
		b_FastUnsafeInputsActive 	: BOOL;			//! <Variable Comment="TRUE if there are fast unsafe inputs in the configuration which the class has to handle" Name="b_FastUnsafeInputsActive"/>
		b_FastUnsafeOutputsActive 	: BOOL;			//! <Variable Comment="TRUE if there are fast unsafe outputs in the configuration which the class has to handle" Name="b_FastUnsafeOutputsActive"/>
		NewConfigType 	: t_ConfigStateType;			//! <Variable Comment="this variable remembers the config format of the module&#13;&#10;new means, it does support the new time sync method (hw class triggers time sync)&#13;&#10;if there is any safety module which does not support the new method, all modules have to use the old method" Name="NewConfigType"/>
		bd_LogOnceMarker 	: SafetyBase::t_LogOnceMarker;			//! <Variable Comment="if an error message should be printed only once even if the error occurs multiple times, this variable is used to remember the messages already printed" Name="bd_LogOnceMarker"/>
		ud_OptionalTimeoutStart 	: UDINT;			//! <Variable Comment="ops.tabsolute timer when the safety manager is finished with adminstrative work&#13;&#10;if there are optional modules we don&apos;t wait forever for everything to get synchron because the optional modules may not be available" Name="ud_OptionalTimeoutStart"/>
		ud_AsyComRetryCounter 	: UDINT;			//! <Variable Comment="counts up if the actual SDO command fails.&#13;&#10;if a certain number of retries also fail an error message will be generated" Name="ud_AsyComRetryCounter"/>
		TimeSyncDOActive 	: SafetyBase::t_TimeSyncDOActiveType;			//! <Variable Comment="this is only for debugging time sync problems (marks if a time sync is active or if the module is waiting for an answer of another module)" Name="TimeSyncDOActive"/>
		b_ManagerReadyForSDO 	: BOOL;			//! <Variable Comment="TRUE means the safety manager has finished first time connecting the domains or there is no safety manager&#13;&#10;SDO transfer only works if this is true" Name="b_ManagerReadyForSDO"/>
		NeedsHwControl 	: ^HwControl;			//! <Variable Comment="this is needed for some global variable declaration" Name="NeedsHwControl"/>
		b_ManualQuit 	: BOOL;			//! <Variable Comment="this marks if a manual quit of communication errors has been done&#13;&#10;the quit mechanism will resend the bus ready command, where normally no PDOs are sent before the errors are being quit&#13;&#10;this variable is used to override the waiting for the bus ready to be finished and allows PDOs to be sent during the bus ready resend." Name="b_ManualQuit"/>
		b_ModuleAccessReady 	: BOOL;
		Online 	: DINT;			//! <Variable Comment="connection state of the module&#13;&#10;0 = not connected&#13;&#10;1 = connected and access init and module init was successful&#13;&#10;&#13;&#10;every action that requires a connected module has to use this variable" Name="Online"/>
		b_VaranAvailable 	: BOOL;			//! <Variable Comment="TRUE if there is a VARAN between the SPS and the module. Move-DOs can only be installed if this is true." Name="b_VaranAvailable"/>
		p_ObjectPath 	: ^USINT;			//! <Variable Comment="pointer to the object path which is needed to add the module to the safety task and get the pointers for SDO handling from the OS" Name="p_ObjectPath"/>
		InputsCount 	: USINT;			//! <Variable Comment="holds the amount of projected safe inputs" Name="InputsCount"/>
		OutputsCount 	: USINT;			//! <Variable Comment="holds the amount of projected safe outputs" Name="OutputsCount"/>
		DOStartFailCounter 	: UDINT;			//! <Variable Comment="counts up if starting a DO fails" Name="DOStartFailCounter"/>
		DOStopFailCounter 	: UDINT;			//! <Variable Comment="counts up if stopping a DO fails" Name="DOStopFailCounter"/>
		b_DOsAlreadyStarted 	: BOOL;			//! <Variable Comment="FALSE at the first time when the DOs should be started&#13;&#10;&#13;&#10;then the pointers to the write and read data are going to be corrected&#13;&#10;&#13;&#10;TRUE after the pointer correction (only needs to be done once)" Name="b_DOsAlreadyStarted"/>
		b_Deactivated 	: BOOL;			//! <Variable Comment="TRUE if the object is disabled through any circumstances (invalid place, varan connection transparent...)" Name="b_Deactivated"/>
		ud_ConfigReadTime 	: UDINT;			//! <Variable Comment="time for the last config readout in µs" Name="ud_ConfigReadTime"/>
		PdoSizeInfo 	: t_PDOSizeInfo;			//! <Variable Comment="info from last readout (last config change, boot of project, hardware connected,..)&#13;&#10;&#13;&#10;info which has been used to create the DOs can be found on:&#13;&#10;MyPDOReadSize,&#13;&#10;MyIFPDOReadSize,&#13;&#10;MyPDOWriteSize,&#13;&#10;AdditionalSPDOs,&#13;&#10;ActivateFastUnsafeIOs" Name="PdoSizeInfo"/>
		ActivateFastUnsafeIOs 	: BOOL;			//! <Variable Comment="holds the information, if the fast unsafe variables has been activated in the safety designer project" Name="ActivateFastUnsafeIOs"/>
		AdditionalSPDOs 	: DINT;			//! <Variable Comment="how many write PDOs are additionally necessary" Name="AdditionalSPDOs"/>
		b_Reconnect 	: BOOL;
		b_MoveDOsCreated 	: BOOL;			//! <Variable Comment="TRUE if the move DOs has been created" Name="b_MoveDOsCreated"/>
		a_RetryCnt : ARRAY [0..31] OF USINT;
			//! <Variable Comment="Array of data about the safetyretrycounter from the module." Name="a_RetryCnt"/>
		ud_RetryCntTimeMark 	: UDINT;			//! <Variable Comment="Timestamp of last retry coutner readout." Name="ud_RetryCntTimeMark"/>
		us_OldRetryCounter 	: USINT;			//! <Variable Comment="Marker for old retry counter." Name="us_OldRetryCounter"/>
		CachedAddr 	: UDINT;
		CachedSize 	: UDINT;
		Cache : ARRAY [0..SB_SDO_MAX_LENGTH-1] OF USINT;

		b_RetryCounterAvailable 	: BOOL;			//! <Variable Comment="Shows if a retry counter readout is available. Depends on the firmware version." Name="b_RetryCounterAvailable"/>
		SchedulerStepNo 	: DINT;			//! <Variable Comment="Shows the amount of steps of the scheduler" Name="SchedulerStepNo"/>
		b_QuitErrorAvailable 	: BOOL;
		b_NeedApplicationRestart 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="constructor" Name="SafetyBase"/>
	FUNCTION SafetyBase
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL CheckVariant
		VAR_INPUT
			us_ActVariant 	: USINT;
		END_VAR
		VAR_OUTPUT
			b_IsOK 	: BOOL;
		END_VAR;
				//! <Function Comment="add SDO to incoming message buffer; This function is called from the SDO sending class." Name="AddSDOToBuffer"/>
	FUNCTION VIRTUAL AddSDOToBuffer
		VAR_INPUT
			p_us_message 	: ^USINT;
			us_length 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="write incoming PDO from other module to hardware " Name="WritePDO2Module"/>
	FUNCTION VIRTUAL WritePDO2Module;
	
	FUNCTION VIRTUAL WriteTDO2Module
		VAR_INPUT
			pTDO 	: ^SafetyBase::TDOType;
		END_VAR;
	
	FUNCTION VIRTUAL InitSafetyBase
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL InitBuffers
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="allocate buffers for reading config data and creating routing tables" Name="GetRoutingData"/>
	FUNCTION VIRTUAL GetRoutingData
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="read config data via SDOs and fill routing tables" Name="ReadSDOConfig"/>
	FUNCTION VIRTUAL ReadSDOConfig
		VAR_INPUT
			p_SDORequestBuffer 	: ^SafetyBase::SDORequReadConfig;
			p_SDOResponseBuffer 	: ^SafetyBase::SDORespReadConfig;
			pModule 	: ^SafetyBase::PathInfoType;
			pListHeader 	: ^SafetyBase::PathInfoType;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="send request for reading config data" Name="SDOReadCfgRequ"/>
	FUNCTION VIRTUAL SDOReadCfgRequ
		VAR_INPUT
			p_SDORequestBuffer 	: ^SafetyBase::SDORequReadConfig;
			p_SDOResponseBuffer 	: ^SafetyBase::SDORespReadConfig;
			ud_Address 	: UDINT;
			us_Length 	: USINT;
			b_UseCache 	: BOOL := TRUE;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="send request with no additional data" Name="SDOStdRequ"/>
	FUNCTION VIRTUAL SDOStdRequ
		VAR_INPUT
			us_Command 	: USINT;
			p_us_RespData 	: ^USINT;
			us_RespLength 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="add data objects for PDO, state etc." Name="AddDO"/>
	FUNCTION VIRTUAL AddDO
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="start data objects" Name="StartDO"/>
	FUNCTION VIRTUAL StartDO;
				//! <Function Comment="stop data objects" Name="StopDO"/>
	FUNCTION VIRTUAL StopDO;
				//! <Function Comment="returns pointer to the own outgoing PDO buffer" Name="GetPointer2PDOBuffer"/>
	FUNCTION VIRTUAL GetPointer2PDOBuffer
		VAR_OUTPUT
			ud_PDOBuffer 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddUnsafeRoutElement
		VAR_INPUT
			pRoutTable 	: ^SafetyBase::pUnsafeIORoutingElement;
			pRoutElementsNo 	: ^UINT;
			ud_Address 	: UDINT;
			ui_NameLen 	: UINT;
			pNameNewElement 	: ^CHAR;
			BitMask 	: BDINT := 0;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="read this-pointer from correct object and add it to the routing tables" Name="AddModuleToRoutingTabs"/>
	FUNCTION VIRTUAL AddModuleToRoutingTabs
		VAR_INPUT
			pModule 	: ^SafetyBase::PathInfoType;
			pListHeader 	: ^SafetyBase::PathInfoType;
			b_IsOptional 	: BOOL;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="add module to routing table" Name="AddRoutingElement"/>
	FUNCTION VIRTUAL AddRoutingElement
		VAR_INPUT
			ud_SafeNumber 	: HDINT;
			ud_thisp 	: UDINT;
			pObject 	: ^SafetyBase::PathInfoType;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="get this-pointer of routing-element based on safety-number" Name="GetRoutingPointerByNumber"/>
	FUNCTION VIRTUAL GetRoutingPointerByNumber
		VAR_INPUT
			ud_SafeNumber 	: HDINT;
		END_VAR
		VAR_OUTPUT
			ud_thisp 	: UDINT;
		END_VAR;
				//! <Function Comment="This function is called during initialization by the Safe-CPU class." Name="ConfigSafetyInput"/>
	FUNCTION VIRTUAL ConfigSafetyInput
		VAR_INPUT
			ud_SafeNrCPU 	: HDINT;
			ud_thisp 	: UDINT;
			p_PDOBuffer 	: ^UDINT;
			pMoveActive 	: ^PDOMoveState;
			p_ud_HandleSourceDO 	: ^UDINT;
			p_ud_MoveSourceAddr 	: ^UDINT;
			p_ud_MoveSourceOffset 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ud_SafeNrModul 	: HDINT;
		END_VAR;
				//! <Function Comment="This function is called during initialization by the Safe-CPU class." Name="ConfigSafetyOutput"/>
	FUNCTION VIRTUAL ConfigSafetyOutput
		VAR_INPUT
			ud_SafeNrCPU 	: HDINT;
			ud_thisp 	: UDINT;
			ud_p_PDOBuffer 	: UDINT;
			pObject 	: ^PathInfoType;
			pMoveActive 	: ^PDOMoveState;
			ud_HandleSourceDO 	: UDINT;
			ud_MoveSourceAddr 	: UDINT;
			ud_MoveSourceOffset 	: UDINT;
			b_IsOptional 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ud_SafeNrModul 	: HDINT;
		END_VAR;
				//! <Function Comment="get this-pointer of routing-element based on Crc of hardware-path" Name="GetRoutingPointerByPath"/>
	FUNCTION VIRTUAL GetRoutingPointerByPath
		VAR_INPUT
			p_ActObjectPath 	: ^USINT;
			ActPathLen 	: UINT;
		END_VAR
		VAR_OUTPUT
			ud_thisp 	: UDINT;
		END_VAR;
				//! <Function Comment="add PDO buffer to list of PDO input buffers" Name="AddPDOToInputBuffer"/>
	FUNCTION VIRTUAL AddPDOToInputBuffer
		VAR_INPUT
			ud_p2Buffer 	: UDINT;
			ud_HandleSourceDO 	: UDINT;
			ud_MoveSourceAddr 	: UDINT := 0;
			ud_MoveSourceOffset 	: UDINT;
			ud_SafetyNr 	: HDINT;
			b_IsOptional 	: BOOL;
			us_PdoLen 	: USINT := 0;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL ConfigSafetyCPU
		VAR_OUTPUT
			ud_SafeNrModul 	: HDINT;
		END_VAR;
				//! <Function Comment="get pointer on PDO input buffer element" Name="GetPDOInputBuffer"/>
	FUNCTION VIRTUAL GetPDOInputBuffer
		VAR_INPUT
			ud_p2Buffer 	: UDINT;
		END_VAR
		VAR_OUTPUT
			p_InputBuffer 	: ^SafetyBase::PDOInputBuffer;
		END_VAR;
				//! <Function Comment="Add module to safety task in OS and get pointers on SDO buffers." Name="AddModuleToSafetyTask"/>
	FUNCTION VIRTUAL AddModuleToSafetyTask
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="The methode returns the module ID which the module must have. It has to be overwritten." Name="GetModuleID"/>
	FUNCTION VIRTUAL GetModuleID
		VAR_OUTPUT
			ud_ModuleID 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns the task priority; A value &lt;&gt; 0 changes the order of executing the update methods. 0 = highest = default priority;" Name="GetTaskPriority"/>
	FUNCTION VIRTUAL GetTaskPriority
		VAR_OUTPUT
			us_TaskPriority 	: USINT;
		END_VAR;
				//! <Function Comment="initialize safety module (e.g. CPU) specific data" Name="InitSafeModule"/>
	FUNCTION VIRTUAL InitSafeModule
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="requests own safety number from module via SDO communication" Name="GetSafetyNumber"/>
	FUNCTION VIRTUAL GetSafetyNumber
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="update of non SDO and PDO data" Name="UpDateNotStd"/>
	FUNCTION VIRTUAL UpDateNotStd;
				//! <Function Comment="extract module path out of config data" Name="ReadModulePath"/>
	FUNCTION VIRTUAL ReadModulePath
		VAR_INPUT
			p_SDORequestBuffer 	: ^SafetyBase::SDORequReadConfig;
			p_SDOResponseBuffer 	: ^SafetyBase::SDORespReadConfig;
			p_ud_Address 	: ^UDINT;
			pModule 	: ^SafetyBase::PathInfoType;
			p_ud_ModulePathLen_Max 	: ^UDINT;
			p_ud_ModulePathCompLen_Max 	: ^UDINT;
			us_SDOMaxDataSize 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="returns the pointer on routing element with searched this-pointer" Name="GetRoutingElementByThis"/>
	FUNCTION VIRTUAL GetRoutingElementByThis
		VAR_INPUT
			ud_thisp 	: UDINT;
		END_VAR
		VAR_OUTPUT
			p_RoutElement 	: ^SafetyBase::RoutElement;
		END_VAR;
	
	FUNCTION VIRTUAL GetThisViaServerName
		VAR_INPUT
			pObjectDotServer 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			ThisPtr 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;
			Value 	: UDINT;
			Value2 	: UDINT := 16#FFFFFFFF;
			Value3 	: UDINT := 16#FFFFFFFF;
		END_VAR;
	
	FUNCTION VIRTUAL InitPathInfo
		VAR_INPUT
			pPathInfo 	: ^SafetyBase::PathInfoType;
		END_VAR;
				//! <Function Comment="log error messages" Name="LogError"/>
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			e_msg 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL ResetConfig;
	
	FUNCTION VIRTUAL RemoveCPUFromTable
		VAR_INPUT
			ud_SafetyNr 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL CheckUnsafeUpdateCycle;
				//! <Function Comment="Make a request to fetch the diagnosis data" Name="FetchDiagState"/>
	FUNCTION VIRTUAL GLOBAL FetchDiagState;
				//! <Function Comment="Check if the diagnosis data have arrived (if so, retcode = TRUE)." Name="GetDiagState"/>
	FUNCTION VIRTUAL GLOBAL GetDiagState
		VAR_INPUT
			pDiagState 	: ^SafetyDiagState;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;			//! <Variable Comment="FALSE...State is not ready (value of &quot;input parameter&quot; not changed)&#13;&#10;TRUE....State is ready (input parameter)" Name="GetDiagState.StateReady"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FetchDiagInfo
		VAR_INPUT
			ucChoice 	: USINT;			//! <Variable Comment="   0..µC1&#13;&#10;&lt;&gt; 0..µC2" Name="FetchDiagInfo.ucChoice"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDiagInfo
		VAR_INPUT
			pDiagInfo 	: ^SafetyDiagInfo;
		END_VAR
		VAR_OUTPUT
			StateReady 	: BOOL;
		END_VAR;
				//! <Function Comment="saves the log file from a specified µC to a file (not readable for user, send it to sigmatek support)" Name="SaveLog"/>
	FUNCTION VIRTUAL GLOBAL SaveLog
		VAR_INPUT
			ucChoice 	: USINT;			//! <Variable Comment="   0..µC1&#13;&#10;&lt;&gt; 0..µC2" Name="SaveLog.ucChoice"/>
			pDPNE 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Success 	: DINT;			//! <Variable Comment="TRUE...saving log to drive is starting&#13;&#10;FALSE..couldn&apos;t start, other log saving process running" Name="SaveLog.Success"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaveLogActive
		VAR_OUTPUT
			Finished 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL SDORequ
		VAR_INPUT
			us_Command 	: USINT;
			p_us_RequData 	: ^USINT;
			us_RequLength 	: USINT;
			p_us_RespData 	: ^USINT;
			us_RespLength 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL BlockedTransferLength
		VAR_INPUT
			ud_Datalength 	: UDINT;
			us_MaxBlocklength 	: USINT;
		END_VAR
		VAR_OUTPUT
			us_ActBlocklength 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL MyTrace
		VAR_INPUT
			pFormat 	: ^CHAR;
			pTxt0 	: ^CHAR;
			pTxt1 	: ^CHAR;
			pTxt2 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL AddToPDOMoverList
		VAR_INPUT
			pThis 	: pVirtualBase;
			pList 	: ^pPDOMoverList;
		END_VAR;
	
	FUNCTION VIRTUAL WalkThroughPDOMoverList
		VAR_INPUT
			pList 	: ^SafetyBase::pPDOMoverList;
			NewState 	: SafetyBase::PDOMoveState;
		END_VAR;
	
	FUNCTION VIRTUAL CleanupPDOMoverList
		VAR_INPUT
			pList 	: ^SafetyBase::pPDOMoverList;
		END_VAR;
	
	FUNCTION VIRTUAL RecordFrame
		VAR_INPUT
			pFrame 	: ^DINT;
			FrameState 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddFrame
		VAR_INPUT
			pFrame 	: ^t_SDOStdHeader;
			FrameState 	: DINT;
			CallerSafetyNr 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL ShowProjectRevision;
	
	FUNCTION DOCheck
		VAR_INPUT
			pFrame 	: ^t_SDOStdHeader;
			pCheckStruct 	: ^SafetyBase::t_DataObjectCheck;
		END_VAR;
	
	FUNCTION VIRTUAL CalcPDOLength
		VAR_INPUT
			BoolVarNo 	: UDINT;
			DintVarNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			PdoLen 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddModuleToCfg
		VAR_INPUT
			ModuleCfg 	: t_ModuleCfg;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddPdoToCfg
		VAR_INPUT
			PdoCfg 	: t_PdoCfg;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddSlaveToCfg
		VAR_INPUT
			pModule 	: ^SafetyBase::PathInfoType;
			b_IsOptional 	: BOOL;
			b_IsInterface 	: BOOL := FALSE;
			InterfaceCRC 	: HDINT := 0;
		END_VAR;
	
	FUNCTION VIRTUAL FreeCfgLists;
	
	FUNCTION VIRTUAL CreateAndSendCfg;
	
	FUNCTION SendAllUnsafeValues;
	
	FUNCTION GetDestinationCRCs;
	
	FUNCTION CountBits
		VAR_INPUT
			BitMask 	: BDINT;
		END_VAR
		VAR_OUTPUT
			BitNo 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL IsOptimizedCPU
		VAR_OUTPUT
			IsOptimized 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL CheckConfigMemSize
		VAR_INPUT
			AddConfigSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pCfg 	: ^void;
		END_VAR;
	
	FUNCTION DToH
		VAR_INPUT
			pt 	: ^CHAR;
			value 	: DINT;
		END_VAR;
	
	FUNCTION LogHWPath
		VAR_INPUT
			pString 	: ^CHAR;
			pHWPath 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
	
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
	
	FUNCTION VIRTUAL GLOBAL InterruptEvent;
	
	FUNCTION SetDORunState
		VAR_INPUT
			Handle 	: UDINT;
			NewState 	: t_BusIFRunState;
		END_VAR;
	
	FUNCTION GetPointer2IFPDOBuffer
		VAR_OUTPUT
			ud_PDOBuffer 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetConfiguration;
	
	FUNCTION AddMovDOs
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION UpdateMovDO
		VAR_INPUT
			p_MoveSettings 	: ^t_MoveSettings;
			ud_NewSourceHandle 	: UDINT;
			ud_NewSourceOffset 	: UDINT;
			ud_NewSourcePointer 	: UDINT;
			ui_NewLength 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL SetSafetyState
		VAR_INPUT
			NewState 	: SafetyConfigStateType;
		END_VAR;
	
	FUNCTION VIRTUAL RefreshAsySrv;
	
	FUNCTION VIRTUAL SetRetryCounter;
	
	FUNCTION IsInCache
		VAR_INPUT
			ud_Address 	: UDINT;
			us_Length 	: USINT;
		END_VAR
		VAR_OUTPUT
			ItsInside 	: BOOL;
		END_VAR;
	
	FUNCTION AddToCache
		VAR_INPUT
			p_SDORequestBuffer 	: ^SDORequReadConfig;
			p_SDOResponseBuffer 	: ^SDORespReadConfig;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitComError::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SafetyBase::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SAFETYBASE
1$UINT, 22$UINT, (SIZEOF(::SafetyBase))$UINT, 
11$UINT, 5$UINT, 0$UINT, 
TO_UDINT(4109957215), "SafetyBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SafetyBase.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::SafetyBase.SafetyState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1504224158), "SafetyState", 
(::SafetyBase.VoltageOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2158378107), "VoltageOK", 
(::SafetyBase.RunState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2759549320), "RunState", 
(::SafetyBase.ServiceMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1978843086), "ServiceMode", 
(::SafetyBase.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::SafetyBase.QuitComError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1389350282), "QuitComError", 
(::SafetyBase.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SafetyBase.SafetyNumber.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2430374202), "SafetyNumber", 
(::SafetyBase.SafetyRetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1159647258), "SafetyRetryCounter", 
(::SafetyBase.DesignerPrjConfigCRC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(349909197), "DesignerPrjConfigCRC", 
//Clients:
(::SafetyBase.ToBusInterface.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000010$UINT, TO_UDINT(1682766337), "ToBusInterface", 
(::SafetyBase.ServerUpdateTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(247674937), "ServerUpdateTime", 
(::SafetyBase.DeviceID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4261957967), "DeviceID", 
(::SafetyBase.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 18$UINT, 
(::SafetyBase.ToStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2501598121), "ToStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_SafetyBase 70

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SafetyBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SafetyBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SafetyBase, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #CheckVariant();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddSDOToBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WritePDO2Module();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #WriteTDO2Module();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #InitSafetyBase();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #InitBuffers();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetRoutingData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReadSDOConfig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #SDOReadCfgRequ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #SDOStdRequ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #AddDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #StartDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #StopDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetPointer2PDOBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #AddUnsafeRoutElement();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #AddModuleToRoutingTabs();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #AddRoutingElement();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #GetRoutingPointerByNumber();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #ConfigSafetyInput();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #ConfigSafetyOutput();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #GetRoutingPointerByPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #AddPDOToInputBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #ConfigSafetyCPU();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #GetPDOInputBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddModuleToSafetyTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #GetModuleID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #GetTaskPriority();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #InitSafeModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #GetSafetyNumber();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #UpDateNotStd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #ReadModulePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #GetRoutingElementByThis();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #GetThisViaServerName();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #InitPathInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #ResetConfig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #RemoveCPUFromTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #CheckUnsafeUpdateCycle();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #FetchDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #GetDiagState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #FetchDiagInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #GetDiagInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #SaveLog();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #SaveLogActive();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #SDORequ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #BlockedTransferLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #MyTrace();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #AddToPDOMoverList();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #WalkThroughPDOMoverList();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #CleanupPDOMoverList();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #RecordFrame();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #AddFrame();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #ShowProjectRevision();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #CalcPDOLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[56]		:= #AddModuleToCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[57]		:= #AddPdoToCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[58]		:= #AddSlaveToCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[59]		:= #FreeCfgLists();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[60]		:= #CreateAndSendCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[61]		:= #IsOptimizedCPU();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[62]		:= #CheckConfigMemSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[63]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[64]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[65]		:= #InterruptEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[66]		:= #GetConfiguration();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[67]		:= #SetSafetyState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[68]		:= #RefreshAsySrv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[69]		:= #SetRetryCounter();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitComError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitComError::Write() );
	IF QuitComError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SafetyBase();

END_FUNCTION

#pragma usingLtd HwControl
#pragma usingLtd SafetyCDIAS_Base

//{{LSL_IMPLEMENTATION
VAR_EXTERNAL
  pAnalyzerThis   : ^DINT;
  pAnalyzerMethod : ^UDINT;
  pSafetyManagerThis   : pVirtualBase;
// b_SafetyOnLocalCDIAS = TRUE means there is a CDIAS safety module on local CDIAS/SDIAS Bus => using internal move command is not possible
  b_SafetyOnLocalCDIAS : BOOL;
  ModuleSyncNo : DINT; // Number of modules which need to be synchron before everyone sends the set bus ready signal
END_VAR

FUNCTION VIRTUAL SafetyBase::AddSDOToBuffer
	VAR_INPUT
		p_us_message 	: ^USINT;
		us_length 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  // if the message is ok and there is space left in the buffer => save it
  if ( p_us_message ) & (us_length <= SB_SDO_MAX_LENGTH) & (ui_cnt_SDOInputBuffer < 1000) then
  
    if ( p_SDOInputBuffer = NIL ) then
    
      sd_retval := -2;
      return;
      
    end_if;

    // if the allocated memory is full, we allocate some more
    if ui_cnt_SDOInputBuffer = InputBufferAllocatedNo then
    
      //reallocate list
      InputBufferAllocatedNo += SB_SDO_BUFFER_ALLOC_BLOCK;
      p_SDOInputBuffer$^void := ToStdLib.Realloc(mptr := p_SDOInputBuffer$^void, newsize := InputBufferAllocatedNo * SB_SDO_MAX_LENGTH);
      
      if ( p_SDOInputBuffer = NIL ) then
        SetSafetyState(NewState:=_MemAllocFailed);
        sd_retval := -3;
        return;
      end_if;

    end_if;

    //copy SDO into new list element
    ToStdLib.MemCpy( dest    := ( p_SDOInputBuffer + ( ui_cnt_SDOInputBuffer * SB_SDO_MAX_LENGTH))$^void
                    , source  := p_us_message
                    , size    := us_length
                    );

    ui_cnt_SDOInputBuffer += 1;
    
    sd_retval := 0;
  else
  
    sd_retval := -1;
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::InitSafetyBase
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
		tempCmd : CmdStruct;
		_result : results;
    dataADDCallback : t_BusIFAddCallback;
  END_VAR

  retcode := FALSE;

#ifdef DO_DEBUG
  PDOWrite.TimeDiffMin := 16#FFFFFFFF;
  PDORead.TimeDiffMin  := 16#FFFFFFFF;

  SDOWrite.TimeDiffMin := 16#FFFFFFFF;
  SDORead.TimeDiffMin  := 16#FFFFFFFF;

  TDOWrite.TimeDiffMin := 16#FFFFFFFF;
  TDORead.TimeDiffMin  := 16#FFFFFFFF;
#endif

  // read the client values
  ServerUpdateTime := ServerUpdateTime.Read();
  DeviceID := DeviceID.Read();

  // login as operator
  dataADDCallback.pthis := this$pVirtualBase;

  tempCmd.uiCmd     := _BUS_IF_ADD_CALLBACK;
  tempCmd.aPara[0]  := (#dataADDCallback)$DINT;      
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
    LogError("(SafetyBase::InitSafetyBase) Failed to install callback at bus interface");
  end_if;

  tempCmd.uiCmd     := _BUS_IF_GET_HW_PATH;
  tempCmd.aPara[0]  := this$DINT;      
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
    LogError("(SafetyBase::InitSafetyBase) Failed to get hardware path");
  else
    p_ObjectPath := _result.aData[4]$^USINT;
  end_if;  

  // check if we're connected via VARAN
  tempCmd.uiCmd     := _BUS_IF_IS_VARAN_AVAILABLE;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    b_VaranAvailable := _result.aData[4]$BOOL;
  else
    LogError("(SafetyBase::InitSafetyBase) Failed to get connection state via BusInterface");
  end_if;
  
  // if this module is not connected via VARAN the MovCommand of VARAN can't be used
  if b_VaranAvailable = FALSE then
    b_SafetyOnLocalCDIAS := TRUE;
  end_if;


  // limit the number of additional SPDOs to the valid range
  if AdditionalSPDOs < 0 then
    AdditionalSPDOs := 0;
  end_if;

  if AdditionalSPDOs > 9 then
    AdditionalSPDOs := 9;
  end_if;

  // first thing to do in cyclic is to set the bus ready
  LastRequest := _NoOpenRequest;
  
  // initialize pointers with NIL (they get valid pointers in a later init-run if an object of the analyzer or safety manager class is available)
  pAnalyzerThis   := NIL;
  pAnalyzerMethod := NIL;

  pSafetyManagerThis   := NIL;

  // use static memory for routing table
  p_RoutTable := #a_RoutTable[0];

  //initialize buffers
  if ( InitBuffers() ) then
    return;
  end_if;

  //no safety interface -> no work
  if ( pISafety = NIL ) then
    return;
  end_if;
  
  retcode := TRUE;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddDO
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	VolatileHandle  : UDINT;
  	tempCmd         : CmdStruct;
    _result         : results;
    dataADDDO       : t_AddDOCfg;
    dataADDTASK     : t_TaskCfg;
    Offset          : HINT;
    Length          : USINT;
    i               : DINT;
  END_VAR

  ret_code := READY;

  // this stays the same for every DO
  tempCmd.uiCmd     := _BUS_IF_ADD_DO;
  tempCmd.aPara[0]  := (#dataADDDO)$DINT;
  
  // first we add all read accesses (this part also stays the same)
  dataADDDO.Priority                := _BUS_IF_ISO;
  dataADDDO.RdWr                    := _BUS_IF_READ;
  dataADDDO.ud_WaitForAccessHandle  := 0;
    
  if MyPDOReadSize then

    // read PDO
    dataADDDO.ud_addressoff_read  := SB_OFFSET_SPDO_DATA_RD;
    dataADDDO.ui_length_read      := MyPDOReadSize;//SB_SPDO_MAX_LENGTH;
    dataADDDO.ppDataRead          := #pPDOReadData;
    
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
      HandlePDORead  := _result.aData$t_AddDORet.Handle;
    else
      LogError("(SafetyBase::AddDO) Failed to add a DO for PDO read data");
      ret_code := ERROR;
    end_if;
  end_if;

  if MyIFPDOReadSize then

    // read PDO for interface frame
    dataADDDO.ud_addressoff_read  := SB_OFFSET_SPDO_IF_DATA_RD;
    dataADDDO.ui_length_read      := MyIFPDOReadSize;// SB_SPDO_MAX_LENGTH;
    dataADDDO.ppDataRead          := #pPDOIFReadData;
    
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
      HandlePDOReadIF  := _result.aData$t_AddDORet.Handle;
    else
      LogError("(SafetyBase::AddDO) Failed to add a DO for PDO interface frame read data");
      ret_code := ERROR;
    end_if;
  end_if;


  // read state bytes for PDOs and TDOs
  dataADDDO.ud_addressoff_read  := SB_OFFSET_STDO_STATUS;
  dataADDDO.ui_length_read      := sizeof(t_StatusInfo);
  dataADDDO.ppDataRead          := #pStatusInfoRd;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    HandleStatusInfo  := _result.aData$t_AddDORet.Handle;
    VolatileHandle    := _result.aData$t_AddDORet.AccessHandle;
  else
    LogError("(SafetyBase::AddDO) Failed to add a DO for PDO/TDO status read data");
    ret_code := ERROR;
  end_if;


  // read fast unsafe IOs, timesync handshake and io states
  
  // calculate length and offset of the access
  
  // we have always 1 byte for the time synchronisation and 5 bytes LED Status
  Length := 1 + 5;
  
  if ActivateFastUnsafeIOs then
    Offset := SB_OFFSET_GPDR2_RD;
    Length += sizeof(t_FastUnsafeIOs);
  else
    Offset := SB_OFFSET_GPDR1_RD;
  end_if;
    
  // now add some bytes for the input and output states (2 bit per IO) + 1 to round up + 4 for "header" info (LED, state bits and hbg state info)
  Length += (((InputsCount + OutputsCount) * 2 - 1) / 8) + 1 + 4;
  
  dataADDDO.ud_addressoff_read  := Offset;
  dataADDDO.ui_length_read      := Length;
  dataADDDO.ppDataRead          := #pTempTimeSyncRead;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    HandleTimeSyncRead  := _result.aData$t_AddDORet.Handle;
    
    // select this DO for periphery reset detection   
    tempCmd.uiCmd     := _BUS_IF_ADD_RESET_DETECTION_4_DO;
    tempCmd.aPara[0]  := HandleTimeSyncRead$DINT;
    
    // don't check return code, this may not be supported by all bus interfaces
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    
    
    // set the add DO command for the next DOs
    tempCmd.uiCmd     := _BUS_IF_ADD_DO;
    tempCmd.aPara[0]  := (#dataADDDO)$DINT;
  else
    LogError("(SafetyBase::AddDO) Failed to add a DO for time sync handshake read");
    ret_code := ERROR;
  end_if;


  // read TDO data
  dataADDDO.ud_addressoff_read  := SB_OFFSET_STDO_DATA_RD;
  dataADDDO.ui_length_read      := sizeof(TDOType);
  dataADDDO.ppDataRead          := #pTDOReadData;
  
  // this must wait until the state of the TDO is read out
  dataADDDO.ud_WaitForAccessHandle  := VolatileHandle;

  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    HandleTDORead  := _result.aData$t_AddDORet.Handle;
  else
    LogError("(SafetyBase::AddDO) Failed to add a DO for TDO read data");
    ret_code := ERROR;
  end_if;
  

  // now we add all write accesses (this part stays the same)
  dataADDDO.Priority                := _BUS_IF_ISO;
  dataADDDO.RdWr                    := _BUS_IF_WRITE;
  dataADDDO.ud_WaitForAccessHandle  := 0;

  if MyPDOWriteSize then
    
    // write PDO
    dataADDDO.ud_addressoff_write  := SB_OFFSET_SPDO_DATA_WR;
    dataADDDO.ui_length_write      := MyPDOWriteSize;//SB_SPDO_MAX_LENGTH;
    dataADDDO.ppDataWrite          := #pPDOWriteData;
    
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
      HandlePDOWrite  := _result.aData$t_AddDORet.Handle;
      
    else
      LogError("(SafetyBase::AddDO) Failed to add a DO for PDO write data");
      ret_code := ERROR;
    end_if;

    if (AdditionalSPDOs > 0) then      
      for i := 0 to (AdditionalSPDOs-1) do
        // additional write PDOs
        dataADDDO.ud_addressoff_write  := SB_OFFSET_SPDO_DATA_WR;
        dataADDDO.ui_length_write      := MyPDOWriteSize;//SB_SPDO_MAX_LENGTH;
        dataADDDO.ppDataWrite          := #aAdditionalPDOs[i].pPDOWriteData;
        
        ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
        if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
          aAdditionalPDOs[i].HandlePDOWrite  := _result.aData$t_AddDORet.Handle;
        else
          LogError("(SafetyBase::AddDO) Failed to add additional write PDO");
          ret_code := ERROR;
        end_if;
      end_for;
    end_if;
  end_if;


  // write time sync handshake
  dataADDDO.ud_addressoff_write  := SB_OFFSET_GPDR1_WR;
  dataADDDO.ui_length_write      := sizeof(t_TimeSyncHandshake);
  dataADDDO.ppDataWrite          := #pTimeSyncHS_WriteData;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    HandleTimeSyncHSWrite  := _result.aData$t_AddDORet.Handle;
  else
    LogError("(SafetyBase::AddDO) Failed to add a DO for time sync handshake write data");
    ret_code := ERROR;
  end_if;


  // write fast unsafe variables (if activated) and unsafe outputs (enable signals for safe outputs)

  // calculate length and offset of the access
  if ActivateFastUnsafeIOs then
    Offset := SB_OFFSET_GPDR2_WR;
    Length := sizeof(t_FastUnsafeIOs);
  else
    Offset := SB_OFFSET_UNSAFE_VAR_WR;
    Length := 0;
  end_if;

  // 1 bit per output
  Length += ((OutputsCount - 1) / 8) + 1;
  
  // maybe we don't need this DO (if we have only inputs and don't use the fast unsafe IOs)
  if Length then
    dataADDDO.ud_addressoff_write  := Offset;
    dataADDDO.ui_length_write      := Length;
    dataADDDO.ppDataWrite          := #pTempUnsafeWrData;
    
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
      HandleUnsafeOutWrite  := _result.aData$t_AddDORet.Handle;
    else
      LogError("(SafetyBase::AddDO) Failed to add a DO for time sync handshake write data");
      ret_code := ERROR;
    end_if;
  end_if;


  // write tdo
  dataADDDO.ud_addressoff_write  := SB_OFFSET_STDO_DATA_WR;
  dataADDDO.ui_length_write      := sizeof(TDOType);
  dataADDDO.ppDataWrite          := #pTDOWriteData;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    HandleTDOWrite  := _result.aData$t_AddDORet.Handle;
  else
    LogError("(SafetyBase::AddDO) Failed to add a DO for time sync handshake write data");
    ret_code := ERROR;
  end_if;


   // add realtime task
  dataADDTASK.Priority    := _BUS_IF_ISO;
  dataADDTASK.callOptions := (CALL_OPTION_RT_PRESCAN or CALL_OPTION_RT_POSTSCAN);
  dataADDTASK.pthis       := this$UDINT;
   
  tempCmd.uiCmd     := _BUS_IF_ADD_TASK;
  tempCmd.aPara[0]  := (#dataADDTASK)$DINT;
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  
  if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
    LogError("(SafetyBase::AddDO) Failed to install realtime tasks");
    ret_code := ERROR;
  end_if;


   // add cyclic task
  dataADDTASK.Priority    := _BUS_IF_ASY;
  dataADDTASK.callOptions := 0;
  dataADDTASK.pthis       := this$UDINT;
   
  tempCmd.uiCmd     := _BUS_IF_ADD_TASK;
  tempCmd.aPara[0]  := (#dataADDTASK)$DINT;
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  
  if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
    LogError("(SafetyBase::AddDO) Failed to install a cyclic task");
    ret_code := ERROR;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetPointer2PDOBuffer
	VAR_OUTPUT
		ud_PDOBuffer 	: UDINT;
	END_VAR

  PDOOutputIsUsed := TRUE;

  //set pointer to address of buffer pointer
  ud_PDOBuffer := ( #PDOOutputBuffer )$UDINT;
   
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddRoutingElement
	VAR_INPUT
		ud_SafeNumber 	: HDINT;
		ud_thisp 	: UDINT;
		pObject 	: ^PathInfoType;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	p_RoutElement   : ^RoutElement;
    ui_PathLength   : UINT;
    NewElement      : BOOL;
  END_VAR

  if ( ( ud_SafeNumber <> 0 ) & ( ud_thisp <> NIL ) ) then
    if ui_CntRoutElements < SB_MAX_NUMBER_ROUT_ELEMENTS then

      NewElement := TRUE;
    
      if ui_CntRoutElements then
        //check if object this-pointer already exists in routing table
        p_RoutElement := GetRoutingElementByThis( ud_thisp := ud_thisp );
      else
        p_RoutElement := NIL;
      end_if;

      if p_RoutElement = NIL then
        //add new element
      
        //set pointer to empty element on last position
        p_RoutElement := p_RoutTable + ( ui_CntRoutElements ) * sizeof(RoutElement);
      else
        // we don't have a new element, we just update an existing
        NewElement := FALSE;
      end_if;
    
      //add path

      // path isn't stored if it's the routing table of safe input module, because
      // it doesn't need the information
      if pObject^.p_us_Path & pObject^.p_us_PathComp 
         & ((NewElement = TRUE) | ((NewElement = FALSE) & (p_RoutElement^.p_CompressedPath = NIL) & (p_RoutElement^.ui_ComprPathLen = 0))) // only if it isn't already set
         then
          
        // the whole object path isn't stored, because the path can't be used for routing of SDOs;
        // The length of the path varies and it's possible, that the path is too long
        // to transfer it in SDO header. Instead of it the compressed path is used for addressing.
        
        ui_PathLength := pObject^.ui_PathCompLen;
        p_RoutElement^.p_CompressedPath$pVoid := ToStdLib.Malloc(size := ui_PathLength);

        if ( p_RoutElement^.p_CompressedPath = NIL ) then
        
          sd_retval                         := -1;
          SetSafetyState(NewState:=_MemAllocFailed);
          return;
          
        end_if;

        // store compressed path into actual routing element
        ToStdLib.MemCpy(dest := p_RoutElement^.p_CompressedPath, source := pObject^.p_us_PathComp, size := ui_PathLength);      
        p_RoutElement^.ui_ComprPathLen := ui_PathLength;
      elsif NewElement then
          
        // not routing table of safety CPU of safety output
        p_RoutElement^.p_CompressedPath := NIL;
        p_RoutElement^.ui_ComprPathLen := 0;
      end_if;
        
      //insert data
      p_RoutElement^.ud_SafeNumber := ud_SafeNumber;
      p_RoutElement^.ud_thisp      := ud_thisp;
      
      if NewElement then
        //increase counter
        ui_CntRoutElements += 1;
      end_if;
        
      sd_retval := 0;
    else
    
      sd_retval := -1;
      LogError("AddRoutingElement: Maximum number of possible routing elements reached");
    end_if;
  else
  
    sd_retval := -1;
  
    if ud_SafeNumber = 0 then
      LogError("AddRoutingElement: 0 is an invalid safety number");
    else
      LogError("AddRoutingElement: NIL pointer given as this pointer");
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetRoutingPointerByNumber
	VAR_INPUT
		ud_SafeNumber 	: HDINT;
	END_VAR
	VAR_OUTPUT
		ud_thisp 	: UDINT;
	END_VAR
  VAR
  	i               : UINT;
    p_RoutElement   : ^RoutElement;
  END_VAR

  ud_thisp := 0;
  
  //no valid safety number
  if ( ud_SafeNumber = 0 ) then
    return;
  end_if;
  
  //set pointer on first routing element
  p_RoutElement := p_RoutTable;
  
  //check each element
  if ( ui_CntRoutElements > 0 ) then
    for i := 0 to ui_CntRoutElements - 1 by 1 do 
    
      //if searched safety number is found, this-pointer is returned
      if ( p_RoutElement^.ud_SafeNumber = ud_SafeNumber ) then
      
        ud_thisp := p_RoutElement^.ud_thisp;
        return;
        
      end_if;
      
      //set pointer to next element
      p_RoutElement += sizeof ( RoutElement );
    
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetRoutingPointerByPath
	VAR_INPUT
		p_ActObjectPath 	: ^USINT;
		ActPathLen 	: UINT;
	END_VAR
	VAR_OUTPUT
		ud_thisp 	: UDINT;
	END_VAR
  VAR
  	i                 : UINT;
    p_RoutElement     : ^RoutElement;
    retcode : UINT;
  END_VAR

  ud_thisp := 0;
  
  //set pointer on first routing element
  p_RoutElement := p_RoutTable;
  
  //check each element
  if ( ui_CntRoutElements > 0 ) then
    for i := 0 to ui_CntRoutElements - 1 by 1 do 
    
      if p_RoutElement^.p_CompressedPath & (p_RoutElement^.ui_ComprPathLen = ActPathLen) then
      
        //if searched path is found, this-pointer is returned
        retcode := ToStdLib.MemCmp(dest:= p_ActObjectPath, source:= p_RoutElement^.p_CompressedPath , size:= ActPathLen);
        
        if retcode = 0 then
        
          ud_thisp := p_RoutElement^.ud_thisp;
          return;
          
        end_if;
      end_if;
      
      //set pointer to next element
      p_RoutElement += sizeof ( RoutElement );
    
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ConfigSafetyInput
	VAR_INPUT
		ud_SafeNrCPU 	: HDINT;
		ud_thisp 	: UDINT;
		p_PDOBuffer 	: ^UDINT;
		pMoveActive 	: ^PDOMoveState;
		p_ud_HandleSourceDO 	: ^UDINT;
		p_ud_MoveSourceAddr 	: ^UDINT;
		p_ud_MoveSourceOffset 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ud_SafeNrModul 	: HDINT;
	END_VAR
  VAR
  	TempPathInfo  : PathInfoType;
  END_VAR

  ud_SafeNrModul := 0;

  if ( ud_SafeNrCPU ) then

    // if pMoveActive is available, the data are sent to a CPU via VARAN => moving is possible
    if pMoveActive then
      // if input module is also accessed via VARAN => activate moving
      if b_VaranAvailable & (b_SafetyOnLocalCDIAS = FALSE) then
        // pdos are moved from csdi to cscp
        b_MoveCommandOutputActive := _Active;
        
        p_ud_MoveSourceAddr^  := InputMovSettings.MoveSettingsBusIF.p_sourcedata$UDINT;
        
        // Return DO Handle and Offset, Needed for Payload Move DOs
        p_ud_HandleSourceDO^  := InputMovSettings.MoveSettingsBusIF.ud_handle_source;        
        p_ud_MoveSourceOffset^:= InputMovSettings.MoveSettingsBusIF.ud_addressoff_source; 
      else
        // pdos are not moved from csdi to cscp or cscp to csto
        pMoveActive^ := _Inactive;
        b_MoveCommandOutputActive := _Inactive;
      end_if;
    else
      b_MoveCommandOutputActive := _Inactive;
    end_if;
    
    InitPathInfo(#TempPathInfo);
  
    //add CPU to routing table for SDO
    if ( AddRoutingElement( ud_SafeNumber   := ud_SafeNrCPU
                          , ud_thisp        := ud_thisp
                          , pObject         := #TempPathInfo
                          ) = 0 ) then
    
      //return own safety number
      ud_SafeNrModul := SafetyNumber;
      
    end_if;
    
    //set pointer to address of buffer pointer
    p_PDOBuffer^ := GetPointer2PDOBuffer();
  else
    LogError("ConfigSafetyInput: 0 is an invalid safety number for the safety CPU");
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ConfigSafetyOutput
	VAR_INPUT
		ud_SafeNrCPU 	: HDINT;
		ud_thisp 	: UDINT;
		ud_p_PDOBuffer 	: UDINT;
		pObject 	: ^PathInfoType;
		pMoveActive 	: ^PDOMoveState;
		ud_HandleSourceDO 	: UDINT;
		ud_MoveSourceAddr 	: UDINT;
		ud_MoveSourceOffset 	: UDINT;
		b_IsOptional 	: BOOL;
	END_VAR
	VAR_OUTPUT
		ud_SafeNrModul 	: HDINT;
	END_VAR
  VAR
  	i : DINT;
  END_VAR

  ud_SafeNrModul := 0;
  
  if ( ud_SafeNrCPU ) then
  
    //add CPU to routing table for SDO
    if ( AddRoutingElement( ud_SafeNumber   := ud_SafeNrCPU
                          , ud_thisp        := ud_thisp
                          , pObject         := pObject
                          ) = 0 ) then
    
      //return own safety number and object path
      ud_SafeNrModul := SafetyNumber;
      
    end_if;

    //add PDO of CPU to list of input elements
    AddPDOToInputBuffer(ud_p2Buffer         := ud_p_PDOBuffer
                      , ud_HandleSourceDO   := ud_HandleSourceDO
                      , ud_MoveSourceAddr   := ud_MoveSourceAddr
                      , ud_MoveSourceOffset := ud_MoveSourceOffset
                      , ud_SafetyNr         := ud_SafeNrCPU
                      , b_IsOptional        := b_IsOptional
                      );

    // if we got an adress of the source data from cpu, the cpu must be connected via VARAN => moving is possible
    if ud_MoveSourceAddr then
      
      // if output module is also accessed via VARAN => activate moving
      if b_VaranAvailable & (b_SafetyOnLocalCDIAS = FALSE) then
        // pdos are moved from cscp to csto
        b_MoveCommandInputActive := _Active;
      else
        // pdos are not moved from cscp to csto because csto is not connected via VARAN
        if pMoveActive then
          pMoveActive^ := _Inactive;        
        end_if;
        b_MoveCommandInputActive := _Inactive;      
      end_if;      
    else
      // pdos are not moved from cscp to csto because cscp (and/or csto) is not connected via VARAN
      if pMoveActive then
        pMoveActive^ := _Inactive;        
      end_if;
      b_MoveCommandInputActive := _Inactive;      
    end_if;

    // we start the data object for continous writing to the module after we know that there is an input for this module and the move command is active
    SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
    
    if AdditionalSPDOs & (ui_cnt_PDOInputBuffer > 1) then
      if AdditionalSPDOs > (ui_cnt_PDOInputBuffer-1) then
        AdditionalSPDOs := ui_cnt_PDOInputBuffer-1;
      end_if;

      for i := 0 to (AdditionalSPDOs-1) do
        SetDORunState(Handle:=aAdditionalPDOs[i].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
      end_for;
    end_if;
  else
    LogError("ConfigSafetyOutput: 0 is an invalid safety number for the safety CPU");
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ConfigSafetyCPU
	VAR_OUTPUT
		ud_SafeNrModul 	: HDINT;
	END_VAR
  VAR
    sd_retval : DINT;  	
  END_VAR

  // if there is no safetynumber available yet, try to get it
  if SafetyNumber = 0 then
    if Online then
      sd_retval := SDOStdRequ ( us_Command      := SB_SDO_COMMAND_GET_SAFENBR
                              , p_us_RespData   := ( #SafetyNumber )$^USINT
                              , us_RespLength   := sizeof(SafetyNumber)
                              );
      
      if ( sd_retval <> 0 ) then
        
        LogError(e_msg:="No Safety Number available!");
        
      end_if;
    else
      LogError(e_msg:="No Safety Number available!");    
    end_if;
  end_if;

  //return own safety number
  ud_SafeNrModul := SafetyNumber;      
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddPDOToInputBuffer
	VAR_INPUT
		ud_p2Buffer 	: UDINT;
		ud_HandleSourceDO 	: UDINT;
		ud_MoveSourceAddr 	: UDINT;
		ud_MoveSourceOffset 	: UDINT;
		ud_SafetyNr 	: HDINT;
		b_IsOptional 	: BOOL;
		us_PdoLen 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	p_BufferElement : ^PDOInputBuffer;
  END_VAR
  
  sd_retval := 0;
  
  //check if input buffer is already in list
  p_BufferElement := GetPDOInputBuffer(ud_p2Buffer := ud_p2Buffer);
  
  //buffer already in list -> do nothing
  if ( p_BufferElement ) then
    return;
  else
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].ud_p2Buffer        := ud_p2Buffer;
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].ud_HandleSourceDO  := ud_HandleSourceDO;   //LanSte 28.05.2013 For Payload support
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].ud_MoveSourceAddr  := ud_MoveSourceAddr;
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].ud_MoveSourceOffset:= ud_MoveSourceOffset; //LanSte 28.05.2013 For Payload support
    //*****************************************************************************
    
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].b_TimeSynchron     := FALSE;
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].ud_SafetyNr        := ud_SafetyNr;
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].us_PDOLen          := us_PDOLen;
    aPDOInputBuffer[ui_cnt_PDOInputBuffer].b_IsOptional       := b_IsOptional;

    if ui_cnt_PDOInputBuffer = 0 then
      // only when adding the first input PDO we increment our module counter
      ModuleSyncNo += 1;
    end_if;

    ui_cnt_PDOInputBuffer += 1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::WritePDO2Module
  VAR
    p_PDOInBufferAct  : ^PDOInputBuffer;
    p_PDO_data        : ^UINT;
    PDOLength         : USINT;
    i : DINT;
  END_VAR

  // if last PDO was selected (or a PDO which doesn't exist anymore), select first
  if ( ui_cnt_PDOInBufferAct >= ui_cnt_PDOInputBuffer ) then
    ui_cnt_PDOInBufferAct := 0;
  end_if;

  p_PDOInBufferAct := #aPDOInputBuffer[ui_cnt_PDOInBufferAct];

  if b_MoveCommandInputActive <> _Active then
    p_PDO_data := p_PDOInBufferAct^.ud_p2Buffer$^UINT;

    // get length out of PDO frame
    PDOLength := (p_PDO_data$^USINT + PDOType.Length)^ + sizeof(PDOType.CRC);

    // only if length is bigger than minimum and smaller than maximum
    if ( PDOLength > PDOType.Length ) & ( PDOLength <= SB_SPDO_MAX_LENGTH ) then
      //copy whole PDO 
      ToStdLib.MemCpy(dest := pPDOWriteData, source := p_PDO_data, size := PDOLength);

#ifdef DO_DEBUG
      DOCheck(pFrame:=p_PDO_data$^t_SDOStdHeader, pCheckStruct:=#PDOWrite);
#endif


#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame(p_PDO_data$^DINT, 1);
#endif

      SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
      PDOSingleRunActive := 2;

      if AdditionalSPDOs then
      
        for i := 0 to (AdditionalSPDOs-1) do
        
          //increase counter for pointer position for next PDO
          ui_cnt_PDOInBufferAct += 1;

          //if last PDO was read, reset counter for first PDO 
          if ( ui_cnt_PDOInBufferAct = ui_cnt_PDOInputBuffer ) then
            ui_cnt_PDOInBufferAct := 0;
          end_if;

          p_PDOInBufferAct := #aPDOInputBuffer[ui_cnt_PDOInBufferAct];

          p_PDO_data := p_PDOInBufferAct^.ud_p2Buffer$^UINT;

          // get length out of PDO frame
          PDOLength := (p_PDO_data$^USINT + PDOType.Length)^ + sizeof(PDOType.CRC);

          // only if length is bigger than minimum and smaller than maximum
          if ( PDOLength > PDOType.Length ) & ( PDOLength <= SB_SPDO_MAX_LENGTH ) then

            //copy whole PDO 
            ToStdLib.MemCpy(dest := aAdditionalPDOs[i].pPDOWriteData, source := p_PDO_data, size := PDOLength);

#ifdef DO_DEBUG
            DOCheck(pFrame:=p_PDO_data$^t_SDOStdHeader, pCheckStruct:=#PDOWrite);
#endif

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame(p_PDO_data$^DINT, 1);
#endif

            SetDORunState(Handle:=aAdditionalPDOs[i].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
          end_if;
        end_for;
      end_if;
    end_if;
  else
    if p_PDOInBufferAct^.ud_MoveSourceAddr then      
      PDOLength := ((p_PDOInBufferAct^.ud_MoveSourceAddr)$^USINT + PDOType.Length)^ + sizeof(PDOType.CRC);
      
      if ( PDOLength > PDOType.Length ) & ( PDOLength <= SB_SPDO_MAX_LENGTH) then

        UpdateMovDO(p_MoveSettings      := #InputMovSettings
                  , ud_NewSourceHandle  := p_PDOInBufferAct^.ud_HandleSourceDO
                  , ud_NewSourceOffset  := p_PDOInBufferAct^.ud_MoveSourceOffset
                  , ud_NewSourcePointer := p_PDOInBufferAct^.ud_MoveSourceAddr
                  , ui_NewLength        := PDOLength
                  );
  
        if AdditionalSPDOs then
        
          for i := 0 to (AdditionalSPDOs-1) do
          
            //increase counter for pointer position for next PDO
            ui_cnt_PDOInBufferAct += 1;

            //if last PDO was read, reset counter for first PDO 
            if ( ui_cnt_PDOInBufferAct = ui_cnt_PDOInputBuffer ) then
              ui_cnt_PDOInBufferAct := 0;
            end_if;
            
            p_PDOInBufferAct := #aPDOInputBuffer[ui_cnt_PDOInBufferAct];

            if p_PDOInBufferAct^.ud_MoveSourceAddr then      
              PDOLength := ((p_PDOInBufferAct^.ud_MoveSourceAddr)$^USINT + PDOType.Length)^ + sizeof(PDOType.CRC);
              
              UpdateMovDO(p_MoveSettings      := #aAdditionalPDOs[i].InputMovSettings
                        , ud_NewSourceHandle  := p_PDOInBufferAct^.ud_HandleSourceDO
                        , ud_NewSourceOffset  := p_PDOInBufferAct^.ud_MoveSourceOffset
                        , ud_NewSourcePointer := p_PDOInBufferAct^.ud_MoveSourceAddr
                        , ui_NewLength        := PDOLength
                        );
            end_if;
          end_for;
        end_if;
      end_if;
    else
      LogError(e_msg:="(SafetyBase::WritePDO2Module) Can't change Move-Command, because the new source address is invalid"); // causes rt-runtime error
    end_if;
  end_if;

  //increase counter for pointer position for next PDO
  ui_cnt_PDOInBufferAct += 1;

  //if last PDO was read, reset counter for first PDO 
  if ( ui_cnt_PDOInBufferAct = ui_cnt_PDOInputBuffer ) then
    ui_cnt_PDOInBufferAct := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddModuleToSafetyTask
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  
  //register module as safety module in OS and receive pointers on SDO buffers
  sd_retval := SAFETY_iAddModuleToSafetyTask( uiMaster  := 0
                                            , pucNode   := p_ObjectPath
                                            , pucRdSDO  := ( #p_Handle_SDO_Read )$^UDINT
                                            , pucWrSDO  := ( #p_Handle_SDO_Write )$^UDINT
                                            );
  
  //look for an error
	if ( sd_retval ) then
    
    LogError(e_msg := "SafetyBase: Module not added to Safety Communication Task");
    
	end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetModuleID
	VAR_OUTPUT
		ud_ModuleID 	: UDINT;
	END_VAR

  // no module
  ud_ModuleID := 16#ff;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::Init
  VAR
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR

//============================ Profiler start======================================================
#ifdef DM_Profiler 
  InitTimeMeasurement(usMode := DMTIME_RT);
  InitTimeMeasurement(usMode := DMTIME_CY);
  InitTimeMeasurement(usMode := DMTIME_RTPOSTSCAN);
#endif
//============================ Profiler end========================================================

  // don't initialize anything if the module is deactivated
  if b_Deactivated then
    return;
  end_if;

  case InitStep of
//**********************************************************************************************************************************************************
    0:
    
      // first check if the module may be deactivated
      MyPara.uiCmd     := _BUS_IF_GET_DEACTIVATED_STATE;
      
      ToBusInterface.NewInst(pPara:=#MyPara, pResult:=#MyResult);
      if MyResult.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
        b_Deactivated := MyResult.aData[4]$BOOL;
        if b_Deactivated then
          return;
        end_if;
      else
        LogError("(SafetyBase::Init) Failed to get deactivation state via BusInterface");
      end_if;
    
      // initialize
      if InitSafetyBase() then
        InitStep += 1;
      end_if;
    
//**********************************************************************************************************************************************************
    1:      
      // if there is any module connected via CDIAS, we have to disable our internal move command
      if b_SafetyOnLocalCDIAS then
        b_MoveCommandInputActive := _Inactive;
        b_MoveCommandOutputActive := _Inactive;      
      end_if;

      InitStep += 1;
      
//**********************************************************************************************************************************************************
   2:
      // initialize safety module specific data (cpu, input, output) in last init and send OK to CPU
      if (us_FirstScan = 10) then
        // log in to safety manager, if there is one
        if pSafetyManagerThis then
          MyPara.uiCmd := CMD_SM_ADD_MODULE;
          MyPara.aPara[0] := DeviceID$DINT;
          MyPara.aPara[1] := THIS$DINT;
          pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
          
          // check if quit error is avaialble
          MyPara.uiCmd := CMD_SM_QUIT_ERROR_AVAILABLE;
          MyPara.aPara[0] := THIS$DINT;
          pSafetyManagerThis^.NewInst(#MyPara, #MyResult);

          b_QuitErrorAvailable := MyResult.aData[0]$DINT <> 0;
        else
          // if there is no manager, we don't have to wait in cywork until the initialisation is finished
          b_ManagerInitialisationFinished := TRUE;
          b_ManagerReadyForSDO := TRUE;
        end_if;

        InitSafeModule();
      end_if;
//**********************************************************************************************************************************************************
  end_case;

  us_FirstScan += 1;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetTaskPriority
	VAR_OUTPUT
		us_TaskPriority 	: USINT;
	END_VAR

  // highest = default-priority (no change in update order)
  us_TaskPriority := 0;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::InitSafeModule
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  sd_retval := 0;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::StartDO
  VAR
  	i : DINT;
  END_VAR

  if b_DOsAlreadyStarted = FALSE then
    b_DOsAlreadyStarted := TRUE;
    
    // seperate the data pointers for read fast unsafe outputs, timesync handshake read and led/io states
    if ActivateFastUnsafeIOs then
      pFastUnsafeOutputs   := pTempTimeSyncRead$^UDINT;
      pTimeSyncHS_ReadData := pFastUnsafeOutputs + (SB_OFFSET_GPDR1_RD - SB_OFFSET_GPDR2_RD);
    else
      pFastUnsafeOutputs := NIL;
      pTimeSyncHS_ReadData := pTempTimeSyncRead$^t_TimeSyncHandshake;
    end_if;
    pLEDandIOStates := pTimeSyncHS_ReadData$^USINT + (SB_OFFSET_IO_STATES - SB_OFFSET_GPDR1_RD);


    // seperate the data pointers for fast unsafe inputs (if activated) and unsafe outputs (enable signals for safe outputs)
    // first check if this DO is available
    if pTempUnsafeWrData then
      if ActivateFastUnsafeIOs then
        pFastUnsafeInputs := pTempUnsafeWrData$^UDINT;
        if OutputsCount then
          pUnsafeOutWrData := pFastUnsafeInputs + (SB_OFFSET_UNSAFE_VAR_WR - SB_OFFSET_GPDR2_WR);
        else
          pUnsafeOutWrData := NIL;
        end_if;
      else
        pFastUnsafeInputs := NIL;
        if OutputsCount then
          pUnsafeOutWrData := pTempUnsafeWrData;
        else
          pUnsafeOutWrData := NIL;
          LogError("(SafetyBase::StartDO) Invalid case: Pointer for unsafe write data available, but no option enabled for this!");
        end_if;      
      end_if;
    end_if;
  end_if;


  // enable the DOs
  SetDORunState(Handle:=HandleTimeSyncRead, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);

  if pTempUnsafeWrData then
    SetDORunState(Handle:=HandleUnsafeOutWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
  end_if;
  
  SetDORunState(Handle:=HandleStatusInfo, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);

  SetDORunState(Handle:=HandleTDORead, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);

  if MyPDOReadSize then
    SetDORunState(Handle:=HandlePDORead, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
  end_if;

  if MyIFPDOReadSize then  
    SetDORunState(Handle:=HandlePDOReadIF, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
  end_if;

  if MyPDOWriteSize then
    SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
    if (AdditionalSPDOs > 0) then      
      for i := 0 to (AdditionalSPDOs-1) do
        SetDORunState(Handle:=aAdditionalPDOs[i].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
      end_for;
    end_if;  
  end_if;

  // or disable the DOs
  SetDORunState(Handle:=HandleTDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::StopDO
  VAR
  	i : DINT;
  END_VAR

  // disable the DOs
  SetDORunState(Handle:=HandleTimeSyncRead, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

  if pTempUnsafeWrData then
    SetDORunState(Handle:=HandleUnsafeOutWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
  end_if;
  
  SetDORunState(Handle:=HandleStatusInfo, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

  if MyPDOReadSize then
    SetDORunState(Handle:=HandlePDORead, NewState:=_BUS_IF_RUN_STATE_NO_RUN);  
  end_if;

  if MyIFPDOReadSize then
    SetDORunState(Handle:=HandlePDOReadIF, NewState:=_BUS_IF_RUN_STATE_NO_RUN);  
  end_if;

  if MyPDOWriteSize then
    SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
    
    // if the Move-DO is started
    if InputMovSettings.EnableState = _BUS_IF_RUN_STATE_CONT_RUN then
      // => stop it
      SetDORunState(Handle := InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
      InputMovSettings.EnableState := _BUS_IF_RUN_STATE_NO_RUN;
    end_if;
  
    if (AdditionalSPDOs > 0) then      
      for i := 0 to (AdditionalSPDOs-1) do
        SetDORunState(Handle:=aAdditionalPDOs[i].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

        // if the Move-DO is started
        if aAdditionalPDOs[i].InputMovSettings.EnableState = _BUS_IF_RUN_STATE_CONT_RUN then
          // => stop it
          SetDORunState(Handle := aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
          aAdditionalPDOs[i].InputMovSettings.EnableState := _BUS_IF_RUN_STATE_NO_RUN;
        end_if;
      end_for;
    end_if;  
  end_if;
  
  SetDORunState(Handle:=HandleTDORead, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

  SetDORunState(Handle:=HandleTDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::InitBuffers
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  sd_retval := -1;
  
  //allocate memory for outgoing SDO (one SDO possible)
  p_SDOOutputBuffer$^void := ToStdLib.Malloc(size := SB_SDO_MAX_LENGTH);
  
  if ( p_SDOOutputBuffer = NIL ) then
    SetSafetyState(NewState:=_MemAllocFailed);
    return;
  end_if;

  //allocate memory for incoming SDO list (number of SDO is dynamical) 
  //following elements will be added dynamical
  
  //allocate list
  InputBufferAllocatedNo := SB_SDO_BUFFER_ALLOC_BLOCK;
  p_SDOInputBuffer$^void := ToStdLib.Malloc(size := InputBufferAllocatedNo * SB_SDO_MAX_LENGTH);
  
  if ( p_SDOInputBuffer = NIL ) then
    SetSafetyState(NewState:=_MemAllocFailed);
    return;
  end_if;

  //all buffers initialized
  sd_retval := 0;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetSafetyNumber
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	TempPathInfo  : PathInfoType;
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR

  sd_retval := SDOStdRequ ( us_Command      := SB_SDO_COMMAND_GET_SAFENBR
                          , p_us_RespData   := ( #SafetyNumber )$^USINT
                          , us_RespLength   := sizeof(SafetyNumber)
                          );
  
  if ( sd_retval <> 0 ) then
    
    LogError(e_msg:="No Safety Number available!");
  
  end_if;

  sd_retval := SDOStdRequ ( us_Command      := SB_SDO_COMMAND_GET_FW_VERSION
                          , p_us_RespData   := ( #sFirmwareVersion )$^USINT
                          , us_RespLength   := sizeof(FirmwareVersionType)
                          );
  
  if ( sd_retval = 0 ) then
    FirmwareVersion := sFirmwareVersion.RevMinor OR (sFirmwareVersion.RevMajor SHL 16);

    // Minor Versions starting with 9xxx mark Bootloader versions
    if (sFirmwareVersion.RevMinor >= 9000) & (sFirmwareVersion.RevMinor < 10000) then
      LogError("(SafetyBase::GetSafetyNumber) Bootloader version of safety firmware detected! Download a firmware or contact Sigmatek Support!");
    end_if;
    
    //Minor Versions higher than 338 mark versions which support the readout of the safety retry counters.
    if (sFirmwareVersion.RevMinor >= SB_RETRY_COUNTER_AVAILABLE_MINOR_REV) & (sFirmwareVersion.RevMajor = SB_RETRY_COUNTER_AVAILABLE_MAJOR_REV) then
      b_RetryCounterAvailable := TRUE;
    else
      b_RetryCounterAvailable := FALSE;
      //Call Method to set retrycounter servers of safety modules to -1
      SetRetryCounter();
    end_if;

    
  else
    SetSafetyState(NewState:=_ReadFWVerFailed);
    LogError(e_msg:="No Firmware Version available!");
  end_if;

  InitPathInfo(#TempPathInfo);
  
  // add own safety number to routing table
  sd_retval := AddRoutingElement( ud_SafeNumber       := SafetyNumber
                                , ud_thisp            := this$UDINT
                                , pObject             := #TempPathInfo
                                );

  // give the manager more details about the module
  if pSafetyManagerThis then
    MyPara.uiCmd := CMD_SM_ADD_MODULE_INFO;
    MyPara.aPara[0] := THIS$DINT;
    MyPara.aPara[1] := SafetyNumber$DINT;
    MyPara.aPara[2] := FirmwareVersion$DINT;
    MyPara.aPara[3] := 16#FF; // fake FPGA_Version (only needed for CDIAS CPUs)
    MyPara.aPara[4] := to_DINT(p_ObjectPath^$USINT) + 1; // size of path (length + 1 for the length information)
    MyPara.aPara[5] := p_ObjectPath$DINT;
    pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
  else
    LogError(e_msg:="(SafetyBase::GetSafetyNumber) Couldn't find object of HwControl class, which is needed for safety time synchronisation!");
  end_if;

END_FUNCTION


FUNCTION SafetyBase::SafetyBase
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    p_SSR			: ^LSL_SSR;
  END_VAR

  //get pointer for logging function
	if ( OS_CILGET( "SSR", #p_SSR ) ) then
    p_KernelLog := NIL;
  else
    //Log function is available
		p_KernelLog := ( p_SSR^.KernelLog )$^DINT;
  end_if;

  //get interface for safety functions
  if ( OS_CILGET(INTERFACE_SAFETY, #pISafety)) then
    pISafety := NIL;
		
    LogError(e_msg := "No Safety Interface found!");
  end_if;

  // initialize it with FALSE, if there is anything on local CDIAS it will change to TRUE
  b_SafetyOnLocalCDIAS := FALSE;

  // initialize module count with 0
  ModuleSyncNo := 0;
    
  ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::UpDateNotStd

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ReadSDOConfig
	VAR_INPUT
		p_SDORequestBuffer 	: ^SDORequReadConfig;
		p_SDOResponseBuffer 	: ^SDORespReadConfig;
		pModule 	: ^PathInfoType;
		pListHeader 	: ^PathInfoType;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    ud_Address                    : UDINT;
    ud_ListLength_Address         : UDINT;
    ud_ListLength                 : UDINT;
    ud_TmpCnt                     : UDINT;
    i                             : UDINT;
    ud_ModulePathLen_Max          : UDINT;
    ud_ModulePathCompLen_Max      : UDINT;
    ud_ListHeaderPathLen_Max      : UDINT;
    ud_ListHeaderPathCompLen_Max  : UDINT;
    us_DataLength_Max             : USINT;
    ud_ListBaseAddress            : UDINT;
    ud_ListAddressMax             : UDINT;
    ud_CntUnsafeOutputs           : UDINT;
    ud_CntUnsafeInputs            : UDINT;
    ud_ActAddress                 : UDINT;  // actual offset in application memory (where to find the values in run mode)
    ud_UnsafeBDINT_Offset         : UDINT;  // actual offset in application memory (where to find the unsafe variables in run mode)
    ud_ActBlockType               : UDINT;
    ud_TmpAddress                 : UDINT;
    ud_TmpStrLen                  : UDINT;
    p_TmpBlockedData              : ^void;
    ud_ActStrLen                  : UDINT;
    us_BlockedTransferLength      : USINT;
    BoolOuts                      : UDINT;
    DintOuts                      : UDINT;    
    TempModuleConfig              : t_ModuleCfg;
    pChar                         : ^CHAR;
    TempPath                      : ARRAY [0..99] OF USINT;
    PathOfThisCPU                 : ARRAY [0..99] OF USINT;
    GotOwnPath                    : BOOL;
    TempPdoConfig                 : t_PdoCfg;
    pBitMasks                     : ^BDINT;
    ActBitMask                    : BDINT;
    ud_skipLength                 : UDINT; //++pr
    b_CfgTypeV2                   : BOOL; // FALSE means there is no support of new time synchronisation/new general purpose register
    TmpCRC                        : HDINT;
    ud_ContainerBlockType         : UDINT;
    b_CfgTypeV3                   : BOOL;
    ud_ConfigLength               : UDINT;
    hd_DynParaVersion             : UDINT;
    DynamicParameterHeader        : t_DynamicParameterHeader;
  END_VAR

  // Initialize the variables with invalid if we are located on VARAN. If any module to communicate with is not located on VARAN, it will change to inactive. (ConfigSafetyInput/Output)
  if b_VaranAvailable then
    b_MoveCommandInputActive := _Invalid;
    b_MoveCommandOutputActive := _Invalid;
  else
    // if no VARAN, we can't move the PDOs
    b_MoveCommandInputActive := _Inactive;
    b_MoveCommandOutputActive := _Inactive;
  end_if;
    
  //minimum length of path: 2 bytes length, 1 byte domain info, 1 byte bus type and 1 byte port  => we use maximum so we don't have dynamic memory => don't fragment heap
  ud_ModulePathLen_Max          := 128;
  ud_ModulePathCompLen_Max      := 128;
  ud_ListHeaderPathLen_Max      := 128;
  ud_ListHeaderPathCompLen_Max  := 128;
  
  NewConfigType := ConfigState_NotInitialized;
  
  //initialize header-data for request
  
  //calculate length without crc
  p_SDORequestBuffer^.StdHeader.Len := sizeof(SDORequReadConfig) - sizeof(SDOHeader.StdHeader.CRC);
  
  //type
  p_SDORequestBuffer^.StdHeader.Typ := SDO_STD;
  
  //command for reading config data
  p_SDORequestBuffer^.StdHeader.Cmd := SB_SDO_COMMAND_READ;
  
  
  //read crc of whole config data
  
  //send request and receive data
  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                              , ud_Address          := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_CRC_ALL
                              , us_Length           := 4
                              );

  //no response
  if ( sd_retval <> 0 ) then
    LogError("Config Read Error: Error reading CRC of config data");
    return;
  end_if;
  
  // save crc and remember the time
  DesignerPrjConfigCRC := p_SDOResponseBuffer^.ud_Data;
  ud_LastCrcCheck := ops.tAbsolute;
  b_CheckCRC := TRUE;
  
  //read length of whole config data
  
  //send request and receive data
  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                              , ud_Address          := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_LEN_ALL
                              , us_Length           := 4
                              );

  //no response
  if ( sd_retval <> 0 ) then
    LogError("Config Read Error: Error reading length of config data");
    return;
  end_if;
  
  //no config data available
  if ( p_SDOResponseBuffer^.ud_Data = 16#FFFF_FFFF ) then
    LogError("Config Read Error: No config data available.");
    return;
  end_if;
  
  ud_ConfigLength := p_SDOResponseBuffer^.ud_Data;
  
  
  // get BlockType
  //send request and receive data
  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                              , ud_Address          := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_BLOCKTYPE
                              , us_Length           := 4
                              );
  //no response, error
  if ( sd_retval <> 0 ) then
    LogError("Config Read Error: Error getting the block type of the header");
    return;
  end_if;  

  ud_ContainerBlockType := p_SDOResponseBuffer^.ud_Data;

  // check if it's a new version of the configuration
  if (ud_ContainerBlockType = SB_BLKTYPE_CFG_CONTAINER_V3)       |
     (ud_ContainerBlockType = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE)     |
     (ud_ContainerBlockType = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE_OPTIONAL) then

    //read dynamic header length (how many data are attached to the header)
    
    //send request and receive data
    sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                , p_SDOResponseBuffer := p_SDOResponseBuffer
                                , ud_Address          := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_LEN_HEAD
                                , us_Length           := 4
                                );

    //no response
    if ( sd_retval <> 0 ) then
      LogError("Config Read Error: Error reading length of dynamic header data");
      return;
    end_if;

    // plausibility check for data length
    if p_SDOResponseBuffer^.ud_Data > 1000 then
      sd_retval := -1;
      LogError("Config Read Error: Invalid length of dynamic header data");
      return;
    end_if;


    // the length info contains: size of length info + size of time info + size of additional data

    //start address of first list: address of dynamic length + length according to length info
    ud_ListBaseAddress := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_LEN_HEAD + p_SDOResponseBuffer^.ud_Data;
    
    // if we got at least 4 byte additional header data, it's the version of the dynamic parameters => read it
    if p_SDOResponseBuffer^.ud_Data >= 12 then
      //send request and receive data
      sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                  , p_SDOResponseBuffer := p_SDOResponseBuffer
                                  , ud_Address          := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_LEN_HEAD + 8
                                  , us_Length           := 4
                                  );

      //no response
      if ( sd_retval <> 0 ) then
        LogError("Config Read Error: Error reading length of dynamic header data");
        return;
      end_if;
      
      hd_DynParaVersion := p_SDOResponseBuffer^.ud_Data;
    else
      LogError("Config Read Error: Data structure error in config! No bytes for the dynamic parameter version (according to length info)");
      return;
    end_if;
  else
    // old version => no dynamic header, the first list starts where the dynamic header length would be

    //start address of first list: address of time info + size of time info
    ud_ListBaseAddress := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_LEN_HEAD + sizeof(UDINT);
  end_if;

  GotOwnPath := FALSE;
  
  //highest address for config data
  ud_ListAddressMax := SDO_ADDRESS_CONFIG_DATA + SDO_OFFSET_CONFIG_LEN_ALL + ud_ConfigLength;

  //max. length of data to read with one request
  us_DataLength_Max := SB_SDO_MAX_LENGTH - sizeof(SDORespReadConfig) + sizeof(SDORespReadConfig.ud_Data);
  
  while ( ud_ListBaseAddress < ud_ListAddressMax ) do
    
    //first read length of path in list-header     
      
    //read path in list-header
    sd_retval := ReadModulePath ( p_SDORequestBuffer          := p_SDORequestBuffer
                                , p_SDOResponseBuffer         := p_SDOResponseBuffer
                                , p_ud_Address                := #ud_ListBaseAddress
                                , pModule                     := pListHeader
                                , p_ud_ModulePathLen_Max      := #ud_ListHeaderPathLen_Max
                                , p_ud_ModulePathCompLen_Max  := #ud_ListHeaderPathCompLen_Max
                                , us_SDOMaxDataSize           := us_DataLength_Max
                                );

    //no response, error
    if ( sd_retval <> 0 ) then
      LogError("Config Read Error: Error reading module path out of config data");
      return;
    end_if;

    // remember our own uncompressed path (first listheader path in the memory)
    if pListHeader^.p_us_Path & (GotOwnPath = FALSE) then
      GotOwnPath := TRUE;

      // remember the path
      _memcpy(ptr1:=#PathOfThisCPU[0], ptr2:=pListHeader^.p_us_Path, cntr:=(pListHeader^.p_us_Path$^UINT)^ + 2);      
    end_if;

    //read length of download data in list-header (=LengthOverall) and save address
    //to calculate later the address of next list-header
    //address = last address + 4 byte (CRC)
    ud_ListLength_Address := ud_ListBaseAddress + 4;
    
    //send request and receive data
    sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                , p_SDOResponseBuffer := p_SDOResponseBuffer
                                , ud_Address          := ud_ListLength_Address
                                , us_Length           := 4
                                );

    //no response
    if ( sd_retval <> 0 ) then
      LogError("Config Read Error: Failed to read out the length of the download data within the configuration");
      return;
    end_if;
    
    //save length of list
    ud_ListLength := p_SDOResponseBuffer^.ud_Data;
    
    //read first opcode in interpreter list
    
    //                                                   v
    //address of LengthOverall + 4 bytes (LengthOverall, BlockType, ModuleID)
    ud_Address := ud_ListLength_Address + 4;

    // get BlockType
    //send request and receive data
    sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                , p_SDOResponseBuffer := p_SDOResponseBuffer
                                , ud_Address          := ud_Address
                                , us_Length           := 4
                                );
    //no response, error
    if ( sd_retval <> 0 ) then
      LogError("Config Read Error: Error getting the block type");
      return;
    end_if;  

    ud_ActBlockType := p_SDOResponseBuffer^.ud_Data;

    case ud_ActBlockType of
//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_CPU, 
      SB_BLKTYPE_CFG_CPU_OPTIONAL , // if we don't need data from an external cpu
      SB_BLKTYPE_CFG_MASTER_CPU: 
        //add other CPUs to routing table
  
        // if there is a valid module path
        if pListHeader^.p_us_Path <> NIL then
          //add module to routing tabs
          sd_retval := AddModuleToRoutingTabs ( pModule       := pListHeader
                                              , pListHeader   := pListHeader
                                              , b_IsOptional  := (ud_ActBlockType = SB_BLKTYPE_CFG_CPU_OPTIONAL)
                                              );
          
          if (sd_retval <> 0 ) then
            if ( SafetyState <> _ModFromCfgNotFound ) then
              LogError("Config Read Error: Failed to add cpu module to routing tabs");
              return;
            end_if;
          end_if;

          TempModuleConfig.Info := 0;
          TempModuleConfig.DestCRCNo := 0;
          TempModuleConfig.pDestCRCs := NIL;
          TempModuleConfig.PdoOutLen := 0;
          
          TempModuleConfig.Info.IsOptional  := (ud_ActBlockType = SB_BLKTYPE_CFG_CPU_OPTIONAL);
          TempModuleConfig.InterfaceCRC     := 0;

          // Remember the path (uncompressed and compressed)
          TempModuleConfig.PathLen := pListHeader^.p_us_Path^$UINT + 2;
          TempModuleConfig.pPath := pListHeader^.p_us_Path;

          TempModuleConfig.CompPathLen := pListHeader^.ui_PathCompLen;
          TempModuleConfig.pCompPath := pListHeader^.p_us_PathComp;

          // if it's our own path, remember the safety number
          if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then       
            TempModuleConfig.SafetyNbr := SafetyNumber;
          else
            TempModuleConfig.SafetyNbr := 0;
          end_if;

          // only when there is a manager
          if pSafetyManagerThis then
            AddModuleToCfg(TempModuleConfig);
          end_if;
        end_if;

//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_SLAVE_COMPR, 
      SB_BLKTYPE_CFG_SLAVE_COMPR_OPTIONAL: //Blocktyp der über die komprimierte Gesamtkonfiguration einer Slave-CPU gegeben wird
        //add other CPUs to routing table

        // if there is a valid module path
        if pListHeader^.p_us_Path <> NIL then
          //add module to routing tabs
          sd_retval := AddModuleToRoutingTabs ( pModule       := pListHeader
                                              , pListHeader   := pListHeader
                                              , b_IsOptional  := (ud_ActBlockType = SB_BLKTYPE_CFG_SLAVE_COMPR_OPTIONAL)
                                              );
          
          if (sd_retval <> 0 ) then
            if ( SafetyState <> _ModFromCfgNotFound ) then
              LogError("Slave Config Read Error: Failed to add cpu module to routing tabs");
              return;
            end_if;
          end_if;
          
          // we skip the config till we get to the interface information of this slave (if it's the source of an interface frame we have to remember it)

          //address of LengthOverall + 3 * 4 bytes (LengthOverall, BlockType, ModuleID) => now the address points to FUB offset
          ud_Address := ud_ListLength_Address + 12;
          
          //skip FUB offset
          ud_Address += 4;
          
          // get no of FUB´s
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the FUB number");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;
          
          // skip no of FUB´s and FUB´s
          ud_Address += (4 + (ud_TmpCnt * 4));

          // get length of path
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the path length");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;
          
          // skip length of path and the path
          ud_Address += (4 + ud_TmpCnt);

          // get length of comp path
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the comp path length");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;
          
          // skip length of comp path and the comp path
          ud_Address += (4 + ud_TmpCnt);

          // skip CRC and LengthOverall to get to the Blocktyp (Modul-Downloaddaten)
          ud_Address += 8;

          // get the block type
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the block type of a slave config");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // check if it's a new version of the configuration
          if (ud_TmpCnt = SB_BLKTYPE_CFG_CONTAINER_V3)       |
             (ud_TmpCnt = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE)     |
             (ud_TmpCnt = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE_OPTIONAL) then

            // skip blocktype to get to the dynamic header length (how many data are attached to the header)
            ud_Address += 4;

            //send request and receive data
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_Address
                                        , us_Length           := 4
                                        );

            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Error reading length of dynamic header data of a slave config");
              return;
            end_if;

            // plausibility check for data length
            if p_SDOResponseBuffer^.ud_Data > 1000 then
              sd_retval := -1;
              LogError("Config Read Error: Invalid length of dynamic header data of a slave config");
              return;
            end_if;


            // the length info contains: size of length info + size of time info + size of additional data
            
            // skip the additional data to get to the path length
            ud_Address += p_SDOResponseBuffer^.ud_Data;
          else
            // old version => no dynamic header, so we skip only blocktype and time info
            ud_Address += 8;
          end_if;

          // get the path length
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the path length");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // skip length of path and the path
          ud_Address += (4 + ud_TmpCnt);

          // get length of comp path
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the comp path length");
            return;
          end_if;  

          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // skip length of comp path and the comp path
          ud_Address += (4 + ud_TmpCnt);

          // skip CRC, LengthOverall, Blocktyp (Modul-Downloaddaten), ModuleID
          ud_Address += 16;
          
          // get the InterfaceCRC
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Slave Config Read Error: Error getting the Inteface-CRC");
            return;
          end_if;  

          TmpCRC := p_SDOResponseBuffer^.ud_Data;

          
          //add slave information to config
          AddSlaveToCfg ( pModule       := pListHeader
                        , b_IsOptional  := (ud_ActBlockType = SB_BLKTYPE_CFG_SLAVE_COMPR_OPTIONAL)
                        , b_IsInterface := (TmpCRC <> 0)
                        , InterfaceCRC  := TmpCRC
                        );

        end_if;

//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_REV: // revision
        
        // check if the list is long enough for a String (more bytes than just the header)
        if ud_ListLength > 12 then
        
          //address of LengthOverall + 3 * 4 bytes (LengthOverall, BlockType, ModuleID) => now the address points to the revision string
          ud_Address := ud_ListLength_Address + 12;
          
          //read out the string (length = LengthOverall - length header)
          
          // get memory for the string
          if pPrjNameStr = NIL then
            PrjNameMemLen := ud_ListLength$USINT - 12;
            pPrjNameStr$^void := ToStdLib.Malloc(size := PrjNameMemLen + 1);
          else
            if PrjNameMemLen <> (ud_ListLength$USINT - 12) then
              PrjNameMemLen := ud_ListLength$USINT - 12;
              pPrjNameStr$^void := ToStdLib.ReAlloc(mptr:=pPrjNameStr, newsize:=PrjNameMemLen + 1);
            end_if;
          end_if;

          // check if we got a memory
          if pPrjNameStr then

            _memset(dest:=pPrjNameStr, usByte:=0, cntr:=PrjNameMemLen+1);
           
            ud_ActStrLen := ud_TmpStrLen := PrjNameMemLen;
            ud_TmpAddress := ud_Address;        
            
            IF p_BlockedTransferMemory = NIL THEN
              sd_retval := -100;
              SetSafetyState(NewState:=_MemAllocFailed);
              RETURN;
            END_IF;
            
            IF ud_BlockedTransferMemorySize < (ud_TmpStrLen + 1) THEN
              p_BlockedTransferMemory := ToStdLib.ReAlloc(mptr:=p_BlockedTransferMemory, newsize:=(ud_TmpStrLen + 1));
              IF p_BlockedTransferMemory = NIL THEN
                ud_BlockedTransferMemorySize := 0;
                sd_retval := -100;
                SetSafetyState(NewState:=_MemAllocFailed);
                RETURN;
              ELSE
                ud_BlockedTransferMemorySize := (ud_TmpStrLen + 1);
              END_IF;
            END_IF;

            ToStdLib.MemSet(dest:=p_BlockedTransferMemory, value:=0, size:=ud_BlockedTransferMemorySize);

            p_TmpBlockedData := p_BlockedTransferMemory;
                    
            us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
            
            while us_BlockedTransferLength do
            
              // get name
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_TmpAddress
                                          , us_Length           := us_BlockedTransferLength
                                          , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                          );
              //no response
              if ( sd_retval <> 0 ) then
                LogError("Revision Read Error: Reading Revision failed");
                return;
              end_if;

              ToStdLib.MemCpy(dest:=p_TmpBlockedData, 
                               source:=#p_SDOResponseBuffer^.ud_Data, 
                               size:=us_BlockedTransferLength);
              
              p_TmpBlockedData += us_BlockedTransferLength;
              ud_TmpAddress += us_BlockedTransferLength;
              ud_TmpStrLen -= us_BlockedTransferLength;
              
              us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
            
            end_while;
            
            ToStdLib.MemCpy(dest:=pPrjNameStr, 
                             source:=p_BlockedTransferMemory, 
                             size:=PrjNameMemLen+1);

            b_GotNewRevision := TRUE;

            // string is formed by: project name {TAB} project revision   => search for the tab
            pPrjRevStr := pPrjNameStr; // initialize pointer, because maybe there is no content in the projectname
            pChar := pPrjNameStr;
            while pChar^ do
              // check for tab sign
              if pChar^ = 9 then
                // at the next character our revision starts
                pPrjRevStr := pChar + sizeof(CHAR);
                
                // we change the tab to a string termination
                pChar^ := 0;
                
                // save the length of the name and the length of the project revision
                PrjNameStrLen := pChar$UDINT - pPrjNameStr$UDINT;
                PrjRevStrLen := PrjNameMemLen - PrjNameStrLen - sizeof(CHAR);
                exit;
              end_if;
              
              pChar += sizeof(CHAR);
            end_while;
            
            ShowProjectRevision();
          end_if;
        end_if;
        

//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_INTERFACE, 
      SB_BLKTYPE_CFG_INTERFACE_OPTIONAL: // interface frame

        //address of LengthOverall + 3 * 4 bytes (LengthOverall, BlockType, Module ID) => points to interface CRC
        ud_Address := ud_ListLength_Address + 12;
   

//*****************************************************************************
//**   INTERFACE CRC                                                         **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading interface CRC of interface frame block failed");
          return;
        end_if;

        TempPdoConfig.InterfaceCRC := p_SDOResponseBuffer^.ud_Data;

        // skip interface crc
        ud_Address += 4;
        
        
//*****************************************************************************
//**   LENGTH OF TOPOLOGY PATH OF INTERFACE FRAME                            **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading length of topology path of interface frame block failed");
          return;
        end_if;


        // skip path length
        ud_Address += 4;
        
        us_BlockedTransferLength := p_SDOResponseBuffer^.ud_Data$USINT;


//*****************************************************************************
//**   TOPOLOGY PATH OF INTERFACE FRAME                                      **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := us_BlockedTransferLength
                                    , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading topology path of interface frame block failed");
          return;
        end_if;


        // remember the destination path
        _memcpy(ptr1:=#TempPath[0], ptr2:=#p_SDOResponseBuffer^.ud_Data, cntr:=us_BlockedTransferLength);


        // skip path
        ud_Address += us_BlockedTransferLength;
        

//*****************************************************************************
//**   LENGTH OF COMPRESSED TOPOLOGY PATH OF INTERFACE FRAME                 **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading length of compressed topology path of interface frame block failed");
          return;
        end_if;


        // skip path length
        ud_Address += 4;
        
        us_BlockedTransferLength := p_SDOResponseBuffer^.ud_Data$USINT;
        

//*****************************************************************************
//**   COMPRESSED TOPOLOGY PATH OF INTERFACE FRAME                           **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := us_BlockedTransferLength
                                    , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading compressed topology path of interface frame block failed");
          return;
        end_if;

        // skip path and maximum cycle time
        ud_Address += us_BlockedTransferLength + 4;


  // here starts the data area (before we read only the list header

//*****************************************************************************
//**   INTERFACE CRC                                                         **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading CRC of interface frame block failed");
          return;
        end_if;

        TempPdoConfig.InterfaceCRC := p_SDOResponseBuffer^.ud_Data;
        
        // skip interface CRC
        ud_Address += 4;


//*****************************************************************************
//**   NUMBER OF BOOL INTERFACE VARIABLES IN THE PDO                         **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading number of bool variables in the interface frame failed");
          return;
        end_if;

        BoolOuts := p_SDOResponseBuffer^.ud_Data;

        // skip bool variables
        ud_Address += 4;

//*****************************************************************************
//**   NUMBER OF DINT INTERFACE VARIABLES IN THE PDO                         **
//*****************************************************************************

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Interface Config Read Error: Reading number of dint variables in the interface frame failed");
          return;
        end_if;

        // skip dint variables
        ud_Address += 4;

        DintOuts := p_SDOResponseBuffer^.ud_Data;

        // if there are interface variables
        if BoolOuts | DintOuts then
          // calculate the length of the interface frame
          TempPdoConfig.PdoLen := CalcPDOLength(BoolOuts, DintOuts);

          // this is the source of the interface frame
          TempPdoConfig.SourcePathLen := TempPath[0]$UINT + 2; 
          TempPdoConfig.pSourcePath   := #TempPath[0];

          // and the destination
          TempPdoConfig.DestPathLen   := PathOfThisCPU[0]$UINT + 2;
          TempPdoConfig.pDestPath     := #PathOfThisCPU[0];

          TempPdoConfig.Info := 0;
          TempPdoConfig.Info.IsInterfacePDO := TRUE;
          TempPdoConfig.Info.IsOptional := (ud_ActBlockType = SB_BLKTYPE_CFG_INTERFACE_OPTIONAL);

          // add the interface PDO to the list
          AddPdoToCfg(TempPdoConfig);
        else
          LogError("Interface Config Read Error: No interface variables found in interface blocktype");
          return;
        end_if;

//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_MODULE, 
      SB_BLKTYPE_CFG_MODULE_V2, 
      SB_BLKTYPE_CFG_MODULE_OPTIONAL, 
      SB_BLKTYPE_CFG_CONTAINER_SLAVE, 
      SB_BLKTYPE_CFG_CONTAINER_SLAVE_OPTIONAL,
      SB_BLKTYPE_CFG_MODULE_V3,
      SB_BLKTYPE_CFG_MODULE_V3_OPTIONAL,
      SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE,
      SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE_OPTIONAL:      // module configurations  
        TempModuleConfig.Info := 0;
        TempModuleConfig.DestCRCNo := 0;
        TempModuleConfig.pDestCRCs := NIL;
        case ud_ActBlockType of 
          SB_BLKTYPE_CFG_MODULE_OPTIONAL,
          SB_BLKTYPE_CFG_CONTAINER_SLAVE_OPTIONAL,
          SB_BLKTYPE_CFG_MODULE_V3_OPTIONAL,
          SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE_OPTIONAL:
            TempModuleConfig.Info.IsOptional := TRUE;
          else
            TempModuleConfig.Info.IsOptional := FALSE;
        end_case;
       
        b_CfgTypeV2 := (ud_ActBlockType <> SB_BLKTYPE_CFG_MODULE);

        // check if it's a V3 config, because the structure of the IO List is different
        if (ud_ActBlockType = SB_BLKTYPE_CFG_MODULE_V3) | 
           (ud_ActBlockType = SB_BLKTYPE_CFG_MODULE_V3_OPTIONAL) |
           (ud_ActBlockType = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE) |
           (ud_ActBlockType = SB_BLKTYPE_CFG_CONTAINER_V3_SLAVE_OPTIONAL) then
          b_CfgTypeV3 := TRUE;
        else
          b_CfgTypeV3 := FALSE;
        end_if;

        // if it's our own path, remember the type of module configuration
        if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then
          // if config is already "old" dont change to "new". (can be set by block SB_BLKTYPE_OLD_MODE_FLAG)
          if NewConfigType <> ConfigState_Old then
            NewConfigType := (b_CfgTypeV2$USINT + 1)$t_ConfigStateType;
          end_if;
        end_if;

        BoolOuts := 0;
        DintOuts := 0;

        // Remember the path (uncompressed and compressed)
        TempModuleConfig.PathLen := pListHeader^.p_us_Path^$UINT + 2;
        TempModuleConfig.pPath := pListHeader^.p_us_Path;

        TempModuleConfig.CompPathLen := pListHeader^.ui_PathCompLen;
        TempModuleConfig.pCompPath := pListHeader^.p_us_PathComp;


//*****************************************************************************
//**   LIST HEADER                                                           **
//*****************************************************************************


        //address of LengthOverall + 3 * 4 bytes (LengthOverall, BlockType, ModuleID)
        ud_Address := ud_ListLength_Address + 12;

        // only available at new modules
        if b_CfgTypeV2 then          

//*****************************************************************************
//**   INTERFACE CRC                                                         **
//*****************************************************************************

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading interface CRC of interface frame block failed");
            return;
          end_if;

          TempPdoConfig.InterfaceCRC := p_SDOResponseBuffer^.ud_Data;

          // skip interface crc
          ud_Address += 4;
          
          
//*****************************************************************************
//**   LENGTH OF TOPOLOGY PATH OF INTERFACE FRAME                            **
//*****************************************************************************

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading length of topology path of interface frame block failed");
            return;
          end_if;


          // skip path length
          ud_Address += 4;
          
          us_BlockedTransferLength := p_SDOResponseBuffer^.ud_Data$USINT;


//*****************************************************************************
//**   TOPOLOGY PATH OF INTERFACE FRAME                                      **
//*****************************************************************************

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := us_BlockedTransferLength
                                      , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading topology path of interface frame block failed");
            return;
          end_if;

          // remember the destination path
          _memcpy(ptr1:=#TempPath[0], ptr2:=#p_SDOResponseBuffer^.ud_Data, cntr:=us_BlockedTransferLength);
          

          // skip path
          ud_Address += us_BlockedTransferLength;
          

//*****************************************************************************
//**   LENGTH OF COMPRESSED TOPOLOGY PATH OF INTERFACE FRAME                 **
//*****************************************************************************

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading length of compressed topology path of interface frame block failed");
            return;
          end_if;


          // skip path length
          ud_Address += 4;
          
          us_BlockedTransferLength := p_SDOResponseBuffer^.ud_Data$USINT;
          

//*****************************************************************************
//**   COMPRESSED TOPOLOGY PATH OF INTERFACE FRAME                           **
//*****************************************************************************

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := us_BlockedTransferLength
                                      , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading compressed topology path of interface frame block failed");
            return;
          end_if;

          ud_Address += us_BlockedTransferLength;

          // skip max. cycle time
          ud_Address += 4;        
        end_if;

        // on first 4 bytes is fix the system time
        ud_ActAddress := 4; 

        // address in memory for unsafe BDINT variables
        ud_UnsafeBDINT_Offset := 0;

//*****************************************************************************
//**   INTERPRETER CODE                                                      **
//*****************************************************************************

        //read til end-command is reached
        while ( 1 ) do
          
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading next command failed");
            return;
          end_if;
          
          //end-command found
          if ( p_SDOResponseBuffer^.ud_Data = SB_SDO_CONFIG_END_CMD ) then
            exit;
          end_if;
          
          //read next opcode
          //length of one command = 4 x 4 bytes
          ud_Address += 16;
          
          //if there is no end-command found, the returncode of response will be <> OK, when the end of config data is missed
          //In this case the loop ends with returncode <> 0.
        end_while;

        //list of I/Os starts at last address + 16 (length of end command = 4x4 bytes)
        ud_Address += 16;


//*****************************************************************************
//**   LOCAL BOOL INPUTS                                                     **
//*****************************************************************************

        //read number of local bool inputs
        
        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of local inputs failed");
          return;
        end_if;

        // remember the number
        BoolOuts += p_SDOResponseBuffer^.ud_Data;
      
        // get offset in application memory
        ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 4;

        //++pr
        ud_skipLength := 4; // Anzahl Einträge
        // only available at new modules
        if b_CfgTypeV2 then          
          ud_skipLength += 12 * p_SDOResponseBuffer^.ud_Data; // QSE, Filtertime, Modulkennung(SDIAS)
        else
          ud_skipLength += 8 * p_SDOResponseBuffer^.ud_Data; // QSE, Filtertime
        end_if;

//*****************************************************************************
//**   LOCAL BOOL OUTPUTS AS INPUTS                                          **
//*****************************************************************************

        // get number of safe outputs as inputs

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := p_SDORequestBuffer^.ud_Address + ud_skipLength // ++pr
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of safe outputs as inputs failed");
          return;
        end_if;

        // remember the number
        BoolOuts += p_SDOResponseBuffer^.ud_Data;

        // get offset in application memory
        ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 4;


//*****************************************************************************
//**   SAFE BOOL OUTPUT VARIABLES                                            **
//*****************************************************************************

        // get number of safe bool output vars

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := p_SDORequestBuffer^.ud_Address + 4
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of safe bool output vars failed");
          return;
        end_if;

        // remember the number
        BoolOuts += p_SDOResponseBuffer^.ud_Data;

        // get offset in application memory
        ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 4;


        // the new container has some additional content here
        if b_CfgTypeV3 then

//*****************************************************************************
//**   LOCAL DINT INPUTS                                                     **
//*****************************************************************************

          //read number of local dint inputs
          
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := p_SDORequestBuffer^.ud_Address + 4
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of local DINT inputs failed");
            return;
          end_if;

          // remember the number
          DintOuts += p_SDOResponseBuffer^.ud_Data;
        
          // get offset in application memory
          ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 8;


//*****************************************************************************
//**   LOCAL DINT OUTPUTS AS INPUTS                                          **
//*****************************************************************************

          // get number of safe dint outputs as inputs

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := p_SDORequestBuffer^.ud_Address + 4 + 12 * p_SDOResponseBuffer^.ud_Data
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe DINT outputs as inputs failed");
            return;
          end_if;

          // remember the number
          DintOuts += p_SDOResponseBuffer^.ud_Data;

          // get offset in application memory
          ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 8;


        end_if;

//*****************************************************************************
//**   SAFE DINT OUTPUT VARIABLES                                            **
//*****************************************************************************

        // get number of safe dint output vars

        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := p_SDORequestBuffer^.ud_Address + 4
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of safe dint output vars failed");
          return;
        end_if;

        // only when there is a manager
        if pSafetyManagerThis then
          // remember the number
          DintOuts += p_SDOResponseBuffer^.ud_Data;

          // now we're ready to determine the PDO size of this module
          TempModuleConfig.PdoOutLen := CalcPDOLength(BoolOuts, DintOuts);
          
          // if it's our own path, remember the PDO length
//          if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then       
//            MyPDOReadSize := TempModuleConfig.PdoOutLen;
//          end_if;
        end_if;

        // get offset in application memory
        ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 8;


        // special unsafe variables (not supported by old modules)
        if b_CfgTypeV2 then          

//*****************************************************************************
//**   FAST UNSAFE OUTPUT VARIABLES                                          **
//*****************************************************************************
            
          // get number of fast unsafe output vars (should be 8 or 0)

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := p_SDORequestBuffer^.ud_Address + 4
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of fast unsafe output vars failed");
            return;
          end_if;

          // get offset in application memory
          ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 4;
          // if it's our own path, remember the fast unsafe settings
          if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then       
            if (p_SDOResponseBuffer^.ud_Data <> 0) then
              if ActivateFastUnsafeIOs then
                b_FastUnsafeOutputsActive := TRUE;
              else
                // error => can't go on like this
                LogError("(SafetyBase::ReadSDOConfig) Number or size of module accesses increased with new safety project!");
                LogError("(SafetyBase::ReadSDOConfig) => Can't continue, because the new data is not covered by the actual accesses! Restart Application!");
                
                b_NeedApplicationRestart := TRUE;
              end_if;
            end_if;
          end_if;
        end_if;
        
//*****************************************************************************
//**   UNSAFE BOOL OUTPUT VARIABLES                                          **
//*****************************************************************************

        //read number of unsafe output vars
           
        //send request and receive data
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := p_SDORequestBuffer^.ud_Address + 4
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of unsafe bool output vars failed");
          return;
        end_if;

        ud_CntUnsafeOutputs := p_SDOResponseBuffer^.ud_Data;
        
        ud_Address := p_SDORequestBuffer^.ud_Address + 4;

        // skip the names of unsafe outputs
        for i := 1 to ud_CntUnsafeOutputs do
        
          // get length of Name
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading length of unsafe bool output name failed");
            return;
          end_if;

          // prepare address to get name
          ud_Address += 4;
          
//          ud_ActStrLen := ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
          ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
          ud_ActStrLen := ud_TmpStrLen;
          ud_TmpAddress := ud_Address;        
          
          IF p_BlockedTransferMemory = NIL THEN
            sd_retval := -100;
            SetSafetyState(NewState:=_MemAllocFailed);
            RETURN;
          END_IF;
          
          IF ud_BlockedTransferMemorySize < (ud_TmpStrLen + 1) THEN
            p_BlockedTransferMemory := ToStdLib.ReAlloc(mptr:=p_BlockedTransferMemory, newsize:=(ud_TmpStrLen + 1));
            IF p_BlockedTransferMemory = NIL THEN
              ud_BlockedTransferMemorySize := 0;
              sd_retval := -100;
              SetSafetyState(NewState:=_MemAllocFailed);
              RETURN;
            ELSE
              ud_BlockedTransferMemorySize := (ud_TmpStrLen + 1);
            END_IF;
          END_IF;

          ToStdLib.MemSet(dest:=p_BlockedTransferMemory, value:=0, size:=ud_BlockedTransferMemorySize);

          p_TmpBlockedData := p_BlockedTransferMemory;
                  
          us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
          
          while us_BlockedTransferLength do
            
            // get name
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_TmpAddress
                                        , us_Length           := us_BlockedTransferLength
                                        , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                        );
            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading unsafe bool output name failed");
              return;
            end_if;

            ToStdLib.MemCpy(dest:=p_TmpBlockedData, 
                             source:=#p_SDOResponseBuffer^.ud_Data, 
                             size:=us_BlockedTransferLength);
            
            p_TmpBlockedData += us_BlockedTransferLength;
            ud_TmpAddress += us_BlockedTransferLength;
            ud_TmpStrLen -= us_BlockedTransferLength;
            
            us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
          
          end_while;
          
          sd_retval := AddUnsafeRoutElement(pRoutTable:=#p_UnsafeOutputsTable, 
                                            pRoutElementsNo:=#ui_CntUnsafeOutputs, 
                                            ud_Address:=ud_ActAddress,
                                            ui_NameLen:=ud_ActStrLen$UINT, 
                                            pNameNewElement:=p_BlockedTransferMemory$^CHAR);

          // if unsafe component not found (sd_retval <> 0), it's not problem for whole safe application

          // get offset in application memory
          ud_ActAddress += 4;

          // prepare address for next unsafe output or for number of safe inputs
          ud_Address += ud_ActStrLen;

        end_for;


        // special unsafe variables (not supported by old modules)
        if b_CfgTypeV2 then          

//*****************************************************************************
//**   UNSAFE BDINT OUTPUT VARIABLES                                         **
//*****************************************************************************

          //read number of unsafe BDINT output vars
             
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of unsafe BDINT output vars failed");
            return;
          end_if;

          ud_CntUnsafeOutputs := p_SDOResponseBuffer^.ud_Data;
          
          ud_Address := p_SDORequestBuffer^.ud_Address + 4;
          
          if ud_CntUnsafeOutputs then
            
            //SDO request for this command has 5 bytes additional data
            pBitMasks$^void := ToStdLib.Malloc(size := ud_CntUnsafeOutputs * sizeof(BDINT));
            
            if ( pBitMasks = NIL ) then
              sd_retval                         := -100;
              SetSafetyState(NewState:=_MemAllocFailed);
              LogError("Config Read Error: Failed to allocate memory for the BDINT variable bitmasks");
              return;
            end_if;
            

            // get the bitmasks for the BDINT variables
            for i := 1 to ud_CntUnsafeOutputs do
            
              // get bitmask
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );
              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading bit mask of unsafe BDINT output failed");
                return;
              end_if;

              // prepare address for the next one
              ud_Address += 4;
              
              // save the bitmask for adding the rout element
              (pBitMasks + (i-1) * sizeof(BDINT))^ := p_SDOResponseBuffer^.ud_Data;
            end_for;
            
            // skip the names of unsafe outputs
            for i := 1 to ud_CntUnsafeOutputs do
            
              // get length of Name
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );
              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of unsafe BDINT output name failed");
                return;
              end_if;

              // prepare address to get name
              ud_Address += 4;
              
//              ud_ActStrLen := ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
              ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
              ud_ActStrLen := ud_TmpStrLen;
              ud_TmpAddress := ud_Address;        
              
              IF p_BlockedTransferMemory = NIL THEN
                sd_retval := -100;
                SetSafetyState(NewState:=_MemAllocFailed);
                RETURN;
              END_IF;
              
              IF ud_BlockedTransferMemorySize < (ud_TmpStrLen + 1) THEN
                p_BlockedTransferMemory := ToStdLib.ReAlloc(mptr:=p_BlockedTransferMemory, newsize:=(ud_TmpStrLen + 1));
                IF p_BlockedTransferMemory = NIL THEN
                  ud_BlockedTransferMemorySize := 0;
                  sd_retval := -100;
                  SetSafetyState(NewState:=_MemAllocFailed);
                  RETURN;
                ELSE
                  ud_BlockedTransferMemorySize := (ud_TmpStrLen + 1);
                END_IF;
              END_IF;

              ToStdLib.MemSet(dest:=p_BlockedTransferMemory, value:=0, size:=ud_BlockedTransferMemorySize);

              p_TmpBlockedData := p_BlockedTransferMemory;
                      
              us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
              
              while us_BlockedTransferLength do
                
                // get name
                sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                            , p_SDOResponseBuffer := p_SDOResponseBuffer
                                            , ud_Address          := ud_TmpAddress
                                            , us_Length           := us_BlockedTransferLength
                                            , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                            );
                //no response
                if ( sd_retval <> 0 ) then
                  LogError("Config Read Error: Reading unsafe BDINT output name failed");
                  return;
                end_if;

                ToStdLib.MemCpy(dest:=p_TmpBlockedData, 
                                 source:=#p_SDOResponseBuffer^.ud_Data, 
                                 size:=us_BlockedTransferLength);
                
                p_TmpBlockedData += us_BlockedTransferLength;
                ud_TmpAddress += us_BlockedTransferLength;
                ud_TmpStrLen -= us_BlockedTransferLength;
                
                us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
              
              end_while;
              
              ActBitMask := (pBitMasks + (i-1) * sizeof(BDINT))^;
              
              sd_retval := AddUnsafeRoutElement(pRoutTable:=#p_UnsafeOutputsTable, 
                                                pRoutElementsNo:=#ui_CntUnsafeOutputs, 
                                                ud_Address:=ud_UnsafeBDINT_Offset,
                                                ui_NameLen:=ud_ActStrLen$UINT, 
                                                pNameNewElement:=p_BlockedTransferMemory$^CHAR,
                                                ActBitMask);

              // if unsafe component not found (sd_retval <> 0), it's not problem for whole safe application
              
              // get offset in application memory
              ud_ActAddress += CountBits(ActBitMask) * sizeof(DINT);
              ud_UnsafeBDINT_Offset += sizeof(DINT);


              // prepare address for next unsafe output or for number of safe inputs
              ud_Address += ud_ActStrLen;

            end_for;
            
            // free the bitmasks
            ToStdLib.Free(mptr:=pBitMasks);
          end_if;
        end_if;

//*****************************************************************************
//**   SAFE INPUT VARIABLES                                                  **
//*****************************************************************************

        // get number of safe inputs
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Reading number of safe inputs failed");
          return;
        end_if;

        //number of safe inputs
        ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

        // get offset in application memory
        ud_ActAddress += ud_TmpCnt * 4;

        //address of path length of first safe input
        ud_Address := p_SDORequestBuffer^.ud_Address + 4;
        
        //read path of all safe inputs and add them to routing lists
        for i := 1 to ud_TmpCnt do
          
          //read path
          sd_retval := ReadModulePath ( p_SDORequestBuffer          := p_SDORequestBuffer
                                      , p_SDOResponseBuffer         := p_SDOResponseBuffer
                                      , p_ud_Address                := #ud_Address
                                      , pModule                     := pModule
                                      , p_ud_ModulePathLen_Max      := #ud_ModulePathLen_Max
                                      , p_ud_ModulePathCompLen_Max  := #ud_ModulePathCompLen_Max
                                      , us_SDOMaxDataSize           := us_DataLength_Max
                                      );
          
          //no response, error
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading path of safe input failed");
            return;
          end_if;
          
          // if there is a valid module path
          if pModule^.p_us_Path <> NIL then
            //add module to routing tabs
            sd_retval := AddModuleToRoutingTabs ( pModule       := pModule
                                                , pListHeader   := pListHeader
                                                , b_IsOptional  := TempModuleConfig.Info.IsOptional
                                                );
            
            if (sd_retval <> 0 ) then
              if ( SafetyState <> _ModFromCfgNotFound ) then
                LogError("Config Read Error: Failed to add safe input module to routing tabs");
                return;
              end_if;
            end_if;
          end_if;
          
          //address of path length = last address + 2 * 4 bytes ( RemoteIndex + MaxAge)
          ud_Address += 8;
        
        end_for;

        if b_CfgTypeV3 then

//*****************************************************************************
//**   SAFE DINT INPUT VARIABLES                                             **
//*****************************************************************************

          // get number of safe DINT inputs
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe DINT inputs failed");
            return;
          end_if;

          //number of safe inputs
          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // get offset in application memory
          ud_ActAddress += ud_TmpCnt * 8;

          //address of path length of first safe input
          ud_Address := p_SDORequestBuffer^.ud_Address + 4;
          
          //read path of all safe inputs and add them to routing lists
          for i := 1 to ud_TmpCnt do
            
            //read path
            sd_retval := ReadModulePath ( p_SDORequestBuffer          := p_SDORequestBuffer
                                        , p_SDOResponseBuffer         := p_SDOResponseBuffer
                                        , p_ud_Address                := #ud_Address
                                        , pModule                     := pModule
                                        , p_ud_ModulePathLen_Max      := #ud_ModulePathLen_Max
                                        , p_ud_ModulePathCompLen_Max  := #ud_ModulePathCompLen_Max
                                        , us_SDOMaxDataSize           := us_DataLength_Max
                                        );
            
            //no response, error
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading path of safe DINT input failed");
              return;
            end_if;
            
            // if there is a valid module path
            if pModule^.p_us_Path <> NIL then
              //add module to routing tabs
              sd_retval := AddModuleToRoutingTabs ( pModule       := pModule
                                                  , pListHeader   := pListHeader
                                                  , b_IsOptional  := TempModuleConfig.Info.IsOptional
                                                  );
              
              if (sd_retval <> 0 ) then
                if ( SafetyState <> _ModFromCfgNotFound ) then
                  LogError("Config Read Error: Failed to add safe DINT input module to routing tabs");
                  return;
                end_if;
              end_if;
            end_if;
            
            //address of path length = last address + 2 * 4 bytes ( RemoteIndex + MaxAge)
            ud_Address += 8;
          
          end_for;
        end_if;


        // only available at new modules
        if b_CfgTypeV2 then          

//*****************************************************************************
//**   SAFE INTERFACE INPUT VARIABLES                                        **
//*****************************************************************************

          // get number of safe interface input vars
          
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe interface input variables failed");
            return;
          end_if;

          // skip the number
          ud_Address += 4;

          //number of safe inputs
          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // get offset in application memory
          ud_ActAddress += ud_TmpCnt * 4;

          if ud_TmpCnt then
            
            for i := 0 to (ud_TmpCnt-1) do
              // get length of the uncompressed path
              
              //send request and receive data
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );

              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of uncompressed interface topology path failed");
                return;
              end_if;

              // skip length of top path
              ud_Address += 4;

              // skip top path
              ud_Address += p_SDOResponseBuffer^.ud_Data;

              // read length of compressed topology path

              //send request and receive data
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );

              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of compressed interface topology path failed");
                return;
              end_if;

              // skip length of compressed top path
              ud_Address += 4;

              // skip compressed top path and remote index and maximum age
              ud_Address += p_SDOResponseBuffer^.ud_Data + 4 + 4;            
            end_for;
          end_if;

(*
 4 Byte Anzahl
 4 Byte Länge vom Pfad, Pfad (vorne Pfad ":" dann CRC für da Interface dann bis auf 4 Byte aufgefüllt)
 4 Byte Länge vom komprimierten Pfad, komprimierter Pfad (vorne Pfad ":" dann CRC für da Interface dann bis auf 4 Byte aufgefüllt)
 4 Byte RemoteIndex
 4 Byte Maximales Alter
*)

        end_if;
        


        // only available at new containers
        if b_CfgTypeV3 then          

//*****************************************************************************
//**   SAFE DINT INTERFACE INPUT VARIABLES                                   **
//*****************************************************************************

          // get number of safe DINT interface input vars
          
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe DINT interface input variables failed");
            return;
          end_if;

          // skip the number
          ud_Address += 4;

          //number of safe inputs
          ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

          // get offset in application memory
          ud_ActAddress += ud_TmpCnt * 8;

          if ud_TmpCnt then
            
            for i := 0 to (ud_TmpCnt-1) do
              // get length of the uncompressed path
              
              //send request and receive data
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );

              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of uncompressed interface topology path failed at safe DINT input variables");
                return;
              end_if;

              // skip length of top path
              ud_Address += 4;

              // skip top path
              ud_Address += p_SDOResponseBuffer^.ud_Data;

              // read length of compressed topology path

              //send request and receive data
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );

              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of compressed interface topology path failed at safe DINT input variables");
                return;
              end_if;

              // skip length of compressed top path
              ud_Address += 4;

              // skip compressed top path and remote index and maximum age
              ud_Address += p_SDOResponseBuffer^.ud_Data + 4 + 4;            
            end_for;
          end_if;

(*
 4 Byte Anzahl
 4 Byte Länge vom Pfad, Pfad (vorne Pfad ":" dann CRC für da Interface dann bis auf 4 Byte aufgefüllt)
 4 Byte Länge vom komprimierten Pfad, komprimierter Pfad (vorne Pfad ":" dann CRC für da Interface dann bis auf 4 Byte aufgefüllt)
 4 Byte RemoteIndex
 4 Byte Maximales Alter
*)

        end_if;
        
        
//*****************************************************************************
//**   FAST UNSAFE INPUT VARIABLES                                           **
//*****************************************************************************

        // only available at new modules
        if b_CfgTypeV2 then          
            
          // get number of fast unsafe intput vars (should be 8 or 0)

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of fast unsafe intput vars failed");
            return;
          end_if;

          ud_Address += 4;

          // get offset in application memory
          ud_ActAddress += p_SDOResponseBuffer^.ud_Data * 4;
          // if it's our own path, remember the fast unsafe settings
          if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then       
            if (p_SDOResponseBuffer^.ud_Data <> 0) then
              if ActivateFastUnsafeIOs then
                b_FastUnsafeInputsActive := TRUE;
              else
                // error => can't go on like this
                LogError("(SafetyBase::ReadSDOConfig) Number or size of module accesses increased with new safety project!");
                LogError("(SafetyBase::ReadSDOConfig) => Can't continue, because the new data is not covered by the actual accesses! Restart Application!");

                b_NeedApplicationRestart := TRUE;
              end_if;
            end_if;
          end_if;
        end_if;

//*****************************************************************************
//**   UNSAFE BOOL INPUT VARIABLES                                           **
//*****************************************************************************

        // here we go for unsafe bool input vars
        
        // get number of unsafe input vars
        sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                    , p_SDOResponseBuffer := p_SDOResponseBuffer
                                    , ud_Address          := ud_Address
                                    , us_Length           := 4
                                    );

        //no response
        if ( sd_retval <> 0 ) then
          LogError("Config Read Error: Failed to read number of unsafe input vars");
          return;
        end_if;


        ud_CntUnsafeInputs := p_SDOResponseBuffer^.ud_Data;
        
        ud_Address := p_SDORequestBuffer^.ud_Address + 4;

        // skip the names of unsafe inputs
        for i := 1 to ud_CntUnsafeInputs do
        
          // get length of Name
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );
          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading length of unsafe input name failed");
            return;
          end_if;

          // prepare address to get name
          ud_Address += 4;
          
//          ud_ActStrLen := ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
          ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
          ud_ActStrLen := ud_TmpStrLen;
          ud_TmpAddress := ud_Address;        
          
          IF p_BlockedTransferMemory = NIL THEN
            sd_retval := -100;
            SetSafetyState(NewState:=_MemAllocFailed);
            RETURN;
          END_IF;
          
          IF ud_BlockedTransferMemorySize < (ud_TmpStrLen + 1) THEN
            p_BlockedTransferMemory := ToStdLib.ReAlloc(mptr:=p_BlockedTransferMemory, newsize:=(ud_TmpStrLen + 1));
            IF p_BlockedTransferMemory = NIL THEN
              ud_BlockedTransferMemorySize := 0;
              sd_retval := -100;
              SetSafetyState(NewState:=_MemAllocFailed);
              RETURN;
            ELSE
              ud_BlockedTransferMemorySize := (ud_TmpStrLen + 1);
            END_IF;
          END_IF;

          ToStdLib.MemSet(dest:=p_BlockedTransferMemory, value:=0, size:=ud_BlockedTransferMemorySize);

          p_TmpBlockedData := p_BlockedTransferMemory;
                  
          us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
          
          while us_BlockedTransferLength do
          
            // get name
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_TmpAddress
                                        , us_Length           := us_BlockedTransferLength
                                        , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                        );
            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading unsafe input name failed");
              return;
            end_if;

            ToStdLib.MemCpy(dest:=p_TmpBlockedData, 
                             source:=#p_SDOResponseBuffer^.ud_Data, 
                             size:=us_BlockedTransferLength);
            
            p_TmpBlockedData += us_BlockedTransferLength;
            ud_TmpAddress += us_BlockedTransferLength;
            ud_TmpStrLen -= us_BlockedTransferLength;
            
            us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
          
          end_while;
          
          sd_retval := AddUnsafeRoutElement(pRoutTable:=#p_UnsafeInputsTable, 
                                            pRoutElementsNo:=#ui_CntUnsafeInputs, 
                                            ud_Address:=ud_ActAddress,
                                            ui_NameLen:=ud_ActStrLen$UINT, 
                                            pNameNewElement:=p_BlockedTransferMemory$^CHAR);

          // if unsafe component not found (sd_retval <> 0), it's not problem for whole safe application

          // get offset in application memory
          ud_ActAddress += 4;

          // prepare address for next unsafe input
          ud_Address += ud_ActStrLen;

        end_for;


        // only available at new modules
        if b_CfgTypeV2 then          

//*****************************************************************************
//**   UNSAFE BDINT INPUT VARIABLES                                          **
//*****************************************************************************

          // here we go for unsafe BDINT input vars
          
          // get number of unsafe input vars
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Failed to read number of unsafe BDINT input vars");
            return;
          end_if;


          ud_CntUnsafeInputs := p_SDOResponseBuffer^.ud_Data;
          
          ud_Address := p_SDORequestBuffer^.ud_Address + 4;

          if ud_CntUnsafeInputs then
            
            //SDO request for this command has 5 bytes additional data
            pBitMasks$^void := ToStdLib.Malloc(size := ud_CntUnsafeInputs * sizeof(BDINT));
            
            if ( pBitMasks = NIL ) then
              sd_retval                         := -100;
              SetSafetyState(NewState:=_MemAllocFailed);
              LogError("Config Read Error: Failed to allocate memory for the BDINT variable bitmasks");
              return;
            end_if;
            

            // get the bitmasks for the BDINT variables
            for i := 1 to ud_CntUnsafeInputs do
            
              // get bitmask
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );
              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading bit mask of unsafe BDINT input failed");
                return;
              end_if;

              // prepare address for the next one
              ud_Address += 4;
              
              // save the bitmask for adding the rout element
              (pBitMasks + (i-1) * sizeof(BDINT))^ := p_SDOResponseBuffer^.ud_Data;
            end_for;
            
            // get the names of unsafe inputs
            for i := 1 to ud_CntUnsafeInputs do
            
              // get length of Name
              sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                          , p_SDOResponseBuffer := p_SDOResponseBuffer
                                          , ud_Address          := ud_Address
                                          , us_Length           := 4
                                          );
              //no response
              if ( sd_retval <> 0 ) then
                LogError("Config Read Error: Reading length of unsafe BDINT input name failed");
                return;
              end_if;

              // prepare address to get name
              ud_Address += 4;
              
//              ud_ActStrLen := ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
              ud_TmpStrLen := p_SDOResponseBuffer^.ud_Data;
              ud_ActStrLen := ud_TmpStrLen;
              ud_TmpAddress := ud_Address;        
              
              IF p_BlockedTransferMemory = NIL THEN
                sd_retval := -100;
                SetSafetyState(NewState:=_MemAllocFailed);
                RETURN;
              END_IF;
              
              IF ud_BlockedTransferMemorySize < (ud_TmpStrLen + 1) THEN
                p_BlockedTransferMemory := ToStdLib.ReAlloc(mptr:=p_BlockedTransferMemory, newsize:=(ud_TmpStrLen + 1));
                IF p_BlockedTransferMemory = NIL THEN
                  ud_BlockedTransferMemorySize := 0;
                  sd_retval := -100;
                  SetSafetyState(NewState:=_MemAllocFailed);
                  RETURN;
                ELSE
                  ud_BlockedTransferMemorySize := (ud_TmpStrLen + 1);
                END_IF;
              END_IF;

              ToStdLib.MemSet(dest:=p_BlockedTransferMemory, value:=0, size:=ud_BlockedTransferMemorySize);

              p_TmpBlockedData := p_BlockedTransferMemory;
                      
              us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
              
              while us_BlockedTransferLength do
                
                // get name
                sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                            , p_SDOResponseBuffer := p_SDOResponseBuffer
                                            , ud_Address          := ud_TmpAddress
                                            , us_Length           := us_BlockedTransferLength
                                            , b_UseCache          := us_BlockedTransferLength < us_DataLength_Max
                                            );
                //no response
                if ( sd_retval <> 0 ) then
                  LogError("Config Read Error: Reading unsafe BDINT input name failed");
                  return;
                end_if;

                ToStdLib.MemCpy(dest:=p_TmpBlockedData, 
                                 source:=#p_SDOResponseBuffer^.ud_Data, 
                                 size:=us_BlockedTransferLength);
                
                p_TmpBlockedData += us_BlockedTransferLength;
                ud_TmpAddress += us_BlockedTransferLength;
                ud_TmpStrLen -= us_BlockedTransferLength;
                
                us_BlockedTransferLength := BlockedTransferLength(ud_Datalength:=ud_TmpStrLen, us_MaxBlocklength:=60);
              
              end_while;
              
              ActBitMask := (pBitMasks + (i-1) * sizeof(BDINT))^;
              
              sd_retval := AddUnsafeRoutElement(pRoutTable:=#p_UnsafeInputsTable, 
                                                pRoutElementsNo:=#ui_CntUnsafeInputs, 
                                                ud_Address:=ud_UnsafeBDINT_Offset,
                                                ui_NameLen:=ud_ActStrLen$UINT, 
                                                pNameNewElement:=p_BlockedTransferMemory$^CHAR,
                                                ActBitMask);

              // if unsafe component not found (sd_retval <> 0), it's not problem for whole safe application

              // get offset in application memory
              ud_ActAddress += CountBits(ActBitMask) * sizeof(DINT);
              ud_UnsafeBDINT_Offset += sizeof(DINT);

              // prepare address for next unsafe output or for number of constants
              ud_Address += ud_ActStrLen;

            end_for;
            
            // free the bitmasks
            ToStdLib.Free(mptr:=pBitMasks);
          end_if;


//*****************************************************************************
//**   CONSTANTS                                                             **
//*****************************************************************************

          // constants

          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of constants failed");
            return;
          end_if;

          // skip number of constants
          ud_Address += 4;

          // skip constants
          ud_Address += p_SDOResponseBuffer^.ud_Data * 4;

          
          if b_CfgTypeV3 then
          
//*****************************************************************************
//**   SAFE DINT CONSTANTS                                                   **
//*****************************************************************************

            // constants

            //send request and receive data
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_Address
                                        , us_Length           := 4
                                        );

            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading number of safe DINT constants failed");
              return;
            end_if;

            // skip number of safe dint constants
            ud_Address += 4;

            // skip constants (4 byte per safe DINT constant)
            ud_Address += p_SDOResponseBuffer^.ud_Data * 4;

          end_if;

//*****************************************************************************
//**   LOCAL OUTPUTS                                                         **
//*****************************************************************************

          // local outputs
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of local outputs failed");
            return;
          end_if;

          // skip number of local outputs
          ud_Address += 4;

          // skip local outputs
          //++pr
          // only available at new modules
          if b_CfgTypeV2 then          
            ud_Address += p_SDOResponseBuffer^.ud_Data * 8; // Used-Flag, Modulkennung(SDIAS)
          else
            ud_Address += p_SDOResponseBuffer^.ud_Data * 4; // Used-Flag
          end_if;
          
          
          if b_CfgTypeV3 then
          
//*****************************************************************************
//**   LOCAL DINT OUTPUTS                                                    **
//*****************************************************************************

            // local outputs
            //send request and receive data
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_Address
                                        , us_Length           := 4
                                        );

            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading number of local outputs failed");
              return;
            end_if;

            // skip number of local outputs
            ud_Address += 4;

            // skip local outputs
            //++pr
            // only available at new modules
            if b_CfgTypeV2 then          
              ud_Address += p_SDOResponseBuffer^.ud_Data * 8; // Used-Flag, Modulkennung(SDIAS)
            else
              ud_Address += p_SDOResponseBuffer^.ud_Data * 4; // Used-Flag
            end_if;
            
          end_if;


//*****************************************************************************
//**   SAFE BOOL INTERFACE OUTPUT VARIABLES                                  **
//*****************************************************************************

          // safe bool interface output vars
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe BOOL interface output variables failed");
            return;
          end_if;

          // skip safe BOOL interface output variables
          ud_Address += 4;

          // count the interface output variables
          BoolOuts := p_SDOResponseBuffer^.ud_Data;


//*****************************************************************************
//**   SAFE DINT INTERFACE OUTPUT VARIABLES                                  **
//*****************************************************************************

          // safe dint interface output vars
          //send request and receive data
          sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                      , p_SDOResponseBuffer := p_SDOResponseBuffer
                                      , ud_Address          := ud_Address
                                      , us_Length           := 4
                                      );

          //no response
          if ( sd_retval <> 0 ) then
            LogError("Config Read Error: Reading number of safe DINT interface output variables failed");
            return;
          end_if;

          // skip number of safe dint interface output vars
          ud_Address += 4;

          // count the interface output variables
          DintOuts := p_SDOResponseBuffer^.ud_Data;


//*****************************************************************************
//**   FSBs = Functional Safety Blocks                                       **
//*****************************************************************************

          ud_skipLength := 0;

          // skip FSBs! structure: CRC, Length.... until the length is 0
          repeat
            
            // skip CRC and length of FSB
            ud_Address += 4 + ud_skipLength;

            //send request and receive data
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_Address
                                        , us_Length           := 4
                                        );

            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading length of FSB failed");
              return;
            end_if;

            ud_skipLength := p_SDOResponseBuffer^.ud_Data;

          until ud_skipLength = 0 end_repeat;
          
          // skip length of block with 0 length
          ud_Address += 4;

          if b_CfgTypeV3 then

//*****************************************************************************
//**   DYNAMIC PARAMETERS (e.g. for SSI Module)                              **
//*****************************************************************************

// Version of Parameters is saved in hd_DynParaVersion
// if it's 16#0001, then we read out the number of parameters which will follow


// structure: 
// number of parameters
// for every parameter: place, id, length (including the 4 byte for the length itself), data

            //send request and receive data
            sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                        , p_SDOResponseBuffer := p_SDOResponseBuffer
                                        , ud_Address          := ud_Address
                                        , us_Length           := 4
                                        );

            //no response
            if ( sd_retval <> 0 ) then
              LogError("Config Read Error: Reading number of dynamic parameters failed");
              return;
            end_if;

            ud_TmpCnt := p_SDOResponseBuffer^.ud_Data;

            // skip number of parameters
            ud_Address += 4;

            if ud_TmpCnt then
              for i := 1 to ud_TmpCnt do
                //send request and receive data
                sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                            , p_SDOResponseBuffer := p_SDOResponseBuffer
                                            , ud_Address          := ud_Address
                                            , us_Length           := sizeof(t_DynamicParameterHeader)
                                            );

                //no response
                if ( sd_retval <> 0 ) then
                  LogError("Config Read Error: Reading header of dynamic parameter failed");
                  return;
                end_if;

                DynamicParameterHeader := p_SDOResponseBuffer^.ud_Data$t_DynamicParameterHeader;
                
                // skip size of header
                ud_Address += sizeof(t_DynamicParameterHeader);

                // data for pdo length info:
                // this data is also mirrored to SB_SDO_ADDRESS_SPECIAL_INFO
                
//                  Marked with Place = 1000
//
//                  (4 Byte Length)
//                   4 Byte Version (starting at 0)
//                   1 Byte Length Rd PDO
//                   1 Byte Length Rd PDO IF
//                   1 Byte Length Wr PDO
//                   1 Byte Number of write PDOs (without additional it would be 1), msb = fast unsafe active
                
                if (DynamicParameterHeader.Place = SB_CONFIG_PDO_INFO_PLACE) & (DynamicParameterHeader.Length >= (sizeof(UDINT) + sizeof(t_PDOSizeInfo))) then
                  //send request and receive data
                  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                                              , ud_Address          := ud_Address
                                              , us_Length           := sizeof(t_PDOSizeInfo)
                                              );

                  //no response
                  if ( sd_retval <> 0 ) then
                    LogError("Config Read Error: Reading dynamic parameter for pdo size failed");
                    return;
                  end_if;
                  
                  PdoSizeInfo := p_SDOResponseBuffer^.ud_Data$t_PDOSizeInfo;
                  
                  // if any sizes increased or we would need more DOs
                  if (PdoSizeInfo.PDORdLen > MyPDOReadSize)     |
                     (PdoSizeInfo.PDOIFRdLen > MyIFPDOReadSize) |
                     (PdoSizeInfo.PDOWrLen > MyPDOWriteSize)    |
                     (((PdoSizeInfo.WrDONrFastUnsafe AND SB_FAST_UNSAFE_MASK) <> 0) > ActivateFastUnsafeIOs)    |
                     (((PdoSizeInfo.WrDONrFastUnsafe AND SB_PDO_WR_MASK) - 1) > AdditionalSPDOs) then
                  
                    // error => can't go on like this
                    LogError("(SafetyBase::ReadSDOConfig) Number or size of module accesses increased with new safety project!");
                    LogError("(SafetyBase::ReadSDOConfig) => Can't continue, because the new data is not covered by the actual accesses! Restart Application!");

                    b_NeedApplicationRestart := TRUE;
                  end_if;

                  exit;
                end_if;
                
                // skip the parameter data (length of the length is also included)
                ud_Address += DynamicParameterHeader.Length - 4;
              end_for;
            end_if;
          end_if;

          // if there are interface variables
          if BoolOuts | DintOuts then
            // calculate the length of the interface frame
            TempPdoConfig.PdoLen := CalcPDOLength(BoolOuts, DintOuts);

            TempPdoConfig.Info := 0;
            TempPdoConfig.Info.IsInterfacePDO := TRUE;
            TempPdoConfig.Info.IsOptional := (ud_ActBlockType = SB_BLKTYPE_CFG_MODULE_OPTIONAL);
            
            // if it's a broadcast => mark it
            if (TempPath[0]$UINT = 2) & (TempPath[0]$HDINT = SB_INTERFACE_FRAME_BROADCAST) then
              TempPdoConfig.Info.IFBroadCast := TRUE;
            end_if;
            
            // this is the source of the interface frame
            TempPdoConfig.SourcePathLen := pListHeader^.p_us_Path^$UINT + 2;
            TempPdoConfig.pSourcePath   := pListHeader^.p_us_Path;

            // and the destination
            TempPdoConfig.DestPathLen   := TempPath[0]$UINT + 2;
            TempPdoConfig.pDestPath     := #TempPath[0];

            // add the interface PDO to the list
            AddPdoToCfg(TempPdoConfig);
            
            TempModuleConfig.Info.IsInterfaceSource := TRUE;
            TempModuleConfig.Info.IsInterfaceDest   := FALSE;
            TempModuleConfig.InterfaceCRC := TempPdoConfig.InterfaceCRC;
          else
            TempModuleConfig.Info.IsInterfaceSource := FALSE;
            TempModuleConfig.Info.IsInterfaceDest   := FALSE;
            TempModuleConfig.InterfaceCRC := 0;
          end_if;
        else
          TempModuleConfig.Info.IsInterfaceSource := FALSE;
          TempModuleConfig.Info.IsInterfaceDest   := FALSE;
          TempModuleConfig.InterfaceCRC := 0;
        end_if;

        // if it's our own path, remember the safety number
        if (PathOfThisCPU[0]$UINT = (pListHeader^.p_us_Path$^UINT)^) & (ToStdLib.MemCmp(#PathOfThisCPU[0], pListHeader^.p_us_Path, PathOfThisCPU[0]$UINT + 2) = 0) then       
          TempModuleConfig.SafetyNbr := SafetyNumber;
        else
          TempModuleConfig.SafetyNbr := 0;
        end_if;

        // only when there is a manager
        if pSafetyManagerThis then
          AddModuleToCfg(TempModuleConfig);
        end_if;

//**********************************************************************************************************************************************************
      SB_BLKTYPE_OLD_MODE_FLAG: // flag fore FW to use old config-mode
        // we need the old TimeSync config-type
        NewConfigType := ConfigState_Old;

//**********************************************************************************************************************************************************
      SB_BLKTYPE_CFG_XML: // configuration for uploading the project to the safetydesigner (network placement information, names of bits,...)
        // no useful information here for us
        
//**********************************************************************************************************************************************************
    else
      // skip it = do nothing
//      TRACE("Found unhandled Blocktype in configuration");
//**********************************************************************************************************************************************************
    end_case;

    ud_ListBaseAddress := ud_ListLength_Address + ud_ListLength;
  end_while;
  
  if ( ( sd_retval = 0 ) & ( SafetyState = _ModFromCfgNotFound ) ) then
    sd_retval := -1;
  end_if;
    
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::SDOReadCfgRequ
	VAR_INPUT
		p_SDORequestBuffer 	: ^SafetyBase::SDORequReadConfig;
		p_SDOResponseBuffer 	: ^SafetyBase::SDORespReadConfig;
		ud_Address 	: UDINT;
		us_Length 	: USINT;
		b_UseCache 	: BOOL;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  // check if we have the data in the cache
  if b_UseCache & IsInCache(ud_Address, us_Length) then
    // use it from the cache

    // the address may be used from outside this function
    p_SDORequestBuffer^.ud_Address := ud_Address;
    
    _memcpy(ptr1:=#p_SDOResponseBuffer^.ud_Data, ptr2:=#Cache[0] + (ud_Address - CachedAddr), cntr:=us_Length);
    
    // everything is fine
    sd_retval := 0;
  else

    //sequence number
    p_SDORequestBuffer^.StdHeader.SeqNr := us_CntSequNr;
    
    //increase counter for sequence number
    if us_CntSequNr < 16#7F then
      us_CntSequNr += 1;
    else
      us_CntSequNr := 0;
    end_if;
    
    //address 
    p_SDORequestBuffer^.ud_Address := ud_Address;
    
    if b_UseCache then
      // get max size
      p_SDORequestBuffer^.us_Length := SB_SDO_MAX_LENGTH - (sizeof(SDORespReadConfig) - sizeof(SDORespReadConfig.ud_Data));
    else
      //length of expected data
      p_SDORequestBuffer^.us_Length := us_Length;   
    end_if;
    
    //calculate CRC (starting with length of data until the end of command)
    p_SDORequestBuffer^.StdHeader.CRC := 0;

    //send request
    sd_retval := SAFETY_iSendRequest( uiMaster    := 0
                                    , pucNode     := p_ObjectPath
                                    , uiInLength  := sizeof(SDORequReadConfig)
                                    , pucInput    := p_SDORequestBuffer$^USINT
                                    , uiOutLength := sizeof(SDORespReadConfig) - sizeof(SDORespReadConfig.ud_Data) + p_SDORequestBuffer^.us_Length
                                    , pucOutput   := p_SDOResponseBuffer$^USINT
                                    );
   
    //no response
    if ( sd_retval <> 0 ) then
      LogError("SDOReadCfgRequ: SAFETY_iSendRequest failed");
      
      // we remember to retry in a few seconds
      b_ReadConfigFailed := TRUE;
      return;
    end_if;

    //check sequence number to exclude a possible wrong response
    if ( p_SDORequestBuffer^.StdHeader.SeqNr <> p_SDOResponseBuffer^.StdHeader.SeqNr ) then
      // we remember to retry in a few seconds
      b_ReadConfigFailed := TRUE;
      //log not routable SDOs
      LogError("SDO Problem (details in next line)");
      LogValue("SDOReadCfgRequ: Invalid Sequence number in SDO Standard Response. Got 0x{0} instead of expected 0x{1}", to_udint(p_SDOResponseBuffer^.StdHeader.SeqNr), to_udint(p_SDORequestBuffer^.StdHeader.SeqNr));
      return;
    end_if;
      
    //check returncode of SDO
    if ( p_SDOResponseBuffer^.us_Returncode <> SB_SDO_RETCODE_OK ) then
      //log not routable SDOs
      LogError("SDO Problem (details in next line)");
      LogValue("SDOReadCfgRequ: Safety module 0x{0}: Retcode of SDO Standard Response was invalid. Retcode: 0x{1}", SafetyNumber$UDINT, to_udint(p_SDOResponseBuffer^.us_Returncode));
      
  //    // when reading fails because safety designer is writing at the same moment
  //    if p_SDOResponseBuffer^.us_Returncode = SDO_MICROCTRL_DIFFER then
        // we remember to retry in a few seconds
        b_ReadConfigFailed := TRUE;
  //    end_if;
      
      return;
    end_if;
      
    //check length of read data
    if ( p_SDOResponseBuffer^.us_Length = 0 ) then
      LogError("SDOReadCfgRequ: Response length is 0");
      sd_retval := -104;
      return;
    elsif b_UseCache then
      // everything is fine => add the new data to the cache
      AddToCache(p_SDORequestBuffer, p_SDOResponseBuffer);
    end_if;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetRoutingData
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
	VAR
    SDORequestBuffer        : SDORequReadConfig;
    SDOResponseBuffer       : ARRAY [0..SB_SDO_MAX_LENGTH-1] OF USINT;
		p_SDORequestBuffer 	    : ^SDORequReadConfig;
		p_SDOResponseBuffer 	  : ^SDORespReadConfig;
    Module                  : PathInfoType;
    ListHeader              : PathInfoType;
    i                       : DINT;
    NotAvailableStr         : ARRAY [0..99] OF CHAR;
    ModulePath              : ARRAY [0..127] OF USINT;
    ModulePathComp          : ARRAY [0..127] OF USINT;
    ListPath                : ARRAY [0..127] OF USINT;
    ListPathComp            : ARRAY [0..127] OF USINT;
    Time1, Time2            : UDINT;
	END_VAR

  // get module specific configuration information
  GetConfiguration();

  InitPathInfo(#Module);
  InitPathInfo(#ListHeader);

  //SDO request for this command has 5 bytes additional to the header
  p_SDORequestBuffer := #SDORequestBuffer;
  
  //SDO response for this command can have maximum additional data
  p_SDOResponseBuffer := (#SDOResponseBuffer)$^SDORespReadConfig;
  
  //path of input-safety-module
  Module.p_us_Path$^void := #ModulePath;
  
  //compressed path of input-safety-module
  Module.p_us_PathComp$^void := #ModulePathComp;
  
  //path in list header
  ListHeader.p_us_Path$^void := #ListPath;
  
  //path in list header
  ListHeader.p_us_PathComp$^void := #ListPathComp;
    
  b_ReadConfigFailed := FALSE;

  b_NeedApplicationRestart := FALSE;
  
  // if there is a revision in the configuration this variable changes to TRUE
  b_GotNewRevision := FALSE;

Time1 := OS_READMICROSEC();
  //read config data via SDOs and add safety modules to routing lists
  sd_retval := ReadSDOConfig( p_SDORequestBuffer      := p_SDORequestBuffer
                            , p_SDOResponseBuffer     := p_SDOResponseBuffer
                            , pModule                 := #Module
                            , pListHeader             := #ListHeader
                            );
Time2 := OS_READMICROSEC();
ud_ConfigReadTime := Time2 - Time1;

  // set error to restart application afterwards to have a complete configuration (needed for routing to share the slave configurations with only 1 restart of the application)
  if b_NeedApplicationRestart then
    SetSafetyState(NewState:=_DOsIncreasedRestartApp);
    sd_retval := -1;
  end_if;

  // if there is no revision in the configuration => clear it
  if (b_GotNewRevision = FALSE) then

    // free memory, if available  
    if pPrjNameStr & pPrjRevStr then
      ToStdLib.Free(pPrjNameStr);
    end_if;

    // use local memory to show "not available"
    _strcpy(dest:=#NotAvailableStr[0], src:="<not available>");
    PrjNameMemLen := _strlen(src:=#NotAvailableStr[0]);
    PrjNameStrLen := PrjRevStrLen := PrjNameMemLen - 1;
    pPrjNameStr := pPrjRevStr := #NotAvailableStr[0];

    // write the strings to the string objects
    ShowProjectRevision();

    // there is no memory, so reset the pointer and length informations
    pPrjNameStr := NIL;
    pPrjRevStr := NIL;

    PrjNameMemLen := 0;
    PrjNameStrLen := 0;
    PrjRevStrLen := 0;
  end_if;
  
  // if reading failed, because designer is writing at the same time => we try again in a few seconds
  if b_ReadConfigFailed then
  
    // next time we check for the configured state of the cpu
    b_CheckConfigured := TRUE;

    // check again in background
    SetSafetyState(NewState:=_ReinitConfig);
    
    // and wait at least 3 secs
    ud_LastCheckConfig := ops.tAbsolute;
  
  // error in configuration -> no work
  elsif ( sd_retval <> 0 ) & (SafetyState <> _ReinitConfig) then  
    if SafetyState = _WaitForSynchronicity then
      SetSafetyState(NewState:=_UnknownCfgError);
    end_if;
  
    LogError(e_msg := "Reading Safety Configuration failed!");
  else    
    // if it's still invalid, moving is possible and none of the connected modules has any reason to deactivate it (otherwise it would be inactive)
    if (b_MoveCommandInputActive = _Invalid) & (b_SafetyOnLocalCDIAS = FALSE) then
      b_MoveCommandInputActive := _Active;
    end_if;
    
    // we start the data object for continous writing to the module after we know that there is an input for this module and the move command is active
    if b_MoveCommandInputActive = _Active then
      // if the pdo mover is active we have to activate the data objects for continous run
      SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
      if AdditionalSPDOs then
        if AdditionalSPDOs > (ui_cnt_PDOInputBuffer-1) then
          AdditionalSPDOs := ui_cnt_PDOInputBuffer-1;
        end_if;
      
        for i := 0 to (AdditionalSPDOs-1) do
          SetDORunState(Handle:=aAdditionalPDOs[i].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
        end_for;
      end_if;
      WalkThroughPDOMoverList(pList := #pPDOMoverListInputs, _Active);
    else
      // tell all modules which think we can communicate via pdo mover, that this is not the case any more
      // for all module which are configured as safety inputs for this module
      // delete list with modules where communication (input) with pdo mover is defined
      WalkThroughPDOMoverList(pList := #pPDOMoverListInputs, _Inactive);
    end_if;

    if pPDOMoverListInputs then
      CleanupPDOMoverList(pList := #pPDOMoverListInputs);
    end_if;

    // if it's still invalid, moving is possible and none of the connected modules has any reason to deactivate it (otherwise it would be inactive)
    if (b_MoveCommandOutputActive = _Invalid) & (b_SafetyOnLocalCDIAS = FALSE) then
      b_MoveCommandOutputActive := _Active;
    end_if;

    // we start the data object for continous writing to the module after we know that there is an input for this module and the move command is active
    if b_MoveCommandOutputActive = _Active then
      // if the mover is active we have to activate the data objects for continous run
      WalkThroughPDOMoverList(pList := #pPDOMoverListInputs, _Active);//ZoePat 27.12.2012 14:31  PRÜFEN OB DAS RICHTIG IST!!??!! evtl. muss Outputs hier hin...
    else
      // tell all modules which think we can communicate via pdo mover, that this is not the case any more
      // for all module which are configured as safety outputs for this module
      // delete list with modules where communication (output) with pdo mover is defined
      WalkThroughPDOMoverList(pList := #pPDOMoverListOutputs, _Inactive);
    end_if;

    if pPDOMoverListOutputs then
      CleanupPDOMoverList(pList := #pPDOMoverListOutputs);
    end_if;

    // read config succeeded, check update cycle of unsafe variables
    CheckUnsafeUpdateCycle();
    
    
    // check for interface frame destination modules and mark them
    GetDestinationCRCs();
    
    // if there is a safety manager create a configuration message and send it to the safety manager
    if pSafetyManagerThis then
      CreateAndSendCfg();
    end_if;
    
    // last thing to do is to start realtime and cyclic work (they do nothing in _ReinitConfig state
    if ud_UnsafeVarsNotFound then
      SetSafetyState(NewState:=_UnsafeVarNotFound);
      ud_UnsafeVarsNotFound := 0;
    else
      if us_SetBusReadyState = SetBusReadyFinished then
        // we're already synchron from a former configuration phase
        SetSafetyState(NewState:=_SafetyClassOK);
      else
        SetSafetyState(NewState:=_WaitForSynchronicity);
      end_if;
    end_if;
  end_if;

  // free temporary configuration lists if there were any
  FreeCfgLists();
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ReadModulePath
	VAR_INPUT
		p_SDORequestBuffer 	: ^SDORequReadConfig;
		p_SDOResponseBuffer 	: ^SDORespReadConfig;
		p_ud_Address 	: ^UDINT;
		pModule 	: ^PathInfoType;
		p_ud_ModulePathLen_Max 	: ^UDINT;
		p_ud_ModulePathCompLen_Max 	: ^UDINT;
		us_SDOMaxDataSize 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    ud_ModulePathLen_Act    : UDINT;
    p_ud_ModulePath_Act     : ^UDINT;
  END_VAR

  //read length of module path
      
  //send request and receive data
  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                              , ud_Address          := p_ud_Address^
                              , us_Length           := 4
                              );

  //no response
  if ( sd_retval <> 0 ) then
    LogError("ReadModulePath: Failed to read length of module path");
    return;
  end_if;
  
  //length of module path
  ud_ModulePathLen_Act := p_SDOResponseBuffer^.ud_Data;
  
  //length is zero, check compressed path
  if ( ud_ModulePathLen_Act > 0 ) then
        
    // if it's too small => error
    if ( ud_ModulePathLen_Act > p_ud_ModulePathLen_Max^ ) then
      sd_retval                         := -100;
      SetSafetyState(NewState:=_MemAllocFailed);
      return;          
    end_if;
        
    //read path
        
    //address of first byte of path
    p_ud_Address^ += 4;
        
    //set pointer to first byte of target buffer
    p_ud_ModulePath_Act := ( pModule^.p_us_Path )$^UDINT;
        
    //read path block by block, if path is longer than max. length
    while ( ud_ModulePathLen_Act > us_SDOMaxDataSize ) do
          
      //send request and receive data
      sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                  , p_SDOResponseBuffer := p_SDOResponseBuffer
                                  , ud_Address          := p_ud_Address^
                                  , us_Length           := us_SDOMaxDataSize
                                  , b_UseCache          := FALSE
                                  );

      //no response
      if ( sd_retval <> 0 ) then
        LogError("ReadModulePath: Failed to read block of module path");
        return;
      end_if;
          
      //copy part of path
      ToStdLib.MemCpy(dest := p_ud_ModulePath_Act , source := #p_SDOResponseBuffer^.ud_Data, size := us_SDOMaxDataSize);
            
      //rest of path to be read
      ud_ModulePathLen_Act -= us_SDOMaxDataSize;
          
      //address of next block
      p_ud_Address^ += us_SDOMaxDataSize;
          
      //set pointer to next free byte of target buffer
      p_ud_ModulePath_Act += us_SDOMaxDataSize;
          
    end_while;

    // if there is something left
    if ud_ModulePathLen_Act then
      //read last bytes of path
        
      //send request and receive data
      sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                  , p_SDOResponseBuffer := p_SDOResponseBuffer
                                  , ud_Address          := p_ud_Address^
                                  , us_Length           := ud_ModulePathLen_Act$USINT
                                  , b_UseCache          := ud_ModulePathLen_Act$USINT < us_SDOMaxDataSize
                                  );

      //no response
      if ( sd_retval <> 0 ) then
        LogError("ReadModulePath: Failed to read last bytes of module path");
        return;
      end_if;
            
      ToStdLib.MemCpy(dest := p_ud_ModulePath_Act, source := #p_SDOResponseBuffer^.ud_Data, size := ud_ModulePathLen_Act);
    end_if;
    
    //address of next byte after path
    //address of last block + length of last read block
    p_ud_Address^ += ud_ModulePathLen_Act;
  else
    pModule^.p_us_Path := NIL;
    
    //address of compressed path
    p_ud_Address^ += 4;
  end_if;

// ============================================================================================================================

  // compressed module path starts here

  // read length of module path
      
  // send request and receive data
  sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                              , p_SDOResponseBuffer := p_SDOResponseBuffer
                              , ud_Address          := p_ud_Address^
                              , us_Length           := 4
                              );

  //no response
  if ( sd_retval <> 0 ) then
    LogError("ReadModulePath: Failed to read length of compressed module path");
    return;
  end_if;
  
  //length of module path
  ud_ModulePathLen_Act := p_SDOResponseBuffer^.ud_Data;
  
  pModule^.ui_PathCompLen := to_uint(ud_ModulePathLen_Act);
  
  //if length is zero, leave method
  if ( ud_ModulePathLen_Act = 0 ) then
    if pModule^.p_us_PathComp <> NIL then
      pModule^.p_us_PathComp := NIL;
    end_if;

    // address of CRC
    p_ud_Address^ += 4;

    return;
  end_if;

  //if it's too small => error
  if ( ud_ModulePathLen_Act > p_ud_ModulePathCompLen_Max^ ) then         
    sd_retval                         := -100;
    SetSafetyState(NewState:=_MemAllocFailed);
    return;
  end_if;

      
  //read path
      
  //address of first byte of path
  p_ud_Address^ += 4;

  //set pointer to first byte of target buffer
  p_ud_ModulePath_Act := pModule^.p_us_PathComp$^UDINT;

  //read path block by block, if path is longer than max. length
  while ( ud_ModulePathLen_Act > us_SDOMaxDataSize ) do
        
    //send request and receive data
    sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                , p_SDOResponseBuffer := p_SDOResponseBuffer
                                , ud_Address          := p_ud_Address^
                                , us_Length           := us_SDOMaxDataSize
                                , b_UseCache          := FALSE
                                );

    //no response
    if ( sd_retval <> 0 ) then
      LogError("ReadModulePath: Failed to read block of compressed module path");
      return;
    end_if;
        
    //copy part of path
    ToStdLib.MemCpy(dest := p_ud_ModulePath_Act , source := #p_SDOResponseBuffer^.ud_Data, size := us_SDOMaxDataSize);
          
    //rest of path to be read
    ud_ModulePathLen_Act -= us_SDOMaxDataSize;
        
    //address of next block
    p_ud_Address^ += us_SDOMaxDataSize;
        
    //set pointer to next free byte of target buffer
    p_ud_ModulePath_Act += us_SDOMaxDataSize;
        
  end_while;

  // if there is something left
  if ud_ModulePathLen_Act then

    //read last bytes of path
      
    //send request and receive data
    sd_retval := SDOReadCfgRequ ( p_SDORequestBuffer  := p_SDORequestBuffer
                                , p_SDOResponseBuffer := p_SDOResponseBuffer
                                , ud_Address          := p_ud_Address^
                                , us_Length           := ud_ModulePathLen_Act$USINT
                                , b_UseCache          := ud_ModulePathLen_Act$USINT < us_SDOMaxDataSize
                                );

    //no response
    if ( sd_retval <> 0 ) then
      LogError("ReadModulePath: Failed to read last bytes of compressed module path");
      return;
    end_if;
          
    ToStdLib.MemCpy(dest := p_ud_ModulePath_Act, source := #p_SDOResponseBuffer^.ud_Data, size := ud_ModulePathLen_Act);
  end_if;
  
  //address of next byte after path
  //address of last block + length of last read block
  p_ud_Address^ += ud_ModulePathLen_Act;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddModuleToRoutingTabs
	VAR_INPUT
		pModule 	: ^PathInfoType;
		pListHeader 	: ^PathInfoType;
		b_IsOptional 	: BOOL;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_TargetObject            : pVirtualBase;
    p_SafetyBase              : pVirtualBase;
    ud_IO_SafeNumber          : HDINT;
    ud_PDO_Buffer             : UDINT;
    pMoveCommandInputActive   : ^PDOMoveState;
    pMoveCommandOutputActive  : ^PDOMoveState;
    ud_MoveSourceDOHandle     : UDINT;
    ud_MoveSourceAddr         : UDINT;
    ud_MoveSourceOffset       : UDINT;
		MyPara 	                  : CmdStruct;
		MyResult	                : results;
  END_VAR

  // if the cpu is connected via varan there is a chance to activate the Move Command (only if all inputs for the cpu are also connected via VARAN)
  if b_VaranAvailable & (b_SafetyOnLocalCDIAS = FALSE) then
    pMoveCommandInputActive := #b_MoveCommandInputActive;    
    pMoveCommandOutputActive := #b_MoveCommandOutputActive;
  else
    pMoveCommandInputActive := NIL;
    pMoveCommandOutputActive := NIL;
  end_if;
  
  // initialize with invalid value
  ud_MoveSourceAddr := 0;
    
  //get this-pointer of object in network that is located with transfered path
  MyPara.uiCmd := _BUS_IF_GET_OBJECT_THIS_PTR;
  MyPara.aPara[0] := pModule^.p_us_Path$DINT;
  sd_retval$iprStates := ToBusInterface.NewInst(#MyPara, #MyResult);    
  p_TargetObject := MyResult.aData[0]$pVirtualBase;

  //this-pointer found
  if ( p_TargetObject ) then
    
    //add output module
    
    //If found this-pointer equals the own this-pointer, then the module has to be added to output-list.
    //This module (CPU) provides the safety input values for the output module (path in list-header).
    if ( p_TargetObject = this ) then

      //the output module is addressed by the ListHeaderPath     
      //get this-pointer of object in network that is located with transfered path
      MyPara.uiCmd := _BUS_IF_GET_OBJECT_THIS_PTR;
      MyPara.aPara[0] := pListHeader^.p_us_Path$DINT;
      sd_retval$iprStates := ToBusInterface.NewInst(#MyPara, #MyResult);    
      p_TargetObject := MyResult.aData[0]$pVirtualBase;
      
      //this-pointer found
      if ( p_TargetObject ) then

        MyPara.uiCmd := CMD_SM_GET_MODULE_TYPE;
        sd_retval$iprStates := p_TargetObject^.NewInst(#MyPara, #MyResult);    

        //check if it's a safety module
        if ( MyResult.aData[0]$UDINT = SM_TYPE_SAFETY_MODULE ) then        
      
          //object is based on SafetyBase
          p_SafetyBase := ( p_TargetObject )$pVirtualBase;
      
          //get pointer on PDO output buffer
          ud_PDO_Buffer := GetPointer2PDOBuffer();
          
          //configure safety output module and receive safety number
          //inform the output module about safety number and object path of the safe CPU

          MyPara.uiCmd := CMD_SM_CONFIG_SAFETY_OUTPUT;
          MyPara.aPara[0] := SafetyNumber$DINT;
          MyPara.aPara[1] := this$DINT;
          MyPara.aPara[2] := (GetPointer2PDOBuffer())$DINT;
          MyPara.aPara[3] := pModule$DINT;
          MyPara.aPara[4] := pMoveCommandOutputActive$DINT;
          MyPara.aPara[5] := ud_LocalMoveSourceAddr$DINT;
          MyPara.aPara[6] := b_IsOptional;
          MyPara.aPara[7] := 0; // Pass DO Handle           p_HandlePDORead$DINT;
          MyPara.aPara[8] := 0; // Offset within the DO     0$DINT;
          
          sd_retval$iprStates := p_SafetyBase^.NewInst(#MyPara, #MyResult);    

          ud_IO_SafeNumber := MyResult.aData[0]$UDINT;

//          ud_IO_SafeNumber := p_SafetyBase^.ConfigSafetyOutput  ( ud_SafeNrCPU    := SafetyNumber
//                                                                , ud_thisp        := this$UDINT
//                                                                , ud_p_PDOBuffer  := GetPointer2PDOBuffer()
//                                                                , pObject         := pModule
//                                                                , pMoveActive     := pMoveCommandOutputActive
//                                                                , ud_MoveSourceAddr := ud_LocalMoveSourceAddr
//                                                                , b_IsOptional := b_IsOptional
//                                                                );
    
          //output module successfully configured
          if ( ud_IO_SafeNumber <> 0 ) then

            // add thispointer to list of modules which are configured to communicate via pdo mover (output)
            if pMoveCommandOutputActive & (pMoveCommandOutputActive^ <> _Inactive) then
              AddToPDOMoverList(p_SafetyBase, #pPDOMoverListOutputs);
            end_if;

            //add module to routing table
            sd_retval := AddRoutingElement( ud_SafeNumber       := ud_IO_SafeNumber
                                          , ud_thisp            := p_SafetyBase$UDINT
                                          , pObject             := pListHeader
                                          );
          else
            sd_retval := 0; // could be an optional module
          end_if;
        else
          LogError("Config Read Error: Output module: Trying to add a non-safety module to safety routing table");
          LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
        end_if;
      else
        LogError("Config Read Error: Output module: No Object of HW-class found for module to be added to safety routing table");
        LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
      end_if;



    //add other cpu module

    elsif pModule = pListHeader then
    
      //the output module is addressed by the ListHeaderPath     
      //get this-pointer of object in network that is located with transfered path
      MyPara.uiCmd := _BUS_IF_GET_OBJECT_THIS_PTR;
      MyPara.aPara[0] := pModule^.p_us_Path$DINT;
      sd_retval$iprStates := ToBusInterface.NewInst(#MyPara, #MyResult);    
      p_TargetObject := MyResult.aData[0]$pVirtualBase;
      
      //this-pointer found
      if ( p_TargetObject ) then
      
        //check if it's a safety module
        MyPara.uiCmd := CMD_SM_GET_MODULE_TYPE;
        sd_retval$iprStates := p_TargetObject^.NewInst(#MyPara, #MyResult);    

        if ( MyResult.aData[0]$UDINT = SM_TYPE_SAFETY_MODULE ) then        
      
          //object is based on SafetyBase
          p_SafetyBase := p_TargetObject;
          
          //get safety number
          MyPara.uiCmd := CMD_SM_CONFIG_SAFETY_CPU;
          
          sd_retval$iprStates := p_SafetyBase^.NewInst(#MyPara, #MyResult);    

          ud_IO_SafeNumber := MyResult.aData[0]$UDINT;

//          ud_IO_SafeNumber := p_SafetyBase^.ConfigSafetyCpu();
    
          if ( ud_IO_SafeNumber <> 0 ) then
            
            //add module to routing table
            sd_retval := AddRoutingElement( ud_SafeNumber       := ud_IO_SafeNumber
                                          , ud_thisp            := p_SafetyBase$UDINT
                                          , pObject             := pListHeader
                                          );
          else
            LogError("Config Read Error: CPU module: 0 is an invalid safety number");            
            LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
          end_if;
        else
          LogError("Config Read Error: CPU module: Trying to add a non-safety module to safety routing table");          
          LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
        end_if;
      else
        LogError("Config Read Error: CPU module: No Object of HW-class found for module to be added to safety routing table");
        LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
      end_if;
      
    
    //add input module
    
    else
      //It's a safety input module, so it has to be added to safety input list.
      //check if found object represents a safety module
      MyPara.uiCmd := CMD_SM_GET_MODULE_TYPE;
      sd_retval$iprStates := p_TargetObject^.NewInst(#MyPara, #MyResult);    
      if ( MyResult.aData[0]$UDINT = SM_TYPE_SAFETY_MODULE ) then
            
        //object is based on SafetyBase
        p_SafetyBase := p_TargetObject;

        //configure safety input module and receive pointer on PDO-Buffer and safety number
        MyPara.uiCmd := CMD_SM_CONFIG_SAFETY_INPUT;
        MyPara.aPara[0] := SafetyNumber$DINT;
        MyPara.aPara[1] := this$DINT;
        MyPara.aPara[2] := (#ud_PDO_Buffer)$DINT;
        MyPara.aPara[3] := pMoveCommandInputActive$DINT;
        MyPara.aPara[4] := (#ud_MoveSourceAddr)$DINT;
        MyPara.aPara[5] := (#ud_MoveSourceDOHandle)$DINT;
        MyPara.aPara[6] := (#ud_MoveSourceOffset)$DINT;      
        sd_retval$iprStates := p_SafetyBase^.NewInst(#MyPara, #MyResult);    

        ud_IO_SafeNumber := MyResult.aData[0]$UDINT;

//      ud_IO_SafeNumber := p_SafetyBase^.ConfigSafetyInput ( ud_SafeNrCPU    := SafetyNumber
//                                                          , ud_thisp        := this$UDINT
//                                                          , p_PDOBuffer     := #ud_PDO_Buffer
//                                                          , pMoveActive     := pMoveCommandInputActive
//                                                          , p_ud_MoveSourceAddr := #ud_MoveSourceAddr
//                                                          );

        //input module successfully configured
        if ( ud_IO_SafeNumber <> 0 ) then
          // only if the configuration affects our cpu, we add something to our PDO input buffer
          MyPara.uiCmd := _BUS_IF_GET_OBJECT_THIS_PTR;
          MyPara.aPara[0] := pListHeader^.p_us_Path$DINT;
          sd_retval$iprStates := ToBusInterface.NewInst(#MyPara, #MyResult);    
          p_TargetObject := MyResult.aData[0]$pVirtualBase;

//          p_TargetObject := ( GetObjectThisp(p_us_ObjectPath := pListHeader^.p_us_Path) )$pVirtualBase;

          //this-pointer found              
          if ( p_TargetObject = this ) then         
          
            // add thispointer to list of modules which are configured to communicate via pdo mover (input)
            if pMoveCommandInputActive & (pMoveCommandInputActive^ <> _Inactive) then
              AddToPDOMoverList(p_SafetyBase, #pPDOMoverListInputs);
            end_if;
          
            //add pointer on PDO output buffer of input module to list of incoming PDOs
            sd_retval := AddPDOToInputBuffer(ud_p2Buffer         := ud_PDO_Buffer
                                           , ud_HandleSourceDO   := ud_MoveSourceDOHandle
                                           , ud_MoveSourceAddr   := ud_MoveSourceAddr
                                           , ud_MoveSourceOffset := ud_MoveSourceOffset
                                           , ud_SafetyNr         := ud_IO_SafeNumber
                                           , b_IsOptional        := b_IsOptional
                                           );
          else
            sd_retval := 0;
          end_if;
          
          if ( sd_retval = 0 ) then
            
            //add module to routing table
            sd_retval := AddRoutingElement( ud_SafeNumber       := ud_IO_SafeNumber
                                          , ud_thisp            := p_SafetyBase$UDINT
                                          , pObject             := pModule
                                          );
        
          else
            LogError("Config Read Error: Input module: Failed to add module to input buffer");            
            LogHWPath("HW-Path of Module: {0}", pListHeader^.p_us_Path);
          end_if;
        else
          // module in configuration, which is not physically available but hw-class is placed
          sd_retval := 0; // could be an optional module
        end_if;
      else
        LogError("Config Read Error: Input module: Trying to add a non-safety module to safety routing table");          
        LogHWPath("HW-Path of Module: {0}", pModule^.p_us_Path);
      end_if;
    end_if;
  else
    // module in configuration, which is not physically available and no hw-class is placed
    LogError("Config Read Error: Module in safety configuration, where no HW-Class is placed (maybe optional module)");
    LogHWPath("HW-Path of Module: {0}", pModule^.p_us_Path);
    sd_retval := 0;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetRoutingElementByThis
	VAR_INPUT
		ud_thisp 	: UDINT;
	END_VAR
	VAR_OUTPUT
		p_RoutElement 	: ^RoutElement;
	END_VAR
  VAR
  	i1                  : UINT;
    p_RoutElement_Act   : ^RoutElement;
  END_VAR

  p_RoutElement := NIL;
  
  //set pointer on first routing element
  p_RoutElement_Act := p_RoutTable;
  
  //check each element
  for i1 := 0 to ui_CntRoutElements - 1 do 
  
    //if searched this is found, pointer on routing element is returned
    if ( p_RoutElement_Act^.ud_Thisp = ud_thisp ) then
      p_RoutElement := p_RoutElement_Act;
      return;
    end_if;
    
    //set pointer to next element
    p_RoutElement_Act += sizeof ( RoutElement );
  
  end_for;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::SDOStdRequ
	VAR_INPUT
		us_Command 	: USINT;
		p_us_RespData 	: ^USINT;
		us_RespLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	pSDORequestBuffer   : ^t_SDOStdHeader;
    pSDOResponseBuffer  : ^SDOStdResp;
    RespBuffer          : ARRAY [0..127] OF USINT;
    RequBuffer          : ARRAY [0..127] OF USINT;
    us_OutLength        : USINT;
  END_VAR

  //SDO requests for this commands don't have any further data
  pSDORequestBuffer$^void := #RequBuffer[0];
  pSDOResponseBuffer$^void := #RespBuffer[0];
  
  //SDO response buffer (length header + rc + data)
  us_OutLength := sizeof(t_SDOStdHeader) + 1 + us_RespLength;
  
  //calculate length without crc
  pSDORequestBuffer^.len := sizeof(t_SDOStdHeader) - sizeof(t_SDOStdHeader.CRC);
  
  //type
  pSDORequestBuffer^.typ := SDO_STD;
  
  //sequence number
  pSDORequestBuffer^.SeqNr := us_CntSequNr;
  
  //increase counter for sequence number
  if us_CntSequNr < 16#7F then
    us_CntSequNr += 1;
  else
    us_CntSequNr := 0;
  end_if;
  
  //command to inform CPU about initializing classes is ok
  pSDORequestBuffer^.cmd := us_Command;
  
  //set CRC-field to 0
  pSDORequestBuffer^.CRC := 0;

  //send request
  sd_retval := SAFETY_iSendRequest( uiMaster    := 0
                                  , pucNode     := p_ObjectPath
                                  , uiInLength  := sizeof(t_SDOStdHeader)
                                  , pucInput    := pSDORequestBuffer$^USINT
                                  , uiOutLength := us_OutLength
                                  , pucOutput   := pSDOResponseBuffer$^USINT
                                  );

  

  //no response
  if ( sd_retval = 0 ) then

    //check sequence number to exclude a possible wrong response
    if ( pSDORequestBuffer^.SeqNr <> pSDOResponseBuffer^.StdHeader.SeqNr ) then
      sd_retval := -102;
      //log not routable SDOs
      LogError("SDO Problem (details in next line)");
      LogValue("Invalid Sequence number in SDO Standard Response. Got 0x{0} instead of expected 0x{1}", to_udint(pSDOResponseBuffer^.StdHeader.SeqNr), to_udint(pSDORequestBuffer^.SeqNr));
      
    //check returncode of SDO
    elsif ( pSDOResponseBuffer^.us_Returncode <> SB_SDO_RETCODE_OK ) then
      //log not routable SDOs
      LogError("SDO Problem (details in next line)");
      LogValue("Safety module 0x{0}: Retcode of SDO Standard Response was invalid. Retcode: 0x{1}", SafetyNumber$UDINT, to_udint(pSDOResponseBuffer^.us_Returncode));
      sd_retval := -103;
    end_if;
  else
    //log not routable SDOs
    LogError("SDO Problem (details in next line)");
    LogValue("SAFETY_iSendRequest failed with retcode: -0x{0}", to_udint(ABS(sd_retval)));
  end_if;
  
  //return response
  if ( ( sd_retval = 0 ) & ( p_us_RespData <> NIL )) then
  
    ToStdLib.MemCpy(dest := p_us_RespData, source := #pSDOResponseBuffer^.us_Data, size := us_RespLength);
  
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::LogError
	VAR_INPUT
		e_msg 	: ^CHAR;
	END_VAR
  VAR
    sz_name : ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  _GetObjName( this, #sz_name[ 0 ] );
  
  MyTrace(pFormat:="Safety Object {0}: {1}", pTxt0:=(#sz_name[ 0 ])$^CHAR, pTxt1:= e_msg, pTxt2:=NIL);

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetPDOInputBuffer
	VAR_INPUT
		ud_p2Buffer 	: UDINT;
	END_VAR
	VAR_OUTPUT
		p_InputBuffer 	: ^PDOInputBuffer;
	END_VAR
  VAR
  	i1                : UINT;
    p_InputBuffer_Act : ^PDOInputBuffer;
  END_VAR

  p_InputBuffer := NIL;
  
  if ui_cnt_PDOInputBuffer then
  
    //set pointer on first input buffer element
    p_InputBuffer_Act := #aPDOInputBuffer[0];
    
    //check each element
    for i1 := 0 to (ui_cnt_PDOInputBuffer-1) do 
    
      //if searched pointer is found, pointer on input buffer element is returned
      if ( p_InputBuffer_Act^.ud_p2Buffer = ud_p2Buffer ) then
        p_InputBuffer := p_InputBuffer_Act;
        return;
      end_if;
      
      //set pointer to next element
      p_InputBuffer_Act += sizeof ( PDOInputBuffer );
    
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetThisViaServerName
	VAR_INPUT
		pObjectDotServer 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		ThisPtr 	: pVoid;
	END_VAR
  VAR
    ChannelMode : CHMODE;
  END_VAR
  
  ThisPtr := NIL;

  if pObjectDotServer = NIL then
    return;
  end_if;
  
  // get thispointer to server via name
  ChannelMode := _LookUpEmbed_C(pObjectDotServer, #ThisPtr, NIL);

  // check if it's a server
  case ChannelMode of
    _CH_CMD,
    _CH_SVR:
    
  else
    ThisPtr := NIL;
    LogError(e_msg:="(SafetyBase::GetThisViaServerName) Couldn't get thispointer of server:");
    LogError(e_msg:=pObjectDotServer);
    ud_UnsafeVarsNotFound += 1;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		Value 	: UDINT;
		Value2 	: UDINT;
		Value3 	: UDINT;
	END_VAR
  VAR
    TempStr       : ARRAY [0..99] OF CHAR;
    TempStr2      : ARRAY [0..99] OF CHAR;
    TempStr3      : ARRAY [0..99] OF CHAR;
    TraceVal      : USINT;
    sz_name       : ARRAY [ 0..255 ] OF CHAR;
    TmpWithObjName: ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  // number of values
  TraceVal := 1;

  _itoa(Value, #TempStr[0]);
  
  if pString <> NIL then
    _GetObjName( this, #sz_name[ 0 ] );
    _strcpy(dest:=#TmpWithObjName[0], src:="ObjectName ");
    _strcat(dest:=#TmpWithObjName[0], src:=#sz_name[0]);
    _strcat(dest:=#TmpWithObjName[0], src:=": ");
    _strcat(dest:=#TmpWithObjName[0], src:=pString);
    
    if Value2 <> 16#FFFFFFFF then
      _itoa(Value2, #TempStr2[0]);
      TraceVal += 1;
    end_if;

    if Value3 <> 16#FFFFFFFF then
      _itoa(Value3, #TempStr3[0]);
      TraceVal += 1;
    end_if;
    
    case TraceVal of
      1:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=NIL, pTxt2:=NIL);
      2:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=NIL);
      3:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=#TempStr3[0]);        
    end_case;
  else
    MyTrace(pFormat:="<invalid string>", pTxt0:=NIL, pTxt1:=NIL, pTxt2:=NIL);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddUnsafeRoutElement
	VAR_INPUT
		pRoutTable 	: ^pUnsafeIORoutingElement;
		pRoutElementsNo 	: ^UINT;
		ud_Address 	: UDINT;
		ui_NameLen 	: UINT;
		pNameNewElement 	: ^CHAR;
		BitMask 	: BDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	p_RoutElement   : ^UnsafeIORoutingElement;
    RemoteDomain      : USINT;
    LinearMemory : BOOL;
  END_VAR 

  sd_retval := -1;

  // check parameters
  if (ui_NameLen = 0) | (pNameNewElement = NIL) then
    LogError("(SafetyBase::AddUnsafeRoutElement) Invalid call parameters for the variable name (invalid configuration in safety cpu)");
    return;
  end_if;

  // on CSCP011 the SDO_COMMAND_WRITE_VALUES didn't exist, so we have to make a difference here
  if (pRoutTable = #p_UnsafeOutputsTable) then
    LinearMemory := TRUE;
  else
    LinearMemory := FALSE;
  end_if;

  // if there is a domain info attached
  if (pNameNewElement^ = '@') & ((pNameNewElement + 1)^ = 'D') then
    // check if it's in the actual domain
    if (pNameNewElement + 3)^ = ':' then
      // 1 digit domain number
      RemoteDomain := (pNameNewElement + 2)^ - '0';
    elsif (pNameNewElement + 4)^ = ':' then
      // 2 digits domain number
      RemoteDomain := ((pNameNewElement + 2)^ - '0') * 10 + (pNameNewElement + 3)^ - '0';
    else
      LogError(e_msg:="(SafetyBase::AddUnsafeRoutElement) Invalid domain info at unsafe variable");      
      return;
    end_if;
    
    // prepare the string (remove the domain info)
    if RemoteDomain >= 10 then
      ui_NameLen -= 5;
      pNameNewElement += 5;
    else
      ui_NameLen -= 4;
      pNameNewElement += 4;
    end_if;    
  end_if;


  //With the first element, the table must be positioned
  if ( pRoutTable^ = NIL ) then
  
    //allocate memory for first routing element
    pRoutTable^$^void := ToStdLib.Malloc(size := sizeof(UnsafeIORoutingElement));
  
    if ( pRoutTable^ = NIL ) then
  
      sd_retval                         := -1;
      SetSafetyState(NewState:=_MemAllocFailed);
      return;
      
    end_if;
    
    p_RoutElement := pRoutTable^;
    
  else
    
    //add new element
    
    //add space for one element to table (linked list element for inputs and linear data area for outputs)
    if LinearMemory = FALSE then
    // search for a place
      p_RoutElement := pRoutTable^;
      while p_RoutElement^.pNext do
        p_RoutElement := p_RoutElement^.pNext;
      end_while;
      p_RoutElement^.pNext$^void := ToStdLib.Malloc(sizeof(UnsafeIORoutingElement));

      if ( p_RoutElement^.pNext = NIL ) then
      
        sd_retval                         := -1;
        SetSafetyState(NewState:=_MemAllocFailed);
        return;
        
      end_if;

      // set pointer to new element
      p_RoutElement := p_RoutElement^.pNext;
    else
      pRoutTable^$^void := ToStdLib.ReAlloc(mptr := pRoutTable^, newsize := ( ( pRoutElementsNo^ + 1 ) * sizeof(UnsafeIORoutingElement)));

      if ( pRoutTable^ = NIL ) then
      
        sd_retval                         := -1;
        SetSafetyState(NewState:=_MemAllocFailed);
        return;
        
      end_if;
      
      //set pointer to empty element on last position
      p_RoutElement := pRoutTable^ + ( pRoutElementsNo^ ) * sizeof(UnsafeIORoutingElement);
    end_if;
  end_if;  

  if p_RoutElement then
    //allocate memory for name
    p_RoutElement^.pName$^void := ToStdLib.Malloc(size := ui_NameLen);
  
    if ( p_RoutElement^.pName = NIL ) then
  
      sd_retval                         := -1;
      SetSafetyState(NewState:=_MemAllocFailed);
      return;
      
    end_if;

    p_RoutElement^.NameLength := ui_NameLen;
    _memcpy(ptr1:=p_RoutElement^.pName, ptr2:=pNameNewElement, cntr:=ui_NameLen);

    // unsafe bdint variables are localized in a different memory area
    if BitMask then
      p_RoutElement^.ud_Address := SB_SDO_ADDRESS_UNSAFE_BDINT + ud_Address;
    else
      p_RoutElement^.ud_Address := SB_SDO_ADDRESS_APP_DATA + ud_Address;
    end_if;
    
    p_RoutElement^.BitMask := BitMask;
    
    // initialize with invalid
    p_RoutElement^.b_IsValid            := FALSE;
    p_RoutElement^.sd_OldValue          := (16#80000000)$DINT;
    p_RoutElement^.sd_NewValue4External := (16#80000000)$DINT;

    // remember that we haven't transmitted this value so far
    p_RoutElement^.b_AlreadyTransmitted := FALSE;

    // initialize next pointer
    p_RoutElement^.pNext := NIL;
    
    //increase counter
    pRoutElementsNo^ += 1;
    
    // check if name exists in PLC
    p_RoutElement^.ud_Thisp   := GetThisViaServerName(pNameNewElement)$UDINT;
    if (pRoutTable = #p_UnsafeOutputsTable) & p_RoutElement^.BitMask then
      p_RoutElement^.UnsafeType := BDINTOutput;
    else
      p_RoutElement^.UnsafeType := NormalUnsafe;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::InitPathInfo
	VAR_INPUT
		pPathInfo 	: ^PathInfoType;
	END_VAR

  pPathInfo^.p_us_Path := NIL;
  pPathInfo^.p_us_PathComp := NIL;
  pPathInfo^.ui_PathCompLen := 0;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::WriteTDO2Module
	VAR_INPUT
		pTDO 	: ^TDOType;
	END_VAR

  if Online then

    // responses into response buffer, request into requestbuffer (only enough place for 1)
    if pTDO^.StdHeader.Typ$USINT AND SB_SSDO_MASK_RESPONSE then
      IF ( s_TDORingbuffer.ud_entries < ( SIZEOF( TDORingbuffer.Entry ) / SIZEOF( TDOType ) ) ) THEN
        s_TDORingbuffer.Entry[s_TDORingbuffer.ud_WritePos] :=  pTDO^;
        s_TDORingbuffer.ud_WritePos := ( s_TDORingbuffer.ud_WritePos + 1 ) mod ( SIZEOF( TDORingbuffer.Entry ) / SIZEOF( TDOType ) );
        s_TDORingbuffer.ud_Entries += 1;
        s_TDORingbuffer.b_ErrorTriggered := FALSE;
      ELSIF ( s_TDORingbuffer.b_ErrorTriggered = FALSE ) THEN
        LogError(e_msg:="Buffer for TDO-Messages is full!");
        s_TDORingbuffer.b_ErrorTriggered := TRUE;
      END_IF;

      IF s_TDORingbuffer.ud_Entries > s_TDORingbuffer.ud_maxEntries THEN
        s_TDORingbuffer.ud_maxEntries := s_TDORingbuffer.ud_Entries;
      END_IF;
    else
      s_TDORingbuffer.RequestTDO := pTDO^;
      s_TDORingbuffer.b_RequestAvailable := TRUE;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ResetConfig
  VAR
    p_SafetyBase        : pVirtualBase;
  	p_RoutElement       : ^RoutElement;
    p_UnsafeRoutElement : ^UnsafeIORoutingElement;
    i                   : UINT;
    ii                   : DINT;
    MyPara              : CmdStruct;
    MyResult            : results;
  END_VAR
  
  // tell all modules, which are connected to this cpu (through the old configuration) that they should delete the cpu from their routing table
  // must be more than 1, because 1st is always own entry
  if p_RoutTable & (ui_CntRoutElements > 1) then
    //set pointer on 2nd routing element
    p_RoutElement := p_RoutTable + sizeof(RoutElement);
    for i := 1 to (ui_CntRoutElements - 1) do
      // clear everything except this object (done after the for loop)
      if p_RoutElement^.ud_Thisp <> THIS$UDINT then
        // get thispointer of routing element
        p_SafetyBase := (p_RoutElement^.ud_Thisp)$pVirtualBase;
        
        // call other safety-class to remove the safetynumber from the routing table
        MyPara.uiCmd := CMD_SM_REMOVE_CPU_FROM_TABLE;
        MyPara.aPara[0] := SafetyNumber$DINT;
        
        p_SafetyBase^.NewInst(#MyPara, #MyResult);    

//        p_SafetyBase^.RemoveCPUFromTable(ud_SafetyNr := SafetyNumber);        
      end_if;

      // free memory of compressed path
      if p_RoutElement^.p_CompressedPath then
        ToStdLib.Free(mptr:=p_RoutElement^.p_CompressedPath);
      end_if;

      // set pointer on next routing element
      p_RoutElement += sizeof(RoutElement);
    end_for;
    
    // reduce local routing table to the cpu's own entry
    ui_CntRoutElements := 1;
  end_if;

  // on CSCP011 the SDO_COMMAND_WRITE_VALUES didn't exist, so we have to make a difference here
  while p_UnsafeInputsTable do
    p_UnsafeRoutElement := p_UnsafeInputsTable;
    p_UnsafeInputsTable := p_UnsafeInputsTable^.pNext;
    
    ToStdLib.Free(mptr:=p_UnsafeRoutElement^.pName);
    ToStdLib.Free(mptr:=p_UnsafeRoutElement);
  end_while;
  ui_CntUnsafeInputs := 0;

  // unsafe outputs are always in linear memory
  if p_UnsafeOutputsTable then
    ToStdLib.Free(mptr:=p_UnsafeOutputsTable);
    p_UnsafeOutputsTable := NIL;
  end_if;
  ui_CntUnsafeOutputs := 0;
  
  // reset no of SDO input buffer
  ui_cnt_SDOInputBuffer := 0;
  
  // if the old configuration is reset, check for the configured state of the cpu
  b_CheckConfigured := TRUE;

  if b_VaranAvailable then
    // by default the mover is invalid. it will be initialized when reading the configuration
    b_MoveCommandInputActive := _Invalid;
    b_MoveCommandOutputActive := _Invalid;

    SetDORunState(Handle:=InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
    InputMovSettings.EnableState := _BUS_IF_RUN_STATE_NO_RUN;
    
    if AdditionalSPDOs then
      for ii := 0 to (AdditionalSPDOs-1) do
        SetDORunState(Handle:=aAdditionalPDOs[ii].InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
        aAdditionalPDOs[ii].InputMovSettings.EnableState := _BUS_IF_RUN_STATE_NO_RUN;
      end_for;
    end_if;
  else
    // if no VARAN, we can't move the PDOs
    b_MoveCommandInputActive := _Inactive;
    b_MoveCommandOutputActive := _Inactive;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::RemoveCPUFromTable
	VAR_INPUT
		ud_SafetyNr 	: HDINT;
	END_VAR
  VAR
  	p_RoutElement   : ^RoutElement;
    i               : UDINT;
    FoundIndex      : UDINT;
    pPDOInputBuffer : ^PDOInputBuffer;
    Found : BOOL;
  END_VAR

  // if we are a cpu, do nothing
  if b_CheckCRC then
    return;
  end_if;
  
  //check each element (must be more than 1, because 1st is always own entry)
  if p_RoutTable & (ui_CntRoutElements > 1) then
    //set pointer on 2nd routing element
    p_RoutElement := p_RoutTable + sizeof(RoutElement);
    for i := 1 to (ui_CntRoutElements - 1) do
    
      // if we found safenumber, delete element from table
      if ( p_RoutElement^.ud_SafeNumber = ud_SafetyNr ) then
      
        // at last element we don't need to copy data, just decrease buffersize
        if i <> (ui_CntRoutElements - 1) then
          _memcpy(p_RoutElement, p_RoutElement + sizeof(RoutElement), sizeof(RoutElement) * (ui_CntRoutElements - 1 - i));
        end_if;
        
        // free 1 element and decrease element counter
        ui_CntRoutElements -= 1;

        exit;
      end_if;
      
      // set pointer on next routing element
      p_RoutElement += sizeof(RoutElement);
    end_for;
  end_if;  
    
  // reset no of SDO input buffer
  ui_cnt_SDOInputBuffer := 0;

  if b_VaranAvailable then
    // by default the mover is invalid. it will be initialized when reading the configuration
    b_MoveCommandInputActive := _Invalid;
    b_MoveCommandOutputActive := _Invalid;

    if InputMovSettings.MoveSettingsBusIF.Handle then
      SetDORunState(Handle:=InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);

      if AdditionalSPDOs then
        for i := 0 to (AdditionalSPDOs-1)$UDINT do
          SetDORunState(Handle:=aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
        end_for;
      end_if;
    end_if;
  else
    // if no VARAN, we can't move the PDOs
    b_MoveCommandInputActive := _Inactive;
    b_MoveCommandOutputActive := _Inactive;
  end_if;

  // check if we received a PDO from this CPU => if so, delete it from the PDO input buffer
  if ui_cnt_PDOInputBuffer then   
    // search for the PDO
    Found := FALSE;
    pPDOInputBuffer := #aPDOInputBuffer[0];
    for FoundIndex := 0 to (ui_cnt_PDOInputBuffer-1) do
      if pPDOInputBuffer^.ud_SafetyNr = ud_SafetyNr then
        Found := TRUE;
        exit;
      end_if;
      
      pPDOInputBuffer += sizeof(PDOInputBuffer);
    end_for;

    // if we found the PDO => remove it from memory (move the memory behind the found PDO over the place of the found PDO)
    if Found then
      // if it's last entry (no entries have to be moved) => we only have to copy some memory if it's not the last
      if FoundIndex < (ui_cnt_PDOInputBuffer-1) then
        for i := FoundIndex to (ui_cnt_PDOInputBuffer-2) do
          aPDOInputBuffer[i] := aPDOInputBuffer[i+1];
        end_for;
      end_if;
      ui_cnt_PDOInputBuffer -= 1;
    end_if;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::CheckUnsafeUpdateCycle

  // we can only use 56 byte pay load (instead of 64) because fw drops the 8 byte used for addresses in safe SDO

  if ui_CntUnsafeOutputs then
  // maximum of read variables in 1 frame is 15 (56 Bytes pay load - 1 Byte Returncode - 1 Byte Length = 54 Bytes => 13x4Bytes = 52)
    MaxVarsPerReadPackage := (SB_SDO_MAX_LENGTH - (sizeof(SDOHeader) - sizeof(SDOHeader.SessId)) - sizeof(SDORespReadConfig.us_Returncode) - sizeof(SDORespReadConfig.us_Length)) / sizeof(DINT);
    ReadFramesNeeded := ((ui_CntUnsafeOutputs - 1) / MaxVarsPerReadPackage) + 1;
  else
    ReadFramesNeeded := 0;
  end_if;

  if ui_CntUnsafeInputs then
  // maximum of write variables in 1 frame is 14 (56 Bytes pay load - 4 Byte Address - 1 Byte Length = 51 Bytes => 12x4Bytes = 48)
    MaxVarsPerWritePackage := (SB_SDO_MAX_LENGTH - (sizeof(SDOHeader) - sizeof(SDOHeader.SessId)) - sizeof(SDORequReadConfig.ud_Address) - sizeof(SDORequReadConfig.us_Length)) / sizeof(DINT);
    WriteFramesNeeded := ((ui_CntUnsafeInputs - 1) / MaxVarsPerWritePackage) + 1;
  else
    WriteFramesNeeded := 0;
  end_if;

  // check if user has given us enough time
  ud_TransfertimePerPackage := SB_SDO_TRANSFERTIME;
  
  if ( (WriteFramesNeeded + ReadFramesNeeded) * ud_TransfertimePerPackage ) > ServerUpdateTime then
    ServerUpdateTime := ( WriteFramesNeeded + ReadFramesNeeded ) * ud_TransfertimePerPackage;
    ud_ServerUpdateTime := ( ReadFramesNeeded ) * ud_TransfertimePerPackage;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::FetchDiagState

  DiagVars.UserDiagStateReady := FALSE;
  DiagVars.UserWantsDiagState := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::GetDiagState
	VAR_INPUT
		pDiagState 	: ^SafetyDiagState;
	END_VAR
	VAR_OUTPUT
		StateReady 	: BOOL;
	END_VAR
  
  StateReady := DiagVars.UserDiagStateReady;
  
  // if data ready, we save it into user structure
  if StateReady then
    pDiagState^.RunState            := DiagVars.UserGetStateResp.RuntimeState;
    pDiagState^.ConfigState         := DiagVars.UserGetStateResp.ConfigState;
    pDiagState^.LoginLevel          := DiagVars.UserGetStateResp.LoginLevel;
    pDiagState^.ErrorCounterIOState := DiagVars.UserGetStateResp.ErrorCount;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::FetchDiagInfo
	VAR_INPUT
		ucChoice 	: USINT;
	END_VAR

  DiagVars.ucChoiceDiagInfo  := ucChoice;
  DiagVars.UserDiagInfoReady := FALSE;
  DiagVars.UserWantsDiagInfo := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::GetDiagInfo
	VAR_INPUT
		pDiagInfo 	: ^SafetyDiagInfo;
	END_VAR
	VAR_OUTPUT
		StateReady 	: BOOL;
	END_VAR
  
  StateReady := DiagVars.UserDiagInfoReady;
  
  // if data ready, we save it into user structure
  if StateReady then
    pDiagInfo^ := DiagVars.UserGetDiagInfoResp;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::SDORequ
	VAR_INPUT
		us_Command 	: USINT;
		p_us_RequData 	: ^USINT;
		us_RequLength 	: USINT;
		p_us_RespData 	: ^USINT;
		us_RespLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	pSDORequestBuffer   : ^t_SDOStdHeader;
    pSDOResponseBuffer  : ^SDOStdResp;
    RespBuffer          : ARRAY [0..127] OF USINT;
    RequBuffer          : ARRAY [0..127] OF USINT;
    us_InLength         : USINT;
    us_OutLength        : USINT;
  END_VAR

  //SDO requests for this commands don't have any further data
  pSDORequestBuffer$^void := #RequBuffer[0];
  pSDOResponseBuffer$^void := #RespBuffer[0];  
   
  //SDO request buffer (length header + data)
  us_InLength := sizeof(t_SDOStdHeader) + us_RequLength;
  
  //SDO response buffer (length header + rc + data)
  us_OutLength := sizeof(t_SDOStdHeader) + 1 + us_RespLength;
  
  //calculate length without crc
  pSDORequestBuffer^.len := sizeof(t_SDOStdHeader) - sizeof(t_SDOStdHeader.CRC) + us_RequLength;
  
  //type
  pSDORequestBuffer^.typ := SDO_STD;
  
  //sequence number
  pSDORequestBuffer^.SeqNr := us_CntSequNr;

  _memcpy(ptr1:=pSDORequestBuffer + sizeof(t_SDOStdHeader), ptr2:=p_us_RequData, cntr:=us_RequLength);

  //increase counter for sequence number
  if us_CntSequNr < 16#7F then
    us_CntSequNr += 1;
  else
    us_CntSequNr := 0;
  end_if;
  
  //command to inform CPU about initializing classes is ok
  pSDORequestBuffer^.cmd := us_Command;
  
  //set CRC-field to 0
  pSDORequestBuffer^.CRC := 0;
  
  //send request
  sd_retval := SAFETY_iSendRequest( uiMaster    := 0
                                  , pucNode     := p_ObjectPath
                                  , uiInLength  := us_InLength
                                  , pucInput    := pSDORequestBuffer$^USINT
                                  , uiOutLength := us_OutLength
                                  , pucOutput   := pSDOResponseBuffer$^USINT
                                  );

  //no response
  if ( sd_retval = 0 ) then

    //check sequence number to exclude a possible wrong response
    if ( pSDORequestBuffer^.SeqNr <> pSDOResponseBuffer^.StdHeader.SeqNr ) then
      sd_retval := -102;
      
    //check returncode of SDO
    elsif ( pSDOResponseBuffer^.us_Returncode <> SB_SDO_RETCODE_OK ) then
      sd_retval := -103;
    end_if;
  
  end_if;
  
  //return response
  if ( ( sd_retval = 0 ) & ( p_us_RespData <> NIL )) then
    ToStdLib.MemCpy(dest := p_us_RespData, source := #pSDOResponseBuffer^.us_Data, size := us_RespLength);
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::SaveLog
	VAR_INPUT
		ucChoice 	: USINT;
		pDPNE 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Success 	: DINT;
	END_VAR

  if DiagVars.SavingLogInProgress = FALSE then
    DiagVars.SavingLogInProgress := TRUE;
    
    DiagVars.ucChoiceSaveLog := ucChoice;
  
    _memcpy(ptr1:=#DiagVars.DPNE, ptr2:=pDPNE, cntr:=_strlen(pDPNE));
    
    Success := TRUE;
  else
    Success := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::SaveLogActive
	VAR_OUTPUT
		Finished 	: BOOL;
	END_VAR
  
  Finished := DiagVars.SavingLogInProgress;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::BlockedTransferLength
	VAR_INPUT
		ud_Datalength 	: UDINT;
		us_MaxBlocklength 	: USINT;
	END_VAR
	VAR_OUTPUT
		us_ActBlocklength 	: USINT;
	END_VAR

  IF ud_Datalength > to_UDINT(us_MaxBlocklength) THEN
    us_ActBlocklength := us_MaxBlocklength;
  ELSE
    us_ActBlocklength := to_USINT(ud_Datalength);
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::MyTrace
	VAR_INPUT
		pFormat 	: ^CHAR;
		pTxt0 	: ^CHAR;
		pTxt1 	: ^CHAR;
		pTxt2 	: ^CHAR;
	END_VAR
  VAR
    nLen      : UDINT;
    pChr      : ^CHAR;
    nTxt      : UDINT;
    nRpl      : UDINT;
    pTxt      : ^CHAR;
    pText     : ^CHAR;
    FormText  : ARRAY [0 .. 255] OF CHAR;
  END_VAR

  // this method is a workaround for the TRACE message limitation problem

  pText := #FormText[0];

  _memset(dest:=#FormText[0], usByte:=0, cntr:=256); // to keep the zero termination

  _strncpy(pText, pFormat, 250);
  nLen  := _strlen(pText);
  pChr  := pText;
  
  WHILE nLen DO
    IF pChr^ = '{' THEN         // works for the first 10 replacement texts (single digit numbers)
      nTxt  := (pChr+1)^ - '0';
      CASE nTxt OF
        0:  pTxt  := pTxt0;
        1:  pTxt  := pTxt1;
        2:  pTxt  := pTxt2;
      ELSE
        pTxt  := "INV";
      END_CASE;
      nRpl  := _strlen(pTxt);
      if nLen - 3 + nRpl > 250 then
        pTxt := "LEN";  // replace the replacement text with "LEN" to see that we're out of length for this string
        nRpl := 3;
      end_if;
      _memmove(pChr + nRpl, pChr + 3, nLen);
      _memcpy(pChr, pTxt, nRpl);
      pChr  += nRpl;  // next character to parse is after the replacement text
      nLen  -= 3;     // the remaining length of the format string is decremented by 3
      if nLen > 250 then  // catch overrun of nLen
        nLen := 0;
      end_if;
    ELSE
      pChr  += 1;
      nLen  -= 1;
    END_IF;
  END_WHILE;

  TRACE(#FormText[0]);
  if ( p_KernelLog ) then
    OS_KERNELLOG0(#FormText[0]);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddToPDOMoverList
	VAR_INPUT
		pThis 	: pVirtualBase;
		pList 	: ^pPDOMoverList;
	END_VAR
  VAR
    pHelp : ^PDOMoverList;
  END_VAR

  if pList^ = NIL then
    pList$^pvoid^ := ToStdLib.Malloc(size:=sizeof(PDOMoverList));
    //Graphic.Memory((#pList)$^pVoid, sizeof(PDOMoverList));
    pHelp := pList^;
  else
    pHelp := pList^;
    if pHelp^.pThis = pThis then
      // this pointer already in buffer => leave function
      return;
    end_if;
    while pHelp^.pNext <> NIL do
      if pHelp^.pThis <> pThis then
        pHelp := pHelp^.pNext;
      else
        // this pointer already in buffer => leave function
        return;
      end_if;
    end_while;
    pHelp^.pNext$pvoid := ToStdLib.Malloc(size:=sizeof(PDOMoverList));
    pHelp := pHelp^.pNext;
  end_if;
  
  if pHelp <> NIL then
    pHelp^.pThis := pThis;
    pHelp^.pNext := NIL;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::WalkThroughPDOMoverList
	VAR_INPUT
		pList 	: ^pPDOMoverList;
		NewState 	: PDOMoveState;
	END_VAR
  VAR
  	pAct     : ^PDOMoverList;
    pFree    : ^void;
		MyPara 	 : CmdStruct;
		MyResult : results;
  END_VAR

  // get pointer on first element of list
  pAct := pList^;

  // if we have entries left we walk on
  WHILE pAct DO
#pragma warning(disable:137 )
    // set state of corresponding PDOMover to off
    IF pList = #pPDOMoverListInputs THEN
      if NewState = _Inactive then

        MyPara.uiCmd := CMD_SM_DEACTIVATE_MOVE_CMD;
        MyPara.aPara[0] := 0;
        pAct^.pThis^.NewInst(#MyPara, #MyResult);    
        
//        pAct^.pThis^.b_MoveCommandOutputActive := _Inactive;
      end_if;
    ELSE
      if NewState = _Inactive then

        MyPara.uiCmd := CMD_SM_DEACTIVATE_MOVE_CMD;
        MyPara.aPara[0] := 1;
        pAct^.pThis^.NewInst(#MyPara, #MyResult);    

//        pAct^.pThis^.b_MoveCommandInputActive := _Inactive;
      end_if;
    END_IF;
#pragma warning(default:137 )    
    
    //go to next entry and get rid of the allocated memory
    pFree := pAct;
    pAct := pAct^.pNext;
    ToStdLib.Free(mptr:=pFree);
  END_WHILE;
  
  // we got rid of the memory above - to make sure nobody will use this data again we clear the list entry
  pList^ := NIL;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::CleanupPDOMoverList
	VAR_INPUT
		pList 	: ^pPDOMoverList;
	END_VAR
  VAR
  	pAct : ^PDOMoverList;
    pFree : ^void;
  END_VAR

  // get pointer on first element of list
  pAct := pList^;

  // if we have entries left we walk on
  WHILE pAct DO    
    //go to next entry and get rid of the allocated memory
    pFree := pAct;
    pAct := pAct^.pNext;
    ToStdLib.Free(mptr:=pFree);
  END_WHILE;
  
  // we got rid of the memory above - to make sure nobody will use this data again we clear the list entry
  pList^ := NIL;
  
END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL SafetyBase::AddFrame
	VAR_INPUT
		pFrame 	: ^t_SDOStdHeader;
		FrameState 	: DINT;
		CallerSafetyNr 	: HDINT;
	END_VAR

END_FUNCTION
#pragma warning(default: 73)

FUNCTION VIRTUAL SafetyBase::RecordFrame
	VAR_INPUT
		pFrame 	: ^DINT;
		FrameState 	: DINT;
	END_VAR
  VAR
    ThisBackup  : pVoid;
    TempSafetyNr: HDINT;
  END_VAR

  if pAnalyzerThis & pAnalyzerMethod then
    
    TempSafetyNr := SafetyNumber;
  
    ThisBackup := THIS;
    
    THIS := pAnalyzerThis$^SafetyBase;
    pAnalyzerMethod$AddFrame(pFrame$^t_SDOStdHeader, FrameState, TempSafetyNr);
    
    THIS := ThisBackup$^SafetyBase;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::ShowProjectRevision

// overload this for CPU modules
  
END_FUNCTION


FUNCTION SafetyBase::DOCheck
	VAR_INPUT
		pFrame 	: ^t_SDOStdHeader;
		pCheckStruct 	: ^SafetyBase::t_DataObjectCheck;
	END_VAR
  VAR
  	DOCheckHeader : t_SDOStdHeader;
    ActTime : UDINT;
  END_VAR

  // check if input parameters are correct
  if pFrame & pFrame^.Len & pCheckStruct then
    DOCheckHeader := pFrame^;
    
    // only if we got a different frame
    if DOCheckHeader <> pCheckStruct^.LastHeader then
      ActTime := OS_READMICROSEC();
      
      pCheckStruct^.TimeDiff := ActTime - pCheckStruct^.LastTime;
      
      if pCheckStruct^.TimeDiff > pCheckStruct^.TimeDiffMax then
        if pCheckStruct^.TimeDiffMax = 0 then
          pCheckStruct^.TimeDiffMax := 1;
        else
          pCheckStruct^.TimeDiffMax := pCheckStruct^.TimeDiff;
        end_if;
      end_if;

      if pCheckStruct^.TimeDiff < pCheckStruct^.TimeDiffMin then
        pCheckStruct^.TimeDiffMin := pCheckStruct^.TimeDiff;
      end_if;


      pCheckStruct^.LastTime := ActTime;      
    else
      // if it's the same frame again: problem!
      pCheckStruct^.SameFrameCnt += 1;
    end_if;
    pCheckStruct^.LastHeader := DOCheckHeader;
  end_if; 

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::CalcPDOLength
	VAR_INPUT
		BoolVarNo 	: UDINT;
		DintVarNo 	: UDINT;
	END_VAR
	VAR_OUTPUT
		PdoLen 	: USINT;
	END_VAR
  VAR
    PayLoad : USINT;
  END_VAR

  // we have at least the header
  PdoLen := sizeof(PDOType) - sizeof(PDOType.DataAndCopy);
  PayLoad := 0;
  
  // now add some space for the needed data
  if BoolVarNo then
    // 1 byte (type + number of values) + 1 byte index + 2 bits for every value (4 per byte)
    PayLoad += 2 + ((BoolVarNo$USINT + 3) / 4);

    // make the it 2 byte aligned (if it isn't already) => only if no dint variables, otherwise it is done one at the DINT variables
    if (PayLoad MOD 2) & (DintVarNo = 0) then
      PayLoad := PayLoad + (2 - (PayLoad MOD 2)); //increase memory, up to a value, which could be divided by 2
    end_if;
  end_if;

  if DintVarNo then
    // 1 byte (type + number of values) + 1 byte index + 1 byte errorflags per 8 values + 4 byte for every value
    PayLoad += 2 + (((DintVarNo$USINT - 1 ) / 8) + 1) + DintVarNo$USINT * 4;
    
    // make the it 2 byte aligned (if it isn't already)
    if (PayLoad MOD 2) then
      PayLoad := PayLoad + (2 - (PayLoad MOD 2)); //increase memory, up to a value, which could be divided by 2
    end_if;
  end_if;

  // duplicate it
  PayLoad *= 2;

  // add it to the total length
  PdoLen += PayLoad; 

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddModuleToCfg
	VAR_INPUT
		ModuleCfg 	: t_ModuleCfg;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pHelp : ^t_ModuleListElem;
  END_VAR

  retcode := 0;

  if pFirstModuleCfg = NIL then
    pFirstModuleCfg$pVoid := ToStdLib.Malloc(size:=sizeof(t_ModuleListElem));
    pHelp := pFirstModuleCfg;
  else
    pHelp := pFirstModuleCfg;
    // if searched path has been found, we already got this module in our list
    if (ModuleCfg.PathLen = pHelp^.ModuleInfo.PathLen) & (ToStdLib.MemCmp(dest:= ModuleCfg.pPath, source:= pHelp^.ModuleInfo.pPath , size:= ModuleCfg.PathLen) = 0) then
      // already in buffer => leave function
      return;
    end_if;
    while pHelp^.pNext <> NIL do
      // if searched path has been found, we already got this module in our list
      if (ModuleCfg.PathLen = pHelp^.ModuleInfo.PathLen) & (ToStdLib.MemCmp(dest:= ModuleCfg.pPath, source:= pHelp^.ModuleInfo.pPath , size:= ModuleCfg.PathLen) = 0) then
        // already in buffer => leave function
        return;
      else
        pHelp := pHelp^.pNext;
      end_if;
    end_while;
    
    // if searched path has been found, we already got this module in our list
    if (ModuleCfg.PathLen = pHelp^.ModuleInfo.PathLen) & (ToStdLib.MemCmp(dest:= ModuleCfg.pPath, source:= pHelp^.ModuleInfo.pPath , size:= ModuleCfg.PathLen) = 0) then
      // already in buffer => leave function
      return;
    else
      pHelp^.pNext$pvoid := ToStdLib.Malloc(size:=sizeof(t_ModuleListElem));
      pHelp := pHelp^.pNext;
    end_if;
  end_if;
  
  if pHelp <> NIL then
    // allocate memory for the module path
    pHelp^.ModuleInfo.pPath$pVoid := ToStdLib.Malloc(size:=ModuleCfg.PathLen);
    if pHelp^.ModuleInfo.pPath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);
      retcode := -1;
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.ModuleInfo.pPath, ptr2:=ModuleCfg.pPath, cntr:=ModuleCfg.PathLen);

    // allocate memory for the module path
    pHelp^.ModuleInfo.pCompPath$pVoid := ToStdLib.Malloc(size:=ModuleCfg.CompPathLen);
    if pHelp^.ModuleInfo.pCompPath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);

      retcode := -1;
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.ModuleInfo.pCompPath, ptr2:=ModuleCfg.pCompPath, cntr:=ModuleCfg.CompPathLen);

    pHelp^.ModuleInfo.Info        := ModuleCfg.Info;
    pHelp^.ModuleInfo.SafetyNbr   := ModuleCfg.SafetyNbr;
    pHelp^.ModuleInfo.InterfaceCRC:= ModuleCfg.InterfaceCRC;
    pHelp^.ModuleInfo.DestCRCNo   := ModuleCfg.DestCRCNo;
    phelp^.ModuleInfo.pDestCRCs   := ModuleCfg.pDestCRCs;
    pHelp^.ModuleInfo.PathLen     := ModuleCfg.PathLen;
    pHelp^.ModuleInfo.CompPathLen := ModuleCfg.CompPathLen;
    pHelp^.ModuleInfo.PdoOutLen   := ModuleCfg.PdoOutLen;
    
    pHelp^.pNext                  := NIL;
    
    ModuleCfgNo += 1;
  else
    SetSafetyState(NewState:=_MemAllocFailed);
    retcode := -1;
    return;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::AddPdoToCfg
	VAR_INPUT
		PdoCfg 	: t_PdoCfg;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pHelp : ^t_PdoListElem;
  END_VAR

  retcode := 0;

  if pFirstPdoCfg = NIL then
    pFirstPdoCfg$pVoid := ToStdLib.Malloc(size:=sizeof(t_PdoListElem));
    pHelp := pFirstPdoCfg;
  else
    pHelp := pFirstPdoCfg;
    // if searched path has been found, we already got this pdo in our list
    if (PdoCfg.SourcePathLen = pHelp^.PdoInfo.SourcePathLen) & (PdoCfg.DestPathLen = pHelp^.PdoInfo.DestPathLen) &
      (PdoCfg.InterfaceCRC = pHelp^.PdoInfo.InterfaceCRC) &
      (ToStdLib.MemCmp(dest:= PdoCfg.pSourcePath, source:= pHelp^.PdoInfo.pSourcePath , size:= PdoCfg.SourcePathLen) = 0) &
      (ToStdLib.MemCmp(dest:= PdoCfg.pDestPath,   source:= pHelp^.PdoInfo.pDestPath   , size:= PdoCfg.DestPathLen  ) = 0) then
      // already in buffer => leave function
      return;
    end_if;
    while pHelp^.pNext <> NIL do
      // if searched path has been found, we already got this pdo in our list
      if (PdoCfg.SourcePathLen = pHelp^.PdoInfo.SourcePathLen) & (PdoCfg.DestPathLen = pHelp^.PdoInfo.DestPathLen) &
        (PdoCfg.InterfaceCRC = pHelp^.PdoInfo.InterfaceCRC) &
        (ToStdLib.MemCmp(dest:= PdoCfg.pSourcePath, source:= pHelp^.PdoInfo.pSourcePath , size:= PdoCfg.SourcePathLen) = 0) &
        (ToStdLib.MemCmp(dest:= PdoCfg.pDestPath,   source:= pHelp^.PdoInfo.pDestPath   , size:= PdoCfg.DestPathLen  ) = 0) then
        // already in buffer => leave function
        return;
      else
        pHelp := pHelp^.pNext;
      end_if;
    end_while;
    
    // if searched path has been found, we already got this pdo in our list
    if (PdoCfg.SourcePathLen = pHelp^.PdoInfo.SourcePathLen) & (PdoCfg.DestPathLen = pHelp^.PdoInfo.DestPathLen) &
      (PdoCfg.InterfaceCRC = pHelp^.PdoInfo.InterfaceCRC) &
      (ToStdLib.MemCmp(dest:= PdoCfg.pSourcePath, source:= pHelp^.PdoInfo.pSourcePath , size:= PdoCfg.SourcePathLen) = 0) &
      (ToStdLib.MemCmp(dest:= PdoCfg.pDestPath,   source:= pHelp^.PdoInfo.pDestPath   , size:= PdoCfg.DestPathLen  ) = 0) then
      // already in buffer => leave function
      return;
    else
      pHelp^.pNext$pvoid := ToStdLib.Malloc(size:=sizeof(t_PdoListElem));
      pHelp := pHelp^.pNext;
    end_if;
  end_if;
  
  if pHelp <> NIL then
    // allocate memory for the module source path
    pHelp^.PdoInfo.pSourcePath$pVoid := ToStdLib.Malloc(size:=PdoCfg.SourcePathLen);
    if pHelp^.PdoInfo.pSourcePath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);
      retcode := -1;
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.PdoInfo.pSourcePath, ptr2:=PdoCfg.pSourcePath, cntr:=PdoCfg.SourcePathLen);

    // allocate memory for the module source path
    pHelp^.PdoInfo.pDestPath$pVoid := ToStdLib.Malloc(size:=PdoCfg.DestPathLen);
    if pHelp^.PdoInfo.pDestPath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);
      retcode := -1;
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.PdoInfo.pDestPath, ptr2:=PdoCfg.pDestPath, cntr:=PdoCfg.DestPathLen);

    pHelp^.PdoInfo.Info           := PdoCfg.Info;
    pHelp^.PdoInfo.InterfaceCRC   := PdoCfg.InterfaceCRC;
    pHelp^.PdoInfo.SourcePathLen  := PdoCfg.SourcePathLen;
    pHelp^.PdoInfo.DestPathLen    := PdoCfg.DestPathLen;
    // length is only zero for non-interface pdos
    if PdoCfg.Info.IsInterfacePDO = FALSE then
      pHelp^.PdoInfo.PdoLen       := 0;   // the length is determined later in method CreateAndSendCfg
    else
      pHelp^.PdoInfo.PdoLen       := PdoCfg.PdoLen;
    end_if;
    pHelp^.PdoInfo.PDO_ID         := 255; // the ID is assigned later by the safety manager of the master domain
    pHelp^.pNext                  := NIL;

    PdoCfgNo += 1;
  else
    SetSafetyState(NewState:=_MemAllocFailed);
    retcode := -1;
    return;
  end_if;
  
END_FUNCTION




FUNCTION VIRTUAL SafetyBase::AddSlaveToCfg
	VAR_INPUT
		pModule 	: ^PathInfoType;
		b_IsOptional 	: BOOL;
		b_IsInterface 	: BOOL;
		InterfaceCRC 	: HDINT;
	END_VAR
  VAR
    pHelp : ^t_SlaveListElem;
  END_VAR

  if pFirstSlaveCfg = NIL then
    pFirstSlaveCfg$pVoid := ToStdLib.Malloc(size:=sizeof(t_SlaveListElem));
    pHelp := pFirstSlaveCfg;
  else
    pHelp := pFirstSlaveCfg;
    while pHelp^.pNext <> NIL do
      //if searched path is found, we already got this module in our list
      if (pModule^.ui_PathCompLen = pHelp^.SlaveInfo.CompPathLen) &
        (ToStdLib.MemCmp(dest:= pModule^.p_us_PathComp, source:= pHelp^.SlaveInfo.pCompPath , size:= pModule^.ui_PathCompLen) = 0) then
        // already in buffer => leave function
        return;
      else
        pHelp := pHelp^.pNext;
      end_if;
    end_while;

    //if searched path is found, we already got this module in our list
    if (pModule^.ui_PathCompLen = pHelp^.SlaveInfo.CompPathLen) &
      (ToStdLib.MemCmp(dest:= pModule^.p_us_PathComp, source:= pHelp^.SlaveInfo.pCompPath , size:= pModule^.ui_PathCompLen) = 0) then
      // already in buffer => leave function
      return;
    end_if;
    
    pHelp^.pNext$pvoid := ToStdLib.Malloc(size:=sizeof(t_SlaveListElem));
    pHelp := pHelp^.pNext;
  end_if;
  
  if pHelp <> NIL then
    // allocate memory for the module path
    pHelp^.SlaveInfo.PathLen := pModule^.p_us_Path^$UINT + 2;
    pHelp^.SlaveInfo.pPath$pVoid := ToStdLib.Malloc(size:=pHelp^.SlaveInfo.PathLen);
    if pHelp^.SlaveInfo.pPath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);
      LogError("AddSlaveToCfg Error: Failed to allocate memory for the module path");
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.SlaveInfo.pPath, ptr2:=pModule^.p_us_Path, cntr:=pHelp^.SlaveInfo.PathLen);

    // allocate memory for the module path
    pHelp^.SlaveInfo.CompPathLen := pModule^.ui_PathCompLen;
    pHelp^.SlaveInfo.pCompPath$pVoid := ToStdLib.Malloc(size:=pHelp^.SlaveInfo.CompPathLen);
    if pHelp^.SlaveInfo.pCompPath = NIL then
      SetSafetyState(NewState:=_MemAllocFailed);
      LogError("AddSlaveToCfg Error: Failed to allocate memory for the compressed module path");
      return;
    end_if;

    _memcpy(ptr1:=pHelp^.SlaveInfo.pCompPath, ptr2:=pModule^.p_us_PathComp, cntr:=pHelp^.SlaveInfo.CompPathLen);

    pHelp^.SlaveInfo.Info             := 0;
    pHelp^.SlaveInfo.Info.IsOptional  := b_IsOptional;
    pHelp^.SlaveInfo.Info.IsInterface := b_IsInterface;

    pHelp^.SlaveInfo.InterfaceCRC := InterfaceCRC;

    pHelp^.pNext                  := NIL;
    
    SlaveCfgNo += 1;
  else
    SetSafetyState(NewState:=_MemAllocFailed);
    LogError("AddSlaveToCfg Error: Failed to allocate memory for the new list-element");
    return;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL SafetyBase::FreeCfgLists
  VAR
    pHelpModule : ^t_ModuleListElem;
    pHelpPdo : ^t_PdoListElem;
    pHelpSlave : ^t_SlaveListElem;
//    pHelpUnsafeVar : ^t_UnsafeVarListElem;
  END_VAR

  // while we got module cfgs 
  while pFirstModuleCfg do
    pHelpModule := pFirstModuleCfg;
    pFirstModuleCfg := pFirstModuleCfg^.pNext;
    
    if pHelpModule^.ModuleInfo.pDestCRCs then
      ToStdLib.Free(pHelpModule^.ModuleInfo.pDestCRCs);
    end_if;
    ToStdLib.Free(pHelpModule^.ModuleInfo.pPath);
    ToStdLib.Free(pHelpModule^.ModuleInfo.pCompPath);
    ToStdLib.Free(pHelpModule);
  end_while;
  pFirstModuleCfg := NIL;
  ModuleCfgNo := 0;

  // while we got pdo cfgs
  while pFirstPdoCfg do
    pHelpPdo := pFirstPdoCfg;
    pFirstPdoCfg := pFirstPdoCfg^.pNext;
    
    ToStdLib.Free(pHelpPdo^.PdoInfo.pSourcePath);
    ToStdLib.Free(pHelpPdo^.PdoInfo.pDestPath);
    ToStdLib.Free(pHelpPdo);
  end_while;
  pFirstPdoCfg := NIL;
  PdoCfgNo := 0;

  // while we got slave cfgs 
  while pFirstSlaveCfg do
    pHelpSlave := pFirstSlaveCfg;
    pFirstSlaveCfg := pFirstSlaveCfg^.pNext;
    
    ToStdLib.Free(pHelpSlave^.SlaveInfo.pPath);
    ToStdLib.Free(pHelpSlave^.SlaveInfo.pCompPath);
    ToStdLib.Free(pHelpSlave);
  end_while;
  pFirstSlaveCfg := NIL;
  SlaveCfgNo := 0;

// memory is freed by safety manager
//  // while we got unsafevar cfgs
//  while pFirstUnsafeCfg do
//    pHelpUnsafeVar := pFirstUnsafeCfg;
//    pFirstUnsafeCfg := pFirstUnsafeCfg^.pNext;
//    
//    ToStdLib.Free(pHelpUnsafeVar^.UnsafeVarInfo.pName);
//    ToStdLib.Free(pHelpUnsafeVar);
//  end_while;
//  pFirstUnsafeCfg := NIL;
//  UnsafeCfgNo := 0;
  
  // reduze size of config mem used to 4 (only safety number of cpu module)
  ConfigMemSizeUsed := 4;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::CreateAndSendCfg
  VAR
    pHelpModule : ^t_ModuleListElem;
    pHelpPdo : ^t_PdoListElem;
    pHelpSlave : ^t_SlaveListElem;
    pCfg : ^void;
    TmpPathLen : UINT;
		MyPara 	  : CmdStruct;
		MyResult	: results;
    AddConfigSize : UDINT;
  END_VAR

(*
    Memory structure:
      4 Byte: SafetyNumber of CPU (is already there from initialisation in CSCP011_IM::InitSafeModule)
      1 Byte: Number of module configurations which are following
      for every module configuration (first is always the CPU itself)
        1 Byte: Info
        4 Byte: Interface Frame Source SafetyNumber (0 if it is no source for interface frames)
        4 Byte: Interface Frame CRC
        1 Byte: Number of destination inferface frame CRCs
        x Byte: Destination interface frame CRCs (number * sizeof(HDINT)
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
        1 Byte: PDO out length for this module
      1 Byte: Number of pdo configurations which are following
      for every PDO configuration
        1 Byte: PDO length
        1 Byte: Interface frame info
        4 Byte: Interface CRC
        2 Byte: Length of source hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of source
        2 Byte: Length of destination hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of destination       
      1 Byte: Number of slave configurations which are following
      for every slave configuration
        1 Byte: Info
        4 Byte: InterfaceCRC
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
*)

  // check if there is memory and if the only thing inside is the safety number
  if pConfigMem & (ConfigMemSizeUsed = 4) then
    // insert the safety number
    pConfigMem^$UDINT := SafetyNumber;
  
    // pCfg points to the next memory we have to write to => set it to the memory after the safety number
    pCfg := pConfigMem + ConfigMemSizeUsed;
        
    // add all module configurations to memory
    if pFirstModuleCfg then
      // add number of module configurations to memory (no need to check the memory here, because already 512 bytes are allocated)
      pCfg^$USINT       := ModuleCfgNo;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);

      pHelpModule := pFirstModuleCfg;
      // go through list
      while pHelpModule do
        // add the elements
        
        // check if we have enough memory to add the next module
        AddConfigSize := sizeof(BSINT) + sizeof(HDINT) + sizeof(HDINT) + sizeof(UINT) + pHelpModule^.ModuleInfo.PathLen + sizeof(UINT) + pHelpModule^.ModuleInfo.CompPathLen + sizeof(USINT);
        if pHelpModule^.ModuleInfo.Info.IsInterfaceDest then
          AddConfigSize += sizeof(USINT) + pHelpModule^.ModuleInfo.DestCRCNo * sizeof(HDINT);
        end_if;

        pCfg := CheckConfigMemSize(AddConfigSize);
        if pCfg = NIL then
          // error message already logged by function
          return;
        end_if;

        // info
        pCfg^$BSINT := pHelpModule^.ModuleInfo.Info;
        pCfg              += sizeof(BSINT);
        ConfigMemSizeUsed += sizeof(BSINT);

        // safety number of interface frame source (if it is one)
        pCfg^$HDINT := pHelpModule^.ModuleInfo.SafetyNbr;
        pCfg              += sizeof(HDINT);
        ConfigMemSizeUsed += sizeof(HDINT);

        // interface CRC of interface frame
        pCfg^$HDINT := pHelpModule^.ModuleInfo.InterfaceCRC;
        pCfg              += sizeof(HDINT);
        ConfigMemSizeUsed += sizeof(HDINT);

        // if its also interface frame destination send the corresponding interface CRCs
        if pHelpModule^.ModuleInfo.Info.IsInterfaceDest then
          TmpPathLen := pHelpModule^.ModuleInfo.DestCRCNo; // save some time with this local variable
          pCfg^$USINT := TmpPathLen$USINT;
          pCfg              += sizeof(USINT);
          ConfigMemSizeUsed += sizeof(USINT);
       
          _memcpy(ptr1:=pCfg, ptr2:=pHelpModule^.ModuleInfo.pDestCRCs, cntr:=TmpPathLen * sizeof(HDINT));
          pCfg += TmpPathLen * sizeof(HDINT);
          ConfigMemSizeUsed += TmpPathLen * sizeof(HDINT);
        end_if;

        // uncompressed module path
        TmpPathLen := pHelpModule^.ModuleInfo.PathLen; // save some time with this local variable
        pCfg^$UINT := TmpPathLen;
        pCfg              += sizeof(UINT);
        ConfigMemSizeUsed += sizeof(UINT);
      
        _memcpy(ptr1:=pCfg, ptr2:=pHelpModule^.ModuleInfo.pPath, cntr:=TmpPathLen);
        pCfg += TmpPathLen;
        ConfigMemSizeUsed += TmpPathLen;

        // compressed module path
        TmpPathLen := pHelpModule^.ModuleInfo.CompPathLen; // save some time with this local variable
        pCfg^$UINT := TmpPathLen;
        pCfg              += sizeof(UINT);
        ConfigMemSizeUsed += sizeof(UINT);
      
        _memcpy(ptr1:=pCfg, ptr2:=pHelpModule^.ModuleInfo.pCompPath, cntr:=TmpPathLen);
        pCfg += TmpPathLen;
        ConfigMemSizeUsed += TmpPathLen;
      
        // PDO out length for this module (to assign the length to the pdo configurations)
        pCfg^$USINT := pHelpModule^.ModuleInfo.PdoOutLen;
        pCfg              += sizeof(USINT);
        ConfigMemSizeUsed += sizeof(USINT);
      
        pHelpModule := pHelpModule^.pNext;
      end_while;

      pCfg := CheckConfigMemSize(sizeof(USINT));
      if pCfg = NIL then
        // error message already logged by function
        return;
      end_if;

      // add number of pdo configurations to memory
      pCfg^$USINT := PdoCfgNo;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);

      // add all pdo configurations to memory (module configs must be available, to find out the PDO length)
      if pFirstPdoCfg then
        pHelpPdo := pFirstPdoCfg;
        // go through list
        while pHelpPdo do
          // add the elements

          // check if we have enough memory to add the next module
          AddConfigSize := sizeof(USINT) + sizeof(BSINT) + sizeof(HDINT) + sizeof(UINT) + pHelpPdo^.PdoInfo.SourcePathLen + sizeof(UINT) + pHelpPdo^.PdoInfo.DestPathLen;
          pCfg := CheckConfigMemSize(AddConfigSize);
          if pCfg = NIL then
            // error message already logged by function
            return;
          end_if;

          // first of all we have to find out the pdo length of this element => search the module configurations until we find our source and copy the pdo length
          if pHelpPdo^.PdoInfo.PdoLen = 0 then
            pHelpModule := pFirstModuleCfg;
            // go through list
            while pHelpModule do
              // if the path of the source module matches, save the pdolength of this module
              if (pHelpPdo^.PdoInfo.SourcePathLen = pHelpModule^.ModuleInfo.PathLen) & (ToStdLib.MemCmp(dest:= pHelpPdo^.PdoInfo.pSourcePath, source:= pHelpModule^.ModuleInfo.pPath , size:= pHelpPdo^.PdoInfo.SourcePathLen) = 0) then
                pHelpPdo^.PdoInfo.PdoLen := pHelpModule^.ModuleInfo.PdoOutLen;
                exit;
              end_if;
              pHelpModule := pHelpModule^.pNext;
            end_while;
          end_if;

          
          // PDO Length
          pCfg^$USINT := pHelpPdo^.PdoInfo.PdoLen;
          pCfg              += sizeof(USINT);
          ConfigMemSizeUsed += sizeof(USINT);

          // info
          pCfg^$BSINT := pHelpPdo^.PdoInfo.Info;
          pCfg              += sizeof(BSINT);
          ConfigMemSizeUsed += sizeof(BSINT);

          // interface CRC
          pCfg^$HDINT := pHelpPdo^.PdoInfo.InterfaceCRC;
          pCfg              += sizeof(HDINT);
          ConfigMemSizeUsed += sizeof(HDINT);

          // Source Path Length
          TmpPathLen := pHelpPdo^.PdoInfo.SourcePathLen; // save some time with this local variable
          pCfg^$UINT := TmpPathLen;
          pCfg              += sizeof(UINT);
          ConfigMemSizeUsed += sizeof(UINT);
        
          // Source Path
          _memcpy(ptr1:=pCfg, ptr2:=pHelpPdo^.PdoInfo.pSourcePath, cntr:=TmpPathLen);
          pCfg += TmpPathLen;
          ConfigMemSizeUsed += TmpPathLen;

          // Destination Path Length
          TmpPathLen := pHelpPdo^.PdoInfo.DestPathLen; // save some time with this local variable
          pCfg^$UINT := TmpPathLen;
          pCfg              += sizeof(UINT);
          ConfigMemSizeUsed += sizeof(UINT);
        
          // Destination Path
          _memcpy(ptr1:=pCfg, ptr2:=pHelpPdo^.PdoInfo.pDestPath, cntr:=TmpPathLen);
          pCfg += TmpPathLen;
          ConfigMemSizeUsed += TmpPathLen;
        
          pHelpPdo := pHelpPdo^.pNext;
        end_while;
      end_if;

      pCfg := CheckConfigMemSize(sizeof(USINT));
      if pCfg = NIL then
        // error message already logged by function
        return;
      end_if;

      // add number of slave configurations to memory
      pCfg^$USINT       := SlaveCfgNo;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);

      pHelpSlave := pFirstSlaveCfg;
      // go through list
      while pHelpSlave do
        // add the elements
        
        // check if we have enough memory to add the next module
        AddConfigSize := sizeof(BSINT) + sizeof(HDINT) + sizeof(UINT) + pHelpSlave^.SlaveInfo.PathLen + sizeof(UINT) + pHelpSlave^.SlaveInfo.CompPathLen;

        pCfg := CheckConfigMemSize(AddConfigSize);
        if pCfg = NIL then
          // error message already logged by function
          return;
        end_if;

        // info
        pCfg^$BSINT := pHelpSlave^.SlaveInfo.Info;
        pCfg              += sizeof(BSINT);
        ConfigMemSizeUsed += sizeof(BSINT);

        // InterfaceCRC
        pCfg^$HDINT := pHelpSlave^.SlaveInfo.InterfaceCRC;
        pCfg              += sizeof(HDINT);
        ConfigMemSizeUsed += sizeof(HDINT);

        // uncompressed Slave path
        TmpPathLen := pHelpSlave^.SlaveInfo.PathLen; // save some time with this local variable
        pCfg^$UINT := TmpPathLen;
        pCfg              += sizeof(UINT);
        ConfigMemSizeUsed += sizeof(UINT);
      
        _memcpy(ptr1:=pCfg, ptr2:=pHelpSlave^.SlaveInfo.pPath, cntr:=TmpPathLen);
        pCfg += TmpPathLen;
        ConfigMemSizeUsed += TmpPathLen;

        // compressed Slave path
        TmpPathLen := pHelpSlave^.SlaveInfo.CompPathLen; // save some time with this local variable
        pCfg^$UINT := TmpPathLen;
        pCfg              += sizeof(UINT);
        ConfigMemSizeUsed += sizeof(UINT);
      
        _memcpy(ptr1:=pCfg, ptr2:=pHelpSlave^.SlaveInfo.pCompPath, cntr:=TmpPathLen);
        pCfg += TmpPathLen;
        ConfigMemSizeUsed += TmpPathLen;
      
        pHelpSlave := pHelpSlave^.pNext;
      end_while;

    else
      // add number of module, pdo and slave configurations to memory (all as 0)
      
      // no module configs
      pCfg^$USINT := 0;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);

      // no pdo configs
      pCfg^$USINT := 0;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);

      // no slave configs
      pCfg^$USINT := 0;
      pCfg              += sizeof(USINT);
      ConfigMemSizeUsed += sizeof(USINT);
    end_if;    

    MyPara.uiCmd := CMD_SM_CPU_CFG_TO_MANAGER;
    MyPara.aPara[0] := ConfigMemSizeUsed$DINT;
    MyPara.aPara[1] := pConfigMem$DINT;
    if pSafetyManagerThis^.NewInst(#MyPara, #MyResult) = READY then
      // the manager takes care of our memory from now on
      pFirstSlaveCfg := NIL;
    end_if;
    
    // now tell the manager, what kind of configuration we have
    MyPara.uiCmd := CMD_SM_NEW_CFG_TYPE;
    MyPara.aPara[0] := SafetyNumber$DINT;
    MyPara.aPara[1] := NewConfigType;
    pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
  else
    LogError("(SafetyBase::CreateAndSendCfg) No config memory or invalid memory size usage");
  end_if;

END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL SafetyBase::CheckVariant
	VAR_INPUT
		us_ActVariant 	: USINT;
	END_VAR
	VAR_OUTPUT
		b_IsOK 	: BOOL;
	END_VAR

  // if the overwritten methods are getting deleted, we already have a code for compatiblity here
  b_IsOK := TRUE; // FALSE;

END_FUNCTION
#pragma warning(default: 73)


FUNCTION SafetyBase::SendAllUnsafeValues
  VAR
  	pHelpUnsafeOut : ^UnsafeIORoutingElement;
  END_VAR

  // mark all unsafe values as not sent
  pHelpUnsafeOut := p_UnsafeInputsTable;
  while pHelpUnsafeOut do
    pHelpUnsafeOut^.b_AlreadyTransmitted := FALSE;
    
    pHelpUnsafeOut := pHelpUnsafeOut^.pNext;
  end_while;
  
  // reset the actual pointer
  pUnsafeInElement := NIL;

END_FUNCTION


FUNCTION SafetyBase::GetDestinationCRCs
  VAR
    pHelpModule : ^t_ModuleListElem;
    pHelpPdo : ^t_PdoListElem;
  END_VAR

  // go through the module list
  pHelpModule := pFirstModuleCfg;
  while pHelpModule do
    pHelpPdo := pFirstPdoCfg;
    while pHelpPdo do
      // search in the PDOs if this module is an interface frame destination somewhere
      if pHelpPdo^.PdoInfo.Info.IsInterfacePDO then 
        if (pHelpPdo^.PdoInfo.DestPathLen = pHelpModule^.ModuleInfo.PathLen) &
         (ToStdLib.MemCmp(dest:= pHelpModule^.ModuleInfo.pPath, source:= pHelpPdo^.PdoInfo.pDestPath , size:= pHelpModule^.ModuleInfo.PathLen) = 0) then
          pHelpModule^.ModuleInfo.Info.IsInterfaceDest := TRUE;
          if pHelpModule^.ModuleInfo.DestCRCNo & pHelpModule^.ModuleInfo.pDestCRCs then
            pHelpModule^.ModuleInfo.pDestCRCs$^void := ToStdLib.ReAlloc(mptr:=pHelpModule^.ModuleInfo.pDestCRCs, newsize:=(pHelpModule^.ModuleInfo.DestCRCNo+1) * sizeof(HDINT));
          else
            pHelpModule^.ModuleInfo.pDestCRCs$^void := ToStdLib.Malloc(sizeof(HDINT));
          end_if;
          
          (pHelpModule^.ModuleInfo.pDestCRCs + pHelpModule^.ModuleInfo.DestCRCNo * sizeof(HDINT))^ := pHelpPdo^.PdoInfo.InterfaceCRC;
          
          pHelpModule^.ModuleInfo.DestCRCNo += 1;
        end_if;
      else
        // if this is module is optional and it's the source of the PDO => the pdo is also optional
        if pHelpModule^.ModuleInfo.Info.IsOptional & (pHelpPdo^.PdoInfo.SourcePathLen = pHelpModule^.ModuleInfo.PathLen) &
         (ToStdLib.MemCmp(dest:= pHelpModule^.ModuleInfo.pPath, source:= pHelpPdo^.PdoInfo.pSourcePath , size:= pHelpModule^.ModuleInfo.PathLen) = 0) then
          pHelpPdo^.PdoInfo.Info.IsOptional := TRUE;
        end_if;
      end_if;
          
      pHelpPdo := pHelpPdo^.pNext;
    end_while;
  
    pHelpModule := pHelpModule^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyBase::CountBits
	VAR_INPUT
		BitMask 	: BDINT;
	END_VAR
	VAR_OUTPUT
		BitNo 	: UDINT;
	END_VAR
  
  BitNo := 0;
  
  while BitMask do
    BitMask := BitMask AND (BitMask - 1);
    BitNo += 1;
  end_while;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::IsOptimizedCPU
	VAR_OUTPUT
		IsOptimized 	: DINT;
	END_VAR

  // every derivation of this class is an optimized cpu, which means the SB_SDO_COMMAND_WRITE_VALUES command is available to save time in communication of unsafe variables
  IsOptimized := TRUE;
  
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::CheckConfigMemSize
	VAR_INPUT
		AddConfigSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pCfg 	: ^void;
	END_VAR
  VAR
  	pTempMem  : ^void;
  END_VAR

  pCfg := NIL;
  
  if ((ConfigMemSizeUsed + AddConfigSize) > ConfigMemSize) & (AddConfigSize <= SB_CONFIG_MEMORY_BLOCK_SIZE) then
    // if there isn't enough memory => reallocate
    pTempMem := ToStdLib.ReAlloc(mptr:=pConfigMem, newsize:=ConfigMemSize + SB_CONFIG_MEMORY_BLOCK_SIZE);
    IF pTempMem <> NIL THEN
      pConfigMem := pTempMem;
      ConfigMemSize += SB_CONFIG_MEMORY_BLOCK_SIZE;
    ELSE
      SetSafetyState(NewState:=_MemAllocFailed);
      LogError("(SafetyBase::CreateAndSendCfg) Failed to reallocate configuration memory!");
      return;
    END_IF;
  elsif (AddConfigSize > SB_CONFIG_MEMORY_BLOCK_SIZE) then
    SetSafetyState(NewState:=_MemAllocFailed);
    LogError("(SafetyBase::CreateAndSendCfg) The configuration of a single config element is too big to handle!");          
    return;
  end_if;

  pCfg := pConfigMem + ConfigMemSizeUsed;
          
END_FUNCTION


FUNCTION SafetyBase::DToH
	VAR_INPUT
		pt 	: ^CHAR;
		value 	: DINT;
	END_VAR
  VAR
    val  : UDINT;
  END_VAR

  // this method converts a single byte into a zero-terminated hexstring like 0xA4 => "A4"
  val := value$UDINT;

  // zero termination
  (pt + 2)^ := 0;

  // start with the low nibble
  if (val AND 16#F) < 10 then
    (pt + 1)^ := (val AND 16#F)$USINT + '0';
  else
    (pt + 1)^ := (val AND 16#F)$USINT - 10 + 'A';
  end_if;

  // now get the high nibble
  val := val / 16;

  if (val AND 16#F) < 10 then
    pt^ := (val AND 16#F)$USINT + '0';
  else
    pt^ := (val AND 16#F)$USINT - 10 + 'A';
  end_if;
  
END_FUNCTION


FUNCTION SafetyBase::LogHWPath
	VAR_INPUT
		pString 	: ^CHAR;
		pHWPath 	: ^USINT;
	END_VAR
  VAR
    TempStr       : ARRAY [0..99] OF CHAR;
    TraceVal      : USINT;
    i             : UINT;
  END_VAR

  if pString & pHWPath then
  
    TraceVal := pHWPath^;
    if TraceVal then
      TraceVal += 2; //show also the length
      i := 0;
      while (TraceVal >= 1) & (i < 95) do
        DToH(#TempStr[i], pHWPath^$USINT);
        i += 2; // 2 chars per byte
        TempStr[i] := ' ';
        i += 1;
        pHWPath += 1;
        TraceVal -= 1;
      end_while;
      TempStr[i] := 0;

      MyTrace(pFormat:=pString, pTxt0:=#TempStr[0], pTxt1:=NIL, pTxt2:=NIL);
    else
      MyTrace(pFormat:=pString, pTxt0:=NIL, pTxt1:=NIL, pTxt2:=NIL);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SafetyBase::QuitComError::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

 	result := input;

  if b_QuitErrorAvailable then
    // remember to do it in next background
    QuitComError := 2;
  else
    // remember. that there has been a manual quit (for writing PDOs in PostScan)
    b_ManualQuit := TRUE;
    
    // remember to do it in next cyclic
    QuitComError := 1;
  end_if;

  // refresh the server on the outer object
  RefreshAsySrv();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::ClassSvr::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	OldClassState : SafetyConfigStateType;
    pPDOInputBuffer : ^PDOInputBuffer;
    i, j : UINT;
    Found : BOOL;
    sd_retval : DINT;
	  GetStateResp   : GetStateResponseType;
  END_VAR

	ret_code := READY;

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		CMD_SM_SET_NEW_SYNC_MODE:
    
      b_NewSyncMode := pPara^.aPara[0]$BOOL; //TRUE;
    
      if b_NewSyncMode then
        NewHandShakeValue := 2#001;
      end_if;
            
//**********************************************************************************************************************************************************
    CMD_SM_START_TIME_SYNC:

      // set bit for starting timesync at the module (bit 2#100 is set later additionally so the firmware can detect our cycle time)
      NewHandShakeValue := 2#011;
      
      b_TimeSyncActive := TRUE;

//**********************************************************************************************************************************************************
    CMD_SM_INIT_FINISHED:
      // the safety manager has finished his administration work (e.g. connecting the domains)
      b_ManagerInitialisationFinished := TRUE;
      
      // optional modules may not be available
      ud_OptionalTimeoutStart := ops.tAbsolute;
      
//**********************************************************************************************************************************************************
    CMD_SM_FIRST_CONNECT_READY:
      // the safety manager has finished first time connecting the domains
      b_ManagerReadyForSDO := TRUE;

//**********************************************************************************************************************************************************
    CMD_SM_DISCONNECT:
      b_ManagerInitialisationFinished := FALSE;
      b_ManagerReadyForSDO := FALSE;

      // wait again to send bus ready signal
      if SafetyState <> _ReinitConfig then
        SetSafetyState(NewState:=_WaitForSynchronicity);
      end_if;
      UnsafeScheduler := UnsafeSchedulerSetBusReady;      
      us_SetBusReadyState := WaitPDOsSyncron;

//**********************************************************************************************************************************************************
    CMD_SM_SDO_TO_MODULE:
#ifdef DO_DEBUG
      DOCheck(pFrame:=(pPara^.aPara[1])$^t_SDOStdHeader, pCheckStruct:=#SDOWrite);
#endif

      AddSDOToBuffer(p_us_Message := pPara^.aPara[1]$^USINT, us_length := pPara^.aPara[0]$USINT);
      
//**********************************************************************************************************************************************************
    CMD_SM_TDO_TO_MODULE:
      WriteTDO2Module(pTDO:=(pPara^.aPara[1])$^TDOType);
           
//**********************************************************************************************************************************************************
    CMD_SM_GET_SAFETY_NUMBER:
      // check if pointer is valid
      if pPara^.aPara[0] then
        ((pPara^.aPara[0])$^UDINT)^ := SafetyNumber;
      end_if;
//**********************************************************************************************************************************************************
    CMD_SM_ADD_INPUT_PDO:
      AddPDOToInputBuffer(ud_p2Buffer         := pPara^.aPara[0]$UDINT
                        , ud_HandleSourceDO   := pPara^.aPara[5]$UDINT
                        , ud_MoveSourceAddr   := pPara^.aPara[1]$UDINT
                        , ud_MoveSourceOffset := pPara^.aPara[6]$UDINT
                        , ud_SafetyNr         := pPara^.aPara[2]$UDINT
                        , b_IsOptional        := pPara^.aPara[4]$BOOL
                        , us_PdoLen           := pPara^.aPara[3]$USINT);

//**********************************************************************************************************************************************************
    CMD_SM_ADD_OUTPUT_PDO:      
      // if it's an interface frame, we return the pointer to the second PDO frame which is the interface pdo frame
      if pPara^.aPara[0] = 1 then
        // skip the first PDO
        pResult^.aData[0]$UDINT := GetPointer2IFPDOBuffer();    // pointer to local memory
        pResult^.aData[4]$UDINT := ud_LocalMoveIFSourceAddr;    // pointer to DPRAM
        pResult^.aData[8]$UDINT := ud_LocalIFReadHandle;        // handle for varan access
        pResult^.aData[12]$UDINT:= ud_LocalIFReadOffset;        // offset inside the varan data
      else
        // otherwise just get the pointer to the PDO read data
        pResult^.aData[0]$UDINT := GetPointer2PDOBuffer();      // pointer to local memory
        pResult^.aData[4]$UDINT := ud_LocalMoveSourceAddr;      // pointer to DPRAM
        pResult^.aData[8]$UDINT := ud_LocalReadHandle;          // handle for varan access
        pResult^.aData[12]$UDINT:= ud_LocalReadOffset;          // offset insid the varan data
      end_if;

      pResult^.uiLng := 16;
      
//**********************************************************************************************************************************************************
    CMD_SM_REMOVE_INPUT_PDO:
      // we lost connection to other systems => we have to initialize again! remove old input PDOs
      
      if ui_cnt_PDOInputBuffer then
        // save the old state of the class and set it temporarily to "module not found" to prevent update rt from crashing
        OldClassState := SafetyState;
        SetSafetyState(NewState:=_ModuleNotFound);
        
        // search for the PDO
        Found := FALSE;
        pPDOInputBuffer := #aPDOInputBuffer[0];
        for i := 0 to (ui_cnt_PDOInputBuffer-1) do
          if pPDOInputBuffer^.ud_p2Buffer = pPara^.aPara[0]$UDINT then
            Found := TRUE;
            exit;
          end_if;
          
          pPDOInputBuffer += sizeof(PDOInputBuffer);
        end_for;

        // if we found the PDO => remove it from memory (move the memory behind the found PDO over the place of the found PDO)
        if Found then
          // if it's last entry (no entries have to be moved) => we only have to copy some memory if it's not the last
          if i < (ui_cnt_PDOInputBuffer-1) then
            for j := i to (ui_cnt_PDOInputBuffer-2) do
              aPDOInputBuffer[j] := aPDOInputBuffer[j+1];
            end_for;
          end_if;
          ui_cnt_PDOInputBuffer -= 1;
        else
          LogError("(SafetyBase::State::NewInst) CMD_SM_REMOVE_INPUT_PDO failed! Couldn't find specified PDO!");
        end_if;

        // restore old class state
        SetSafetyState(NewState:=OldClassState);
      else
        LogError("(SafetyBase::State::NewInst) CMD_SM_REMOVE_INPUT_PDO failed! No input PDOs found!");
      end_if;


//*****************************************************************************
//** COMMANDS FROM BUS INTERFACE                                             **
//*****************************************************************************

//**********************************************************************************************************************************************************
    _BUS_IF_HWCONNECT :
      // device has been connected
      ConnectEvent();
      pResult^.aData[0] := _BUS_IF_RETVAL_OK;

//**********************************************************************************************************************************************************
    _BUS_IF_HWDISCONNECT :
      // device has been disconnected
      DisconnectEvent();
      pResult^.aData[0] := _BUS_IF_RETVAL_OK;

//**********************************************************************************************************************************************************
    _BUS_IF_HWINTERRUPT :
      // error at device which may lead to a disconnect or replace the disconnect callback
      InterruptEvent();
      pResult^.aData[0] := _BUS_IF_RETVAL_OK;

//**********************************************************************************************************************************************************
    _BUS_IF_CHECK_DEVICE_ID :
      // check for correct device id
      pResult^.aData[0] := (DeviceID = pPara^.aPara[0]$UDINT);
            
//**********************************************************************************************************************************************************
    _BUS_IF_RESET_DETECTED:
      if SafetyState = _SafetyClassOK then
        SafetyState := _LostPowerSupply;
      end_if;

//**********************************************************************************************************************************************************
    _BUS_IF_RESET_GONE_DETECTED:
      if SafetyState = _LostPowerSupply then
        SafetyState := _SafetyClassOK;
      end_if;

//**********************************************************************************************************************************************************


//*****************************************************************************
//** COMMANDS FROM OTHER SAFETYMODULES                                       **
//*****************************************************************************

//**********************************************************************************************************************************************************
    CMD_SM_ADD_SDO_TO_BUFFER:
      sd_retval := AddSDOToBuffer(p_us_message:=pPara^.aPara[0]$^USINT, us_length:=pPara^.aPara[1]$USINT);
      if sd_retval then
        ret_code := ERROR;
      end_if;
      
      pResult^.aData[0]$DINT := sd_retval;
      
//**********************************************************************************************************************************************************
    CMD_SM_WRITE_TDO_TO_MODULE:
      WriteTDO2Module(pTDO:=pPara^.aPara[0]$^TDOType);

//**********************************************************************************************************************************************************
    CMD_SM_CONFIG_SAFETY_CPU:
      pResult^.aData[0]$UDINT := ConfigSafetyCpu();
      
//**********************************************************************************************************************************************************
    CMD_SM_CONFIG_SAFETY_INPUT:
      pResult^.aData[0]$UDINT := ConfigSafetyInput(ud_SafeNrCPU         := pPara^.aPara[0]$HDINT
                                                 , ud_thisp             := pPara^.aPara[1]$UDINT
                                                 , p_PDOBuffer          := pPara^.aPara[2]$^UDINT
                                                 , pMoveActive          := pPara^.aPara[3]$^PDOMoveState
                                                 , p_ud_HandleSourceDO  := pPara^.aPara[5]$^UDINT
                                                 , p_ud_MoveSourceAddr  := pPara^.aPara[4]$^UDINT
                                                 , p_ud_MoveSourceOffset:= pPara^.aPara[6]$^UDINT
                                                 );

//**********************************************************************************************************************************************************
    CMD_SM_CONFIG_SAFETY_OUTPUT:
      pResult^.aData[0]$UDINT := ConfigSafetyOutput(ud_SafeNrCPU        := pPara^.aPara[0]$HDINT
                                                  , ud_thisp            := pPara^.aPara[1]$UDINT
                                                  , ud_p_PDOBuffer      := pPara^.aPara[2]$UDINT
                                                  , pObject             := pPara^.aPara[3]$^PathInfoType
                                                  , pMoveActive         := pPara^.aPara[4]$^PDOMoveState
                                                  , ud_HandleSourceDO   := pPara^.aPara[7]$UDINT
                                                  , ud_MoveSourceAddr   := pPara^.aPara[5]$UDINT
                                                  , ud_MoveSourceOffset := pPara^.aPara[8]$UDINT
                                                  , b_IsOptional        := pPara^.aPara[6]$BOOL
                                                  );
                                                  
//**********************************************************************************************************************************************************
    CMD_SM_REMOVE_CPU_FROM_TABLE:
      RemoveCPUFromTable(ud_SafetyNr := pPara^.aPara[0]$HDINT);
      
//**********************************************************************************************************************************************************     
    CMD_SM_GET_MODULE_TYPE:
      pResult^.aData[0]$UDINT := SM_TYPE_SAFETY_MODULE;
      
//**********************************************************************************************************************************************************     
    CMD_SM_DEACTIVATE_MOVE_CMD:
      // check if it's for input (1) or output (0)
      if pPara^.aPara[0] then
        b_MoveCommandInputActive  := _Inactive;        
      else
        b_MoveCommandOutputActive := _Inactive;
      end_if;

//**********************************************************************************************************************************************************     
    CMD_SM_POST_INIT_FINISHED:
      Found := FALSE;
      if Online then
        // get configuration if module is configured
        
        // get state via SDO communication
        sd_retval := SDOStdRequ ( us_Command      := SDO_COMMAND_GET_STATE
                                , p_us_RespData   := ( #GetStateResp )$^USINT
                                , us_RespLength   := sizeof(GetStateResponseType)
                                );
        
        // the cpu is configured, load the new configuration
        if ( sd_retval = 0 ) & 
           (GetStateResp.ConfigState <> CFG_STATE_UNKNOWN) &
           (GetStateResp.ConfigState <> CFG_STATE_INVALID) &
           (GetStateResp.ConfigState <> CFG_STATE_NOT_CONFIGURED) then
           
          //get configuration from safe CPU and build routing tables
          GetRoutingData();
          
          Found := TRUE;
        end_if;
      end_if;

      // if we didn't get the config here => try again later
      if ( (Found = FALSE) & 
           (SafetyState = _SafetyClassOK) ) then // Check SafetyState, Otherwise Set Error will be overwritten.
        //get configuration from safe CPU and build routing tables later in background
        b_GetNewConfiguration := FALSE;
        
          // next time we check for the configured state of the cpu
        b_CheckConfigured := TRUE;

        // check again in background
        SetSafetyState(NewState:=_ReinitConfig);
      end_if;
      
//**********************************************************************************************************************************************************
  else
    LogValue(pString:="(SafetyBase::ClassSvr::NewInst): Received invalid command: 0x{0}", Value:=pPara^.uiCmd);
//**********************************************************************************************************************************************************
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	sd_retval         : DINT;
    GetStateResp      : GetStateResponseType;
    LastWriteCounter  : UDINT;
    FileHandle        : DINT;
		MyPara 	          : CmdStruct;
		MyResult	        : results;
  END_VAR

  // if any LED is active, then firmware update is not active and we can do our work
  if (VoltageOK | RunState | ServiceMode | ErrorState) then    

    // if a quit error is pending
    if QuitComError = 2 then
      MyPara.uiCmd := CMD_SM_QUIT_ERROR_VIA_OS;
      MyPara.aPara[0] := THIS$DINT;
      MyPara.aPara[1] := SafetyNumber$DINT;
      pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
  
      QuitComError := MyResult.aData[0]$DINT;

      // refresh the server on the outer object
      RefreshAsySrv();
    end_if;


    if (SafetyState = _ReinitConfig) then
    
      // check every second if the cpu is configured
      if b_CheckConfigured & ((ops.tAbsolute - ud_LastCheckConfig) > 3000) then
        // get state via SDO communication
        sd_retval := SDOStdRequ ( us_Command      := SB_SDO_COMMAND_GET_STATE
                                , p_us_RespData   := ( #GetStateResp )$^USINT
                                , us_RespLength   := sizeof(GetStateResponseType)
                                );
        
        // the cpu is configured, load the new configuration
        if ( sd_retval = 0 ) & 
           (GetStateResp.ConfigState <> SB_CFG_STATE_UNKNOWN) &
           (GetStateResp.ConfigState <> SB_CFG_STATE_INVALID) &
           (GetStateResp.ConfigState <> SB_CFG_STATE_NOT_CONFIGURED) then
           
          b_CheckConfigured := FALSE;
          
          b_GetNewConfiguration := TRUE;
        end_if;
        
        // remember the last time we checked for configurated cpu
        ud_LastCheckConfig := ops.tAbsolute;
      end_if;
        
      // if there is a new configuration => get it
      if b_GetNewConfiguration then
        // get configuration from safe CPU and build routing tables
        sd_retval := GetRoutingData();
        if sd_retval = 0 then
          b_GetNewConfiguration := FALSE;
          
          SendAllUnsafeValues();
        else
          LogError(e_msg:="FAILED TO REINIT THE SAFECPU: ");
        end_if;
      end_if;
    end_if;

    // here we save the log file from the module to the harddrive (started by user)
    if DiagVars.SavingLogInProgress then
    
      case DiagVars.SavingLogSSW of

  // ********************************************************************************************************************************************
        GetLogHeader:     // get log header from module (contains size of log memory and write counter)

          // get log header via SDO communication
          sd_retval := SDORequ ( us_Command      := SB_SDO_COMMAND_GET_LOG_HDR
                               , p_us_RequData   := #DiagVars.ucChoiceSaveLog
                               , us_RequLength   := 1
                               , p_us_RespData   := ( #DiagVars.LogHeader)$^USINT
                               , us_RespLength   := sizeof(DiagStructType.LogHeader)
                               );
          
          if ( sd_retval = 0 ) then
            DiagVars.LogMemToGet := DiagVars.LogHeader.LogMemSize;
            DiagVars.pLogFileMem$pVoid := ToStdLib.Malloc(size:=DiagVars.LogHeader.LogMemSize);
            //_memset(dest:=DiagVars.pLogFileMem$pVoid, usByte:=0, cntr:=DiagVars.LogHeader.LogMemSize);
            if DiagVars.ucChoiceSaveLog = 0 then
              DiagVars.ReadBaseAdr := SB_SDO_ADDRESS_LOG_UC1;
            else
              DiagVars.ReadBaseAdr := SB_SDO_ADDRESS_LOG_UC2;
            end_if;
            DiagVars.SavingLogSSW := GetLogFileBlocks;
            
          end_if;

  // ********************************************************************************************************************************************
        GetLogFileBlocks: // get the log memory from the application memory of the module (every cycle only a little bit to prevent runtime error in module)
          
          // we wait here until UpdateCy finishes our work
        
  // ********************************************************************************************************************************************
        GetLogHeader2:    // get log header from module again. if write counter changed, 
                          // we repeat GetLogFileBlocks. otherwise we continue to save the file
        
          LastWriteCounter := DiagVars.LogHeader.WriteCounter;
        
          // get LogHeader
          sd_retval := SDORequ ( us_Command      := SB_SDO_COMMAND_GET_LOG_HDR
                               , p_us_RequData   := #DiagVars.ucChoiceSaveLog
                               , us_RequLength   := 1
                               , p_us_RespData   := ( #DiagVars.LogHeader)$^USINT
                               , us_RespLength   := sizeof(DiagStructType.LogHeader)
                               );
          
          if ( sd_retval = 0 ) then
          
            // if write counter is different, repeat last step
            if DiagVars.LogHeader.WriteCounter <> LastWriteCounter then
              DiagVars.SavingLogSSW := GetLogFileBlocks;

              DiagVars.LogMemToGet := DiagVars.LogHeader.LogMemSize;
              
              // realloc memory (maybe it's a different size)
              ToStdLib.Free(mptr:=DiagVars.pLogFileMem$pVoid);
              DiagVars.pLogFileMem$pVoid := ToStdLib.Malloc(size:=DiagVars.LogHeader.LogMemSize);
            else
              // write counter is equal. continue to last step
              DiagVars.SavingLogSSW := SaveLogFile;
            end_if;
          end_if;
        
  // ********************************************************************************************************************************************
        SaveLogFile:      // save the memory to the specified file (DPNE)

          // open file (create/overwrite always)
          FileHandle := FileSys.FileOpen(filename:=#DiagVars.DPNE[0], attributes:=ATT_CREATE_ALWAYS);
          
          if FileHandle >= 0 then
            
            // save content to it
            if FileSys.FileWrite(handle:=FileHandle, buffer:=DiagVars.pLogFileMem, length:=DiagVars.LogHeader.LogMemSize) <> DiagVars.LogHeader.LogMemSize$DINT then
              // failed to write to file
              LogError("SafetyBase::MyBackground: Failed to write to binary LogFile");
            end_if;
            
            // close file
            FileSys.FileClose(handle:=FileHandle);
          else
            // failed to open file
            LogError("SafetyBase::MyBackground: Failed to open binary LogFile");
          end_if;
          
          ToStdLib.Free(mptr:=DiagVars.pLogFileMem$pVoid);
          DiagVars.pLogFileMem := NIL;
          
          DiagVars.SavingLogSSW := GetLogHeader;
          DiagVars.SavingLogInProgress := FALSE;
        
      end_case;  
    end_if;
  end_if;
  
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	calloption    : UDINT;
    PDOLength : USINT;
    p_ReceiveObj  : pVirtualBase;
    i : UINT;
    ii : DINT;
		MyPara 	  : CmdStruct;
		MyResult	: results;
    bValidTDO : BOOL;
    TempSafetyNr  : HDINT;
    p_PDOInBufferAct : ^PDOInputBuffer;
  END_VAR

  // Save state 
  // This must be the 1. line in this function or EAX may be overwritten by the generated AWL code
  calloption := EAX;

  if calloption = CALL_OPTION_RT_PRESCAN then    // Called from UpdateRt

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
    StartTimeMeasurement(usMode := DMTIME_RT);
#endif	
//============================ Profiler end========================================================

    // do tdo/pdo communication only, if module has been found and initialized correctly and if there are some LEDs on (else a FW-Update is running)
    if Online & 
       (( SafetyState = _SafetyClassOK ) | ( SafetyState = _WaitForSynchronicity ) | ( SafetyState = _ReinitConfig ) | ( SafetyState = _ModFromCfgNotFound ) | ( SafetyState = _UnknownCfgError ) | ( SafetyState = _UnsafeVarNotFound )) then

      // get I/O state, runstate, error... and write unsafe I/Os
      UpDateNotStd();

      // wait until the safetymanager has initialized everything
      if b_ManagerInitialisationFinished = FALSE then
        return;
      end_if;

      // if any LED is active, then firmware update is not active and we can do our work
      if (VoltageOK | RunState | ServiceMode | ErrorState) then    
        // first check if there is a TDO to fetch
        if NewHandShakeValue then

          pTimeSyncHS_WriteData^ := pTimeSyncHS_ReadData^ OR NewHandShakeValue;
          SetDORunState(Handle:=HandleTimeSyncHSWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
          TimeSyncHSSingleRunActive := 2;
          
          // if the time synchonisation is active we send 2 different bits in 2 successive cycles, so the µC can detect the cycle time
          if NewHandShakeValue = 2#011 then
            NewHandShakeValue := 2#111;
            TimeSyncDOActive.OwnSyncActive := 1;
          else
            NewHandShakeValue := 0;
          end_if;
        elsif b_TimeSyncActive then
          // wait until the time synchronisation is finished
          if ((pTimeSyncHS_ReadData^ AND 2#110) = 0) & (TimeSyncHSSingleRunActive = 0) then
            b_TimeSyncActive := FALSE;
            TimeSyncDOActive.OwnSyncActive := 0;
            
            MyPara.uiCmd := CMD_SM_TIME_SYNC_FINISHED;
            pSafetyManagerThis^.NewInst(#MyPara, #MyResult); // thispointer doesn't have to be checked here; NewHandShakeValue gets set via SafetyManager
          end_if;
        end_if;

        // Read Length of TDO
        TDOInfo := pStatusInfoRd^.TDOReadState;

        // check msb (= new data) and length of frame
        bValidTDO := (TDOInfo AND 16#80) & ((TDOInfo AND 16#7F) = SB_STDO_LENGTH);
      
        if TimeSyncHSSingleRunActive then
          TimeSyncHSSingleRunActive -= 1;
          if TimeSyncHSSingleRunActive = 0 then
            SetDORunState(Handle:=HandleTimeSyncHSWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
          end_if;
        end_if;
      
        if bValidTDO then
      
          //copy whole TDO
          ToStdLib.MemCpy(dest := #TDOFrame, source := pTDOReadData, size := sizeof(TDOType));

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#TDOFrame)$^DINT, 0);
#endif

          // check length inside TDO Frame (must be 20)
          if TDOFrame.StdHeader.Len = (SB_STDO_LENGTH - sizeof(TDOType.StdHeader.CRC)) then
            
            // check who needs the TDO and give it the right addressee
            
            //search this-pointer of receiver with safety number
            p_ReceiveObj := ( GetRoutingPointerByNumber(ud_SafeNumber := TDOFrame.DstAdr))$pVirtualBase;
            
            if p_ReceiveObj <> NIL then
#ifdef DO_DEBUG
              DOCheck(pFrame:=(#TDOFrame)$^t_SDOStdHeader, pCheckStruct:=#TDORead);
#endif
              
              MyPara.uiCmd := CMD_SM_WRITE_TDO_TO_MODULE;
              MyPara.aPara[0] := (#TDOFrame)$DINT;
              p_ReceiveObj^.NewInst(#MyPara, #MyResult);    

  //                p_ReceiveObj^.WriteTDO2Module(#TDOFrame);
            elsif pSafetyManagerThis then
#ifdef DO_DEBUG
              DOCheck(pFrame:=(#TDOFrame)$^t_SDOStdHeader, pCheckStruct:=#TDORead);
#endif

              //passing the TDO to another domain
              MyPara.uiCmd := CMD_SM_TDO_TO_MANAGER;
              MyPara.aPara[0] := SB_STDO_LENGTH;
              MyPara.aPara[1] := (#TDOFrame)$DINT;
              pSafetyManagerThis^.NewInst(#MyPara, #MyResult);                      
            end_if;
          elsif TDOFrame.StdHeader.Len > 0 then
            LogError("Found TDOFrame with invalid Length value inside (must be 20)");
          elsif TDOFrame.StdHeader.Len = 0 then
            LogError("Found TDOFrame with Length = 0");
          end_if;
        end_if;
        
        if bValidTDO then
          // if it's a response, reset the flag
          if TDOFrame.StdHeader.Typ$USINT AND SB_SSDO_MASK_RESPONSE then            
            TimeSyncDOActive.Wait4ResponseNo -= 1;
          end_if;
        end_if;

        // if we are in run state
        if RunState then
          if b_MoveCommandOutputActive <> _Active then
            if PDOSingleRunActive then
              PDOSingleRunActive -= 1;
              if PDOSingleRunActive = 0 then
                SetDORunState(Handle:=HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
                
                if AdditionalSPDOs then             
                  for ii := 0 to (AdditionalSPDOs-1) do
                    SetDORunState(Handle:=aAdditionalPDOs[ii].HandlePDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
                  end_for;
                end_if;
              end_if;
            end_if;

            //read PDO from hardware, only if PDO is needed by other moduls
            if ( PDOOutputIsUsed ) then

              PDOLength := pStatusInfoRd^.PDOReadLength;

              // only if length is bigger than minimum and smaller than maximum
              if ( PDOLength > PDOType.Length ) & ( PDOLength <= SB_SPDO_MAX_LENGTH) then
                //copy whole PDO
                ToStdLib.MemCpy(dest := #PDOOutputBuffer, source := pPDOReadData, size := PDOLength);

#ifdef DO_DEBUG
                DOCheck(pFrame:=(#PDOOutputBuffer)$^t_SDOStdHeader, pCheckStruct:=#PDORead);
#endif

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
//if SafetyState = _SafetyClassOK then
  RecordFrame((#PDOOutputBuffer)$^DINT, 0);
//end_if;
#endif

              end_if;
            end_if;
            
            
            //read IFPDO from hardware, only if IFPDO is needed by other moduls
            if ( IFPDOOutputIsUsed ) then

              //copy whole PDO
              ToStdLib.MemCpy(dest := #IFPDOOutputBuffer, source := pPDOIFReadData, size := MyIFPDOReadSize);

#ifdef DO_DEBUG
              DOCheck(pFrame:=(#IFPDOOutputBuffer)$^t_SDOStdHeader, pCheckStruct:=#PDOIFRead);
#endif

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
//if SafetyState = _SafetyClassOK then
  RecordFrame((#IFPDOOutputBuffer)$^DINT, 0);
//end_if;
#endif
            end_if;
          else
            PDOLength := pStatusInfoRd^.PDOReadLength;
#ifdef DO_DEBUG
            DOCheck(pFrame:=pPDOReadData$^t_SDOStdHeader, pCheckStruct:=#PDORead);
#endif
          end_if;
        end_if;
      end_if;
    end_if;

#ifndef CALL_OPTION_RT_POSTSCAN
    UpDateRTPostScan(Handle);
#endif 

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
    StopTimeMeasurement(usMode := DMTIME_RT);
#endif	
//============================ Profiler end========================================================


  elsif calloption = CALL_OPTION_RT_POSTSCAN then // Called from UpdateRtPostScan

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
    StartTimeMeasurement(usMode := DMTIME_RTPOSTSCAN);
#endif	
//============================ Profiler end========================================================

    // do tdo/pdo communication only, if module has been found and initialized correctly and if there are some LEDs on (else a FW-Update is running)
    if Online & 
       (( SafetyState = _SafetyClassOK ) | ( SafetyState = _WaitForSynchronicity ) | ( SafetyState = _ModFromCfgNotFound ) | ( SafetyState = _UnknownCfgError ) | ( SafetyState = _UnsafeVarNotFound )) then

      // if any LED is active, then firmware update is not active and we can do our work
      if (VoltageOK | RunState | ServiceMode | ErrorState) then

        // TDO Handling with mover
        if TDOSingleRunActive then
          TDOSingleRunActive := FALSE;
          SetDORunState(Handle:=HandleTDOWrite, NewState:=_BUS_IF_RUN_STATE_NO_RUN);
        end_if;

        // check if we may send a TDO (TDO-Status-Register MSB must be zero)
        if (( pStatusInfoRd^.TDOWriteState AND 16#80 ) = 0) then

          // check for a TDO Request => if there is one, send it
          if s_TDORingbuffer.b_RequestAvailable then

            ToStdLib.MemCpy(dest := pTDOWriteData, source := #s_TDORingbuffer.RequestTDO, size := sizeof(TDOType));

            TimeSyncDOActive.Wait4ResponseNo += 1;
#ifdef DO_DEBUG
            DOCheck(pFrame:=(#s_TDORingbuffer.RequestTDO)$^t_SDOStdHeader, pCheckStruct:=#TDOWrite);
#endif

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#s_TDORingbuffer.RequestTDO)$^DINT, 1);
#endif

            s_TDORingbuffer.b_RequestAvailable := FALSE;

            SetDORunState(Handle:=HandleTDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);

            TDOSingleRunActive := TRUE;

          // Send entries of TDO-Buffer (only responses)
          elsif ( s_TDORingbuffer.ud_Entries > 0 ) THEN

            ToStdLib.MemCpy(dest := pTDOWriteData, source := #s_TDORingbuffer.Entry[s_TDORingbuffer.ud_ReadPos], size := sizeof(TDOType));

#ifdef DO_DEBUG
            DOCheck(pFrame:=(#s_TDORingbuffer.Entry[s_TDORingbuffer.ud_ReadPos])$^t_SDOStdHeader, pCheckStruct:=#TDOWrite);
#endif

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#s_TDORingbuffer.Entry[s_TDORingbuffer.ud_ReadPos])$^DINT, 1);
#endif

            // in the startupphase we use the time synchronisation between modules to check if a module is synchron with all of his communication partners
            if (us_SetBusReadyState = WaitPDOsSyncron) & ui_cnt_PDOInputBuffer then
              TempSafetyNr := s_TDORingbuffer.Entry[s_TDORingbuffer.ud_ReadPos].SrcAdr;

              p_PDOInBufferAct := #aPDOInputBuffer[0];
              for i := 0 to (ui_cnt_PDOInputBuffer-1) do
                if p_PDOInBufferAct^.ud_SafetyNr = TempSafetyNr then
                  p_PDOInBufferAct^.b_TimeSynchron := TRUE;
                end_if;

                p_PDOInBufferAct +=  sizeof(PDOInputBuffer);
              end_for;                        
            end_if;

            s_TDORingbuffer.ud_ReadPos := ( s_TDORingbuffer.ud_ReadPos + 1 ) mod ( SIZEOF( TDORingbuffer.Entry ) / SIZEOF( TDOType ) );
            s_TDORingbuffer.ud_Entries -= 1;

            SetDORunState(Handle:=HandleTDOWrite, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);

            TDOSingleRunActive := TRUE;
          END_IF;
        else
          // can't write this time, if there is a request waiting => drop it
          if s_TDORingbuffer.b_RequestAvailable then
            s_TDORingbuffer.b_RequestAvailable := FALSE;
            sd_RequestDropCounter += 1;
          end_if;
        end_if;
        
        if RunState & ((us_SetBusReadyState = SetBusReadyFinished) | b_ManualQuit) then
          //write PDO to hardware
          if ( ui_cnt_PDOInputBuffer > 0 ) then          
            WritePDO2Module();
          end_if;
        end_if;
      end_if;
    end_if;

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
    StopTimeMeasurement(usMode := DMTIME_RTPOSTSCAN);
#endif	
//============================ Profiler end========================================================
  end_if;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::ConnectEvent
  VAR
		MyPara 	              : CmdStruct;
		MyResult	            : results;
  END_VAR

  //start DOs
  StartDO();

  if SafetyState = _ModuleNotFound then
    if ModuleSyncNo = 0 then
      SetSafetyState(NewState:=_SafetyClassOK);
    else
      SetSafetyState(NewState:=_WaitForSynchronicity);
    end_if;
  end_if;
  
  // if we we're already connected => tell the sdias manager we're back (safetythis has to be valid if b_Reconnect is set, therefore we don't have to check it here)
  if b_Reconnect then
#ifdef HWK_SHOW_PRAGMA_MESSAGES
#pragma message("RamAnd 24.10.2013 10:43 \ reconnect kann erst getestet werden, wenn das OS ein reconnect zulässt (issue Punkt Nr.1)")
#endif
    MyPara.uiCmd := CMD_SM_MODULE_RECONNECT;
    MyPara.aPara[0] := THIS$DINT;
    pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
  end_if;


// online is set if module init succeeds
//  Online := 1;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::DisconnectEvent
  VAR
		MyPara 	              : CmdStruct;
		MyResult	            : results;
  END_VAR
  
  //stop DOs
  StopDO();

  // reset time sync state and tell the manager
  if pSafetyManagerThis then
    MyPara.uiCmd := CMD_SM_MODULE_DISCONNECT;
    MyPara.aPara[0] := THIS$DINT;
    pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
    
    b_Reconnect := TRUE;
  end_if;
  b_TimeSyncActive := FALSE;
  TimeSyncDOActive.OwnSyncActive := 0;

  // clear request, otherwise problems could occur on next connect
  LastRequest := _NoOpenRequest;

  SafetyNumber := 0;
  FirmwareVersion := 0;
  
  // increment the config checksum to ensure the readout on reconnect (config readout also contains check of connected modules)
  DesignerPrjConfigCRC += 1;

  SetSafetyState(NewState:=_ModuleNotFound);
  
  Online := 0;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::InterruptEvent

END_FUNCTION


FUNCTION SafetyBase::SetDORunState
	VAR_INPUT
		Handle 	: UDINT;
		NewState 	: t_BusIFRunState;
	END_VAR
  VAR
    dataSETRUNSTATE : t_SetRunStateCfg;
		tempCmd : CmdStruct;
		_result : results;
  END_VAR

  // set runstate of read
  dataSETRUNSTATE.Handle      := Handle;
  dataSETRUNSTATE.NewRunState := NewState;
  
  tempCmd.uiCmd         := _BUS_IF_SET_RUN_STATE;  
  tempCmd.aPara[0]      := (#dataSETRUNSTATE)$DINT; 

  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result); 
  
  if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
    if NewState = _BUS_IF_RUN_STATE_NO_RUN then
      DOStopFailCounter += 1;
    else
      DOStartFailCounter += 1;
    end_if;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyBase::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	p_SDO_act             : ^SDOHeader;
    us_SDO_length         : USINT;
    i                     : UINT;
    p_ReceiveObj          : pVirtualBase;
    p_SDOviaPath          : ^SDOviaPath;
    sd_retval             : DINT;
    IsStandardResp        : BOOL;
		SDORequestBuffer      : SDORequReadConfig;
    DataLen               : USINT;
    us_UnsafeSchedulerRun : USINT;
    p_PDOInBufferAct      : ^PDOInputBuffer;
    EverythingSynchron    : BOOL;
		MyPara 	              : CmdStruct;
		MyResult	            : results;
    UnsafeWrPackageNo     : USINT;
    aUnsafeWrPackages     : UnsafeWritePackages;
    UnsafeRdPackageNo     : USINT;
    aUnsafeRdPackages     : UnsafeReadPackages;
    TmpVal                : DINT;
    AddUnsafePackage      : BOOL;
    GotNewUnsafeValue     : BOOL;
    pHelpUnsafe           : ^UnsafeIORoutingElement;
    BDINTWriteVars        : USINT;
    NoStr                 : ARRAY[0..11] of CHAR;
    TmpStr                : ARRAY[0..99] of CHAR;
  END_VAR

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StartTimeMeasurement(usMode := DMTIME_CY);
#endif	
//============================ Profiler end========================================================

  // do sdo communication only, if module has been found and initialized correctly and if there are some LEDs on (else a FW-Update is running)
  if Online & (VoltageOK | RunState | ServiceMode | ErrorState) &
     (( SafetyState = _SafetyClassOK ) | ( SafetyState = _WaitForSynchronicity ) | ( SafetyState = _ReinitConfig ) | ( SafetyState = _ModFromCfgNotFound ) | ( SafetyState = _UnknownCfgError ) | ( SafetyState = _UnsafeVarNotFound )) then

    // wait until the safetymanager has initialized connection
    if (b_ManagerReadyForSDO = FALSE) then
      return;
    end_if;

    //Update of service messages doesn't take place in realtime

    // if we have to quit the communication errors and there is no other request open at this time
    if (QuitComError = 1) & (LastRequest = _NoOpenRequest) then
      if UnsafeScheduler <> UnsafeSchedulerSetBusReady then
        us_SetBusReadyState := WaitPDOsSyncron; 
        UnsafeScheduler := UnsafeSchedulerSetBusReady;  
      end_if;
      
      QuitComError := 0;
      
      // refresh the server on the outer object
      RefreshAsySrv();
    end_if;

    //read SDO from module and send it to the target module
    //check, if SDO is available and valid
    if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
  
      //calculate length of SDO
      us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
      
      //copy SDO without first byte (=status byte)
      ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame(p_SDOOutputBuffer$^DINT, 0);
#endif

      //mark data as received
      p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
    
      //find target object for routing
      p_ReceiveObj := NIL;

      IsStandardResp := FALSE;
      //check, if receiver is addressed by safety number or hardware path
      if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SSDO_MOD) then
      
        //search this-pointer of receiver with safety number
        p_ReceiveObj := ( GetRoutingPointerByNumber(ud_SafeNumber := p_SDOOutputBuffer^.SDOHeader.DstAdr))$pVirtualBase;
        
      elsif ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SSDO_MOD_TP) then

        //search this-pointer of receiver with hardware path
        p_SDOviaPath := p_SDOOutputBuffer$^SDOviaPath;
        p_ReceiveObj := ( GetRoutingPointerByPath(p_ActObjectPath := #p_SDOviaPath^.TopologyPath[0], p_SDOviaPath^.StdHeader.Len - 8))$pVirtualBase;
      elsif ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
        IsStandardResp := TRUE;
        StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
        if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then

          case LastRequest of
            _NoOpenRequest: // error, no open request, but we got a response
              LogError(e_msg:="Standard frame response received, without open request");
            
            _SetBusReady:
              IF StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_SET_BUS_READY THEN
                if us_SetBusReadyState <> SendSetBusReady then
                  LogError("Got Response of SetBusReady, but SSW is not in the right step");
                  return;
                end_if;
                us_SetBusReadyState := SetBusReadyFinished;
                b_ManualQuit := FALSE;
                UnsafeScheduler := UnsafeSchedulerGetDiagVars; // Go on with the action-steps, done here so we don't lose a whole cycle
                LastRequest := _NoOpenRequest;
                ud_AsyComRetryCounter := 0; // reset retry counter
                if SafetyState = _WaitForSynchronicity then
                  SetSafetyState(NewState:=_SafetyClassOK);
                end_if;
              else
                LogError("Invalid command: bus ready expected");  
              END_IF;
            
            _ReadData:
              // if we did read command, then save the value to corresponding server
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ then
                // if returncode is 0 read succeeded
                if StandardResponse.aData[0] = 0 then
                  // check if length is correct
                  if StandardResponse.aData[1] = StandardRequest.aData[4] then
                    // delete request
                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    if (DiagVars.SavingLogSSW = GetLogFileBlocks) then
                      // save the last block in the memory for the file
                      _memcpy(ptr1:=DiagVars.pLogFileMem$pVoid + (DiagVars.LogHeader.LogMemSize - DiagVars.LogMemToGet), 
                              ptr2:=#StandardResponse.aData[2], 
                              cntr:=DiagVars.BytesToGet);

                      DiagVars.LogMemToGet -= DiagVars.BytesToGet;
                      
                      if DiagVars.LogMemToGet = 0 then
                        DiagVars.SavingLogSSW := GetLogHeader2;
                      end_if;
                    else
                      LogError("SDO Receive: Invalid Read response (no diagnostic read active)");
                    end_if;
                  end_if;
                end_if;
              else
                LogError("SDO Receive: Invalid command, read expected");              
              end_if;

            _ReadValues:
              // if we did read command, then save the value to corresponding server
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ_VALUES then
                // if returncode is 0 read succeeded
                if StandardResponse.aData[0] = 0 then
                  // check if length is correct
                  if StandardResponse.aData[1] = StandardRequest.aData[0] then
                    // delete request
                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    // if we got some outputs in the routing table and a valid pointer, write values to servers
                    if ui_CntUnsafeOutputs & pUnsafeOutElement then
                      
                      // depending on length we do different number of server write-methods to set the data we just read
//                      pUnsafeOutElement := p_UnsafeOutputsTable + (UnsafeReadTransNr * MaxVarsPerReadPackage * sizeof(UnsafeIORoutingElement));  // the pointer is already on this element
                      for i := 0 to (StandardResponse.aData[1] - 1) do
                        // save the new value temporarily
                        TmpVal := StandardResponse.aData[2 + (i * sizeof(DINT))]$DINT;
                        if pUnsafeOutElement^.ud_Thisp then
                          if pUnsafeOutElement^.UnsafeType = BDINTOutput then
                            pUnsafeOutElement^.sd_OldValue := RD(pUnsafeOutElement^.ud_Thisp$^void)$DINT;
                            TmpVal := ((pUnsafeOutElement^.sd_OldValue$UDINT AND (NOT pUnsafeOutElement^.BitMask)) OR
                                      (TmpVal$UDINT AND pUnsafeOutElement^.BitMask))$DINT;
                            
                            // now we have to write the value to the server
                            WR(pUnsafeOutElement^.ud_Thisp$^void, TmpVal);              
                          else
                            WR(pUnsafeOutElement^.ud_Thisp$^void, TmpVal);                              
                          end_if;
                        elsif (pUnsafeOutElement^.UnsafeType = ExternalOutput) | (pUnsafeOutElement^.UnsafeType = ExternalBDINTOutput) then
                          pUnsafeOutElement^.sd_NewValue4External := TmpVal;
                          
                          // mark the value as valid
                          pUnsafeOutElement^.b_IsValid := TRUE;
                        end_if;
                        pUnsafeOutElement += sizeof(UnsafeIORoutingElement);
                      end_for;
                    end_if;
                  
                    UnsafeReadTransNr += 1;
                  end_if;
                end_if;
              else
                LogError("SDO Receive: Invalid command, read values expected");              
              end_if;
            
            _WriteValues:
              if IsOptimizedCPU() then
                // if we did a write command, just check 
                if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_WRITE_VALUES then
                  // delete request
                  LastRequest := _NoOpenRequest;
                  ud_AsyComRetryCounter := 0; // reset retry counter

                  // if there is no more element to send or check for changes => proceed to the next step
                  if pUnsafeInElement = NIL then
                    UnsafeScheduler := UnsafeSchedulerReadData; //We need to set scheduler to next step....
                  end_if;                
                else
                  LogError("SDO Receive: Invald command, write expected");          
                end_if;
              else
                // on CSCP011 the SDO_COMMAND_WRITE_VALUES didn't exist
                
                // if we did a write command, just check 
                if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_WRITE then
                  // delete request
                  LastRequest := _NoOpenRequest;
                  ud_AsyComRetryCounter := 0; // reset retry counter

                  if UnsafeWriteTransNr < (WriteFramesNeeded - 1) then
                    UnsafeWriteTransNr += 1;
                  else
                    UnsafeWriteTransNr := 0;
                    UnsafeWritingActive := FALSE;
                    UnsafeScheduler := UnsafeSchedulerReadData; //We need to set scheduler to next step....
                  end_if;
                else
                  LogError("SDO Receive: Invald command, write expected");          
                end_if;
              end_if;


            _GetCRC:
              // check if it's a response to a read command
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ then
                // if returncode is 0 read succeeded
                if StandardResponse.aData[0] = 0 then
                  // check if length is correct
                  if StandardResponse.aData[1] = 4 then
                  
                    // delete request
                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    if DesignerPrjConfigCRC <> StandardResponse.aData[2]$UDINT then
                      // CRC has changed => save the new crc
                      DesignerPrjConfigCRC := StandardResponse.aData[2]$UDINT;
                      
                      // show that we read the config of the class again
                      SetSafetyState(NewState:=_ReinitConfig);

                      if pSafetyManagerThis then
                        MyPara.uiCmd := CMD_SM_NEW_SAFETY_PROJECT;
                        MyPara.aPara[0] := 4;
                        MyPara.aPara[4] := (#SafetyNumber)$DINT;
                        pSafetyManagerThis^.NewInst(#MyPara, #MyResult);    
                      end_if;

                      // remove the cpu from all classes, which use it
                      ResetConfig();
                      
                      // we have to return here because:
                      // the command CMD_SM_NEW_SAFETY_PROJECT will trigger a disconnect of this class which will set the unsafe scheduler to setbusready, 
                      // which would skip the synchron check in the actual cyclic run because everything of the old configuration is synchron now
                      return;
                    end_if;
                  end_if;
                end_if;
              end_if;
                
            _DiagState:
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_GET_STATE then
                _memcpy(ptr1 := #DiagVars.UserGetStateResp, 
                        ptr2 := #StandardResponse.aData + SIZEOF(USINT), 
                        cntr := sizeof(GetStateResponseType) );
                DiagVars.UserDiagStateReady := TRUE;
                DiagVars.UserWantsDiagState := FALSE;
                LastRequest := _NoOpenRequest;
                ud_AsyComRetryCounter := 0; // reset retry counter
              end_if;
            _DiagInfo:
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_GET_DIAG_INFO then
                _memcpy(ptr1 := #DiagVars.UserGetDiagInfoResp, 
                        ptr2 := #StandardResponse.aData + SIZEOF(USINT), 
                        cntr := sizeof(SafetyDiagInfo) );
                DiagVars.UserDiagInfoReady := TRUE;
                DiagVars.UserWantsDiagInfo := FALSE;
                LastRequest := _NoOpenRequest;
                ud_AsyComRetryCounter := 0; // reset retry counter
              end_if;
              
            _ReadRetryCounter:
              //if we did read command, then save the value to corresponding server
              if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ then
                // if returncode is 0 read succeeded
                if StandardResponse.aData[0] = 0 then
                  // check if length is correct
                  if StandardResponse.aData[1] = SB_SDO_LENGTH_RETRY_COUNTER then
                    // delete request
                    LastRequest := _NoOpenRequest;
                      
                      //Only Write if Retry Counter has changed
                      if StandardResponse.aData[2] <> us_OldRetryCounter then
                        //if retry counter has changed, save the new retry counter
                        SafetyRetryCounter += to_usint(StandardResponse.aData[2] - us_OldRetryCounter);
                        us_OldRetryCounter := StandardResponse.aData[2];
                        
                        //0x20400000 is adress of retry counter: 1 byte amount of all retries of all modules, 16byte µC1, 16 byte µC2
                        //Save the values from the modules
                        ToStdLib.MemCpy(dest:=#a_RetryCnt[0], source:=#StandardResponse.aData[3], size:=SB_SDO_LENGTH_RETRY_COUNTER);
                        
                        //Calls the method of class sdiassafetymanager
                        SetRetryCounter();  
                      end_if;
                    end_if;
                  end_if;
                else
                  LogError("SDO Receive: Invalid command, read values expected");    
                end_if;

            else
              LogError(e_msg:="SDO Receive: Invalid standard frame response");
          end_case;

          // if request is deleted, increase sequence number to set next request
          if LastRequest = _NoOpenRequest then
            if StandardSeqNr < 16#7F then
              StandardSeqNr += 1;
            else
              StandardSeqNr := 0;
            end_if;
          end_if;
        else
          LogError("SDO Receive: Invalid sequence number in Standard SDO response");
          LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
        end_if;
      else
        LogError("SDO Receive: Invalid frametype in Standard SDO response");
      end_if;

      //if there is no object, the message will be lost
      if ( p_ReceiveObj ) then

        //send SDO to receiver object
        MyPara.uiCmd := CMD_SM_ADD_SDO_TO_BUFFER;
        MyPara.aPara[0] := p_SDOOutputBuffer$DINT;
        MyPara.aPara[1] := us_SDO_length;
        sd_retval$iprStates := p_ReceiveObj^.NewInst(#MyPara, #MyResult);    

//        sd_retval := p_ReceiveObj^.AddSDOToBuffer(p_us_Message := p_SDOOutputBuffer$^USINT, us_length := us_SDO_length);
        
        if sd_retval$iprStates = ERROR then
          // convert returncode into hex-string
          _itoa((0-MyResult.aData[0]$DINT)$UDINT, #NoStr[0]);
          
          // generate error message with returncode (add to logfile and debugger trace)
          _StrCpy(#TmpStr[0], "AddSDOToBuffer failed: Returncode: -");
          _StrCat(#TmpStr[0], #NoStr[0]);
          LogError(#TmpStr[0]);
        end_if;
      
      elsif IsStandardResp = FALSE then

        if pSafetyManagerThis & us_SDO_length then
#ifdef DO_DEBUG
          DOCheck(pFrame:=(p_SDOOutputBuffer)$^t_SDOStdHeader, pCheckStruct:=#SDORead);
#endif

          MyPara.uiCmd := CMD_SM_SDO_TO_MANAGER;
          MyPara.aPara[0] := to_dint(us_SDO_length);
          MyPara.aPara[1] := p_SDOOutputBuffer$DINT;
          pSafetyManagerThis^.NewInst(#MyPara, #MyResult);    
        else
          //log not routable SDOs
          LogError("SDO Problem (details in next line)");
          LogValue("Safety module 0x{0}: SDO not routed to receiver {1}", SafetyNumber$UDINT, p_SDOOutputBuffer^.SDOHeader.DstAdr$UDINT);
        end_if;
      end_if;

    elsif (LastRequest <> _NoOpenRequest) & (ud_TransfertimePerPackage > 0) then
      // count up for timeout
      ud_UnsafeTimeoutCounter += 1;
            
      if ( ud_UnsafeTimeoutCounter ) > ( 50 * ud_TransfertimePerPackage ) then
        CASE UnsafeScheduler OF

          UnsafeSchedulerSetBusReady:
            LogError("(SafetyBase::UpdateCy) Timeout on setting bus ready");

          UnsafeSchedulerGetDiagVars:
            IF LastRequest = _ReadData THEN
              LogError("(SafetyBase::UpdateCy) Timeout requesting DiagVars");
            END_IF;
            UnsafeScheduler := UnsafeSchedulerGetCRC;
            DiagVars.SavingLogSSW := GetLogFileBlocks;
            
          UnsafeSchedulerGetCRC:
            LogError("(SafetyBase::UpdateCy) Timeout requesting CRC");
            UnsafeScheduler := UnsafeSchedulerWriteData;
            
          UnsafeSchedulerWriteData:
            LogError("(SafetyBase::UpdateCy) Timeout writing Data 'Unsafe Input'");
            UnsafeScheduler := UnsafeSchedulerReadData;
            UnsafeWriteTransNr := 0;
            
          UnsafeSchedulerReadData:
            LogError("(SafetyBase::UpdateCy) Timeout reading Data 'Unsafe Output'");
            UnsafeScheduler := UnsafeSchedulerDiagState;
            UnsafeReadTransNr := 0;
            
          UnsafeSchedulerDiagState:
            LogError("(SafetyBase::UpdateCy) Timeout on reading DiagState");
            UnsafeScheduler := UnsafeSchedulerDiagInfo;
            
          UnsafeSchedulerDiagInfo:
            LogError("(SafetyBase::UpdateCy) Timeout on reading DiagInfo");
            UnsafeScheduler := UnsafeSchedulerGetRetryCounter;
          
          UnsafeSchedulerGetRetryCounter:
            LogError("(SafetyBase::UpdateCy) Timeout on reading RetryCounter");
            UnsafeScheduler := UnsafeSchedulerGetDiagVars ;
          
        END_CASE;
        
        // we only increase the retry counter if the module is running
        if RunState then
          ud_AsyComRetryCounter += 1;        
        end_if;

        if ud_AsyComRetryCounter >= SB_SDO_MAX_TRIES then
          SetSafetyState(NewState:=_AsyncComError);
          LogError("(SafetyBase::UpdateCy) Too many consecutive asynchronous commands failed! Please contact Sigmatek Support!");
        else
          LastRequest := _NoOpenRequest;
          // if request is deleted, increase sequence number to set next request
          if StandardSeqNr < 16#7F then
            StandardSeqNr += 1;
          else
            StandardSeqNr := 0;
          end_if;
        end_if;
      end_if;
       
    end_if;

    //write to hardware from other module received SDO
    if ( ui_cnt_SDOInputBuffer > 0 ) & p_SDOInputBuffer then
      
      //set pointer to first SDO in the SDO list
      p_SDO_act   := p_SDOInputBuffer$^SDOHeader;
          
      //calculate length of SDO (CRC + data length)
      us_SDO_length := sizeof (SDOHeader.StdHeader.CRC) + p_SDO_act^.StdHeader.Len;
          
      //check, if buffer is empty
      if ( p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA ) then
      
#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame(p_SDO_act$^DINT, 1);
#endif

        //copy SDO into write-buffer
        ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := p_SDO_act, size := us_SDO_length);
        
        //mark SDO data as valid
        p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
                   
        //decrement amount of SDOs 
        ui_cnt_SDOInputBuffer -= 1;
          
        //if there is at least 1 SDO left, copy the remaining memory over the actual SDO
        if ( ui_cnt_SDOInputBuffer > 0 ) then
                   
          //remove first entry in the SDO list
          _memmove(p_SDOInputBuffer, (p_SDOInputBuffer + SB_SDO_MAX_LENGTH), (ui_cnt_SDOInputBuffer * SB_SDO_MAX_LENGTH));
        end_if;
      end_if;
    end_if;


    // Start of scheduler; we need to share the time between reading, writing and diagnosis
    us_UnsafeSchedulerRun := 0;

    if (b_ManagerInitialisationFinished = TRUE) & ( p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA ) then
      
      //If Retrycounter is available we have 7 steps to go through.
      if b_RetryCounterAvailable then
        SchedulerStepNo := 7;
      else
        SchedulerStepNo := 6;
      end_if;

      // Check actions until we find somthing we need to do
      // all x (SchedulerStepNo) action-steps must be walked through during one cycle to make sure new data is fetched as fast as possible
      // SetBusReady is an exception: this step is only performed once on bootup!
      while (us_UnsafeSchedulerRun < SchedulerStepNo) & (LastRequest = _NoOpenRequest) do
        us_UnsafeSchedulerRun += 1;
        ud_UnsafeTimeoutCounter := 0; //No active request: we can reset the timeout-counter
        case UnsafeScheduler of

       (* ***************************************** *)
          UnsafeSchedulerSetBusReady:
       (* ***************************************** *)
          case us_SetBusReadyState of
          
          //-------------------------------------------------------------------------------------------------------------
            WaitPDOsSyncron: 
            
              EverythingSynchron := TRUE;
              
              // it's possible that all PDOs are coming from a different domain, then we have no inputbuffer
              if ui_cnt_PDOInputBuffer then
                p_PDOInBufferAct := #aPDOInputBuffer[0];
                for i := 0 to (ui_cnt_PDOInputBuffer-1) do
                  if p_PDOInBufferAct^.b_TimeSynchron = FALSE then
                    // we're still not synchron with this module. if it's optional it is probably not connected
                    if p_PDOInBufferAct^.b_IsOptional then
                      if (ops.tAbsolute - ud_OptionalTimeoutStart) <= SB_OPTIONAL_MODULE_SYNC_TIMEOUT then
                        // if timeout not exceeded => not sychron (otherwise the variable will stay on it's old value)
                        EverythingSynchron := FALSE;
                        exit;
                      else
                        TRACE("Synchronisation timeout for optional module exceeded => assume it's synchon");
                      end_if;
                    else
                      EverythingSynchron := FALSE;
                      exit;
                    end_if;
                  end_if;
                
                  p_PDOInBufferAct +=  sizeof(PDOInputBuffer);
                end_for;              
                
                if EverythingSynchron & (ModuleSyncNo > 0) then
                  ModuleSyncNo -= 1;

#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
//                  case ud_MyModuleID of
//                    CSCP01x_ID:
//                      TRACE("ModuleSyncNo wurde dekrementiert von: CSCP");
//                      
//                    CSDI16x_ID:
//                      TRACE("ModuleSyncNo wurde dekrementiert von: CSDI");
//                      
//                    CSTO08x_ID:
//                      TRACE("ModuleSyncNo wurde dekrementiert von: CSTO");
//                  end_case;
#endif
                end_if;
#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
//              elsif EverythingSynchron then
//                  case ud_MyModuleID of
//                    CSCP01x_ID:
//                      TRACE("ModuleSyncNo wurde nicht verändert von: CSCP");
//                      
//                    CSDI16x_ID:
//                      TRACE("ModuleSyncNo wurde nicht verändert von: CSDI");
//                      
//                    CSTO08x_ID:
//                      TRACE("ModuleSyncNo wurde nicht verändert von: CSTO");
//                  end_case;
#endif
              end_if;
              
              if EverythingSynchron then
                us_SetBusReadyState := WaitAllModulesSyncron;
              end_if;

          //-------------------------------------------------------------------------------------------------------------
            WaitAllModulesSyncron:              
              // wait for other modules to be synchron with each other
              if (ModuleSyncNo = 0) & b_ManagerInitialisationFinished then
                us_SetBusReadyState := SendSetBusReady;              
              end_if;
            
          //-------------------------------------------------------------------------------------------------------------
            SendSetBusReady:              
              // send the bus-ready command
              SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
              SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_SET_BUS_READY;                        // set bus ready command
              SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
              SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
              SDORequestBuffer.StdHeader.Len  := 4;                                                   // header
          
              LastRequest := _SetBusReady;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#SDORequestBuffer)$^DINT, 1);
#endif

              //copy SDO into write-buffer
              ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                    
              //mark SDO data as valid
              p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
              
              if ( pISafety^.udVersion >= 16#1001 ) then
                SAFETY_iPushSafetyTask();
              end_if;
              
          //-------------------------------------------------------------------------------------------------------------
            SetBusReadyFinished:
              // all ok, nothing to do here
              
          end_case;
          us_UnsafeSchedulerRun := 16#FF; //make sure we don't repeat the while-loop until we have sent the bus-ready command

       (* ***************************************** *)
          UnsafeSchedulerGetDiagVars:
       (* ***************************************** *)

          //check, if buffer is empty and we got some unsafe data to get/set and crc check is finished
          if (DiagVars.SavingLogSSW = GetLogFileBlocks) then

            // check if more than blocksize to get
            if DiagVars.LogMemToGet > SB_LOG_DATA_BLOCK_SIZE then
              // get a complete block
              DiagVars.BytesToGet := SB_LOG_DATA_BLOCK_SIZE;
            else
              // get only the last bytes
              DiagVars.BytesToGet := DiagVars.LogMemToGet$USINT;
            end_if;

            StandardRequest.SDOHeader.Cmd   := SB_SDO_COMMAND_READ;                         // read command
            StandardRequest.SDOHeader.Typ   := SDO_STD;                                     // standard frame type
            StandardRequest.SDOHeader.SeqNr := StandardSeqNr OR 16#80;                      // sequence number is in special area
            StandardRequest.SDOHeader.Len   := 4 + 4 + 1;                                   // header + destination address + length of data
            StandardRequest.aData[0]$UDINT  := DiagVars.ReadBaseAdr + (DiagVars.LogHeader.LogMemSize - DiagVars.LogMemToGet);// destination address
            StandardRequest.aData[4]        := DiagVars.BytesToGet$USINT;                   // length of data
                  
            LastRequest := _ReadData;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#StandardRequest)$^DINT, 1);
#endif

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #StandardRequest, size := (sizeof(SDOHeader.StdHeader.CRC) + StandardRequest.SDOHeader.Len));
            
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;
          else
            UnsafeScheduler := UnsafeSchedulerGetCRC;
          end_if;

          
       (* ***************************************** *)
          UnsafeSchedulerGetCRC:
       (* ***************************************** *)
          
          // every 5 secs check for a new safety project inside the cpu 
          if b_CheckCRC & ((ops.tAbsolute - ud_LastCrcCheck) > SB_CRC_CHECK_TIME ) then

            SDORequestBuffer.StdHeader.CRC  := 0;                                                         // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_READ;                                       // read command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                                   // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                                    // sequence number
            SDORequestBuffer.StdHeader.Len  := 4 + 4 + 1;                                                 // header + destination address + length of data
            SDORequestBuffer.ud_Address     := SB_SDO_ADDRESS_CONFIG_DATA + SB_SDO_OFFSET_CONFIG_CRC_ALL; // address of crc
            SDORequestBuffer.us_Length      := 4;                                                         // length of crc

            LastRequest := _GetCRC;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#SDORequestBuffer)$^DINT, 1);
#endif

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;

            ud_LastCrcCheck := ops.tAbsolute;
          else
            if RunState then
              // in operational also get unsave-variables
              UnsafeScheduler := UnsafeSchedulerWriteData;
            else
              // not operational, we must skip the unsave vars
              UnsafeScheduler := UnsafeSchedulerDiagState;
              us_UnsafeSchedulerRun += 2;
            end_if;
          end_if;

       (* ***************************************** *)
          UnsafeSchedulerWriteData:
       (* ***************************************** *)

          if IsOptimizedCPU() then
            if ui_CntUnsafeInputs then
              // if we have finished checking through all variables the last time => check from beginning (otherwise the pointer is on the element where we have to continue)
              if pUnsafeInElement = NIL then
                pUnsafeInElement := p_UnsafeInputsTable;
              end_if;
              
              // we check if we have to write any of the unsafe input variables (only until our message is full)
              UnsafeWrPackageNo := 0;
              BDINTWriteVars := 0; // limit number of bdint write variables to 3 to ensure constant load of firmware
              while pUnsafeInElement & (UnsafeWrPackageNo < SB_MAX_UNSAFE_WRITE_PACKAGES) & (BDINTWriteVars < SB_MAX_UNSAFE_BDINTS_PER_WRITE) do

                // we have to check if we add this one
                GotNewUnsafeValue := FALSE;

                // if the type is normal we can read the actual value from the server
                if pUnsafeInElement^.UnsafeType = NormalUnsafe then
                  // check if pointer to server is valid
                  if pUnsafeInElement^.ud_Thisp then
                    // get the actual value from the server
                    TmpVal := RD((pUnsafeInElement^.ud_Thisp)$^void);

                    // we remember to update this if it's necessary
                    GotNewUnsafeValue := TRUE;                 
                  else
                    if bd_LogOnceMarker.NoThisForUnsafeIn = FALSE then
                      bd_LogOnceMarker.NoThisForUnsafeIn := TRUE;
                      LogError("No thispointer available for Server of local unsafe input variable");
                    end_if;
                  end_if;
                elsif pUnsafeInElement^.UnsafeType = ExternalInput then
                  // check if we already have a valid value there
                  if pUnsafeInElement^.b_IsValid then
                    // get the actual value from the element
                    TmpVal := pUnsafeInElement^.sd_NewValue4External;
                    
                    // we remember to update this if it's necessary
                    GotNewUnsafeValue := TRUE;
                  end_if;
                else
                  if bd_LogOnceMarker.WrongUnsafeVarType = FALSE then
                    bd_LogOnceMarker.WrongUnsafeVarType := TRUE;
                    LogError("Wrong unsafe variable type in unsafe input list");              
                  end_if;
                end_if;
                
                // if we have a new valid unsafe value => check if we have to send it
                if GotNewUnsafeValue then
                  // if it hasn't been sent yet
                  if (pUnsafeInElement^.b_AlreadyTransmitted = FALSE) then
                    // remember that we sent this already
                    pUnsafeInElement^.b_AlreadyTransmitted := TRUE;
                    
                    // add this one
                    AddUnsafePackage := TRUE;
                  elsif TmpVal <> pUnsafeInElement^.sd_OldValue then
                    // if there were any changes on this value
                    
                    // add this one
                    AddUnsafePackage := TRUE;                
                  else
                    // don't add this one
                    AddUnsafePackage := FALSE;
                  end_if;                  

                  // if it is ready to be added => add it to send buffer
                  if AddUnsafePackage then
                    // add a package to send
                    aUnsafeWrPackages[UnsafeWrPackageNo].ud_Address := pUnsafeInElement^.ud_Address;
                    aUnsafeWrPackages[UnsafeWrPackageNo].Value      := TmpVal;
                    UnsafeWrPackageNo += 1;

                    // if it has a bitmask it's an unsafe bdint input variable
                    if pUnsafeInElement^.BitMask then
                      BDINTWriteVars += 1;
                    end_if;

                    // remember the actual as old value
                    pUnsafeInElement^.sd_OldValue := TmpVal;
                  end_if;
                end_if;

                pUnsafeInElement := pUnsafeInElement^.pNext;
              end_while;

              if UnsafeWrPackageNo then
                DataLen := UnsafeWrPackageNo * sizeof(UnsafeWritePackage);
              
                StandardRequest.SDOHeader.Cmd                 := SB_SDO_COMMAND_WRITE_VALUES;    // write values command
                StandardRequest.SDOHeader.Typ                 := SDO_STD;                        // standard frame type     
                StandardRequest.SDOHeader.SeqNr               := StandardSeqNr OR 16#80;         // sequence number is in special area
                StandardRequest.SDOHeader.Len                 := 4 + 4 + 1 + DataLen;            // header + destination address + length of data + data
                StandardRequest.aData[0]                      := UnsafeWrPackageNo;              // number of packages
                StandardRequest.aData[1]$UnsafeWritePackages  := aUnsafeWrPackages;              // packages

                LastRequest := _WriteValues;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#StandardRequest)$^DINT, 1);
#endif

                //copy SDO into write-buffer
                ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #StandardRequest, size := (sizeof(SDOHeader.StdHeader.CRC) + StandardRequest.SDOHeader.Len));
                
                //mark SDO data as valid
                p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
                
                if ( pISafety^.udVersion >= 16#1001 ) then
                  SAFETY_iPushSafetyTask();
                end_if;
              else
                UnsafeScheduler := UnsafeSchedulerReadData;
              end_if;
            else
              UnsafeScheduler := UnsafeSchedulerReadData;
            end_if;
          else
            // on CSCP011 the SDO_COMMAND_WRITE_VALUES didn't exist
            if ui_CntUnsafeInputs & WriteFramesNeeded then
              // if writing is not active, check if it's necessary to activate it
              if (UnsafeWritingActive = FALSE) then
                pUnsafeInElement := p_UnsafeInputsTable;

                for i := 0 to (ui_CntUnsafeInputs - 1) do
                  if pUnsafeInElement^.ud_Thisp then
                    sd_retval := RD((pUnsafeInElement^.ud_Thisp)$^void);        // data
                    if pUnsafeInElement^.sd_OldValue <> sd_retval then
                      UnsafeWritingActive := TRUE;
                      pUnsafeInElement^.sd_OldValue := sd_retval;
                    end_if;
                  end_if;
                  pUnsafeInElement += sizeof(UnsafeIORoutingElement);
                end_for;
              end_if;

              // check if writing is already active
              if UnsafeWritingActive then
                // pointer to the right unsafe input
                pUnsafeInElement := p_UnsafeInputsTable + (UnsafeWriteTransNr * MaxVarsPerWritePackage * sizeof(UnsafeIORoutingElement));

                // get length of data we write
                if (UnsafeWriteTransNr < (WriteFramesNeeded-1)) | ((ui_CntUnsafeInputs MOD MaxVarsPerWritePackage) = 0) then
                  DataLen := MaxVarsPerWritePackage * sizeof(DINT);
                else
                  DataLen := (ui_CntUnsafeInputs MOD MaxVarsPerWritePackage)$USINT * sizeof(DINT);
                end_if;

                StandardRequest.SDOHeader.Cmd   := SB_SDO_COMMAND_WRITE;                        // write command
                StandardRequest.SDOHeader.Typ   := SDO_STD;                                     // standard frame type     
                StandardRequest.SDOHeader.SeqNr := StandardSeqNr OR 16#80;                      // sequence number is in special area
                StandardRequest.SDOHeader.Len   := 4 + 4 + 1 + DataLen;                         // header + destination address + length of data + data
                StandardRequest.aData[0]$UDINT  := pUnsafeInElement^.ud_Address;                // destination address
                StandardRequest.aData[4]        := DataLen;                                     // length of data
                
                // depending on length we do different number of server read-methods to get the data we write
                for i := 0 to (DataLen/sizeof(DINT)) - 1 do
                  if pUnsafeInElement^.ud_Thisp then
                    StandardRequest.aData[5 + (i * sizeof(DINT))]$DINT := pUnsafeInElement^.sd_OldValue;
                  else
                    // this server doesn't exist in lasal => always send 0
                    StandardRequest.aData[5 + (i * sizeof(DINT))]$DINT := 0;
                  end_if;

                  pUnsafeInElement += sizeof(UnsafeIORoutingElement);
                end_for;

                LastRequest := _WriteValues;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#StandardRequest)$^DINT, 1);
#endif

                //copy SDO into write-buffer
                ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #StandardRequest, size := (sizeof(SDOHeader.StdHeader.CRC) + StandardRequest.SDOHeader.Len));
                
                //mark SDO data as valid
                p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
                
                if ( pISafety^.udVersion >= 16#1001 ) then
                  SAFETY_iPushSafetyTask();
                end_if;
              else
                UnsafeScheduler := UnsafeSchedulerReadData;
              end_if;      
            else
              UnsafeScheduler := UnsafeSchedulerReadData;
            end_if;
          end_if;

       (* ***************************************** *)
          UnsafeSchedulerReadData:
       (* ***************************************** *)
          if ui_CntUnsafeOutputs & ReadFramesNeeded then
            //check, if buffer is empty and we got some unsafe data to get/set and crc check is finished
            if (UnsafeReadTransNr < ReadFramesNeeded) //then
             & ( ((UnsafeReadTransNr = 0) & ( ops.tAbsolute - LastUnsafeUpdate > ud_ServerUpdateTime ) ) | (UnsafeReadTransNr <> 0) )then
              // here we request directly the unsafe IOs
              
              // sequence number is in special area
              StandardRequest.SDOHeader.SeqNr := StandardSeqNr OR 16#80;
              
              // we get an output
              pUnsafeOutElement := p_UnsafeOutputsTable + (UnsafeReadTransNr * MaxVarsPerReadPackage * sizeof(UnsafeIORoutingElement));
              
              // get length of data we read
              if (UnsafeReadTransNr < (ReadFramesNeeded - 1)) | ((ui_CntUnsafeOutputs MOD MaxVarsPerReadPackage) = 0) then
                UnsafeRdPackageNo := MaxVarsPerReadPackage;
              else
                UnsafeRdPackageNo := (ui_CntUnsafeOutputs MOD MaxVarsPerReadPackage)$USINT;
              end_if;
              
              DataLen := UnsafeRdPackageNo * sizeof(DINT);

              // create buffer with addresses of values to read
              pHelpUnsafe := pUnsafeOutElement;
              for i := 0 to (UnsafeRdPackageNo-1) do
                aUnsafeRdPackages[i] := pHelpUnsafe^.ud_Address;
                pHelpUnsafe += sizeof(UnsafeIORoutingElement);
              end_for;

              StandardRequest.SDOHeader.Cmd               := SB_SDO_COMMAND_READ_VALUES;                  // read values command
              StandardRequest.SDOHeader.Typ               := SDO_STD;                                     // standard frame type
              StandardRequest.SDOHeader.SeqNr             := StandardSeqNr OR 16#80;                      // sequence number is in special area
              StandardRequest.SDOHeader.Len               := 4 + 1 + DataLen;                             // header + size + length of data
              StandardRequest.aData[0]                    := UnsafeRdPackageNo;                           // number of values to get
              StandardRequest.aData[1]$UnsafeReadPackages := aUnsafeRdPackages;                           // read addresses
                    
              LastRequest := _ReadValues;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#StandardRequest)$^DINT, 1);
#endif

              //copy SDO into write-buffer
              ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #StandardRequest, size := (sizeof(SDOHeader.StdHeader.CRC) + StandardRequest.SDOHeader.Len));
              
              //mark SDO data as valid
              p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
              
              if ( pISafety^.udVersion >= 16#1001 ) then
                SAFETY_iPushSafetyTask();
              end_if;

            elsif (UnsafeReadTransNr >= ReadFramesNeeded) then
              // We have finished all read data, go on with the next step
              UnsafeScheduler := UnsafeSchedulerDiagState;
              LastUnsafeUpdate := ops.tAbsolute;
              UnsafeReadTransNr := 0;
            else
              // time until read is not yet over - go on
              UnsafeScheduler := UnsafeSchedulerDiagState;
            end_if;
          else
            UnsafeScheduler := UnsafeSchedulerDiagState;
          end_if;

       (* ***************************************** *)
          UnsafeSchedulerDiagState:
       (* ***************************************** *)
          // get the diag state (on user demand)
          if DiagVars.UserWantsDiagState then
            
            // get state via SDO communication                                  
            SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_GET_STATE;                            // get-state command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            SDORequestBuffer.StdHeader.Len  := 4;                                                   // header
            SDORequestBuffer.ud_Address     := 0;
            SDORequestBuffer.us_Length      := 0;

            LastRequest := _DiagState;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#SDORequestBuffer)$^DINT, 1);
#endif

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;
          else
            UnsafeScheduler := UnsafeSchedulerDiagInfo;
          end_if;

       (* ***************************************** *)
          UnsafeSchedulerDiagInfo:
       (* ***************************************** *)
       
          // get the diag info (on user demand)
          if DiagVars.UserWantsDiagInfo then
            
            // get state via SDO communication                               
            StandardRequest.SDOHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            StandardRequest.SDOHeader.Cmd  := SB_SDO_COMMAND_GET_DIAG_INFO;                        // read command
            StandardRequest.SDOHeader.Typ  := SDO_STD;                                             // standard frame type
            StandardRequest.SDOHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            StandardRequest.SDOHeader.Len  := 4 + 1;                                               // header + µC-selection
            StandardRequest.aData[0] := DiagVars.ucChoiceDiagInfo;

            LastRequest := _DiagInfo;

#ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#StandardRequest)$^DINT, 1);
#endif

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #StandardRequest, size := (sizeof(SDOHeader.StdHeader.CRC) + StandardRequest.SDOHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;
            
          else
            
            if SchedulerStepNo = 6 then
              UnsafeScheduler := UnsafeSchedulerGetDiagVars; 
              
            elsif SchedulerStepNo = 7 then
              UnsafeScheduler := UnsafeSchedulerGetRetryCounter;            
            end_if;

          
          end_if;
       (* ***************************************** *)
          UnsafeSchedulerGetRetryCounter:
       (* ***************************************** *)
           //read out the retry counters every 10seconds
          if (ops.tAbsolute - ud_RetryCntTimeMark) > SB_RETRY_COUNTER_WAIT_TIME  then
            
            SDORequestBuffer.StdHeader.CRC  := 0;                                                         // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_READ;                                       // read command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                                   // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                                    // sequence number
            SDORequestBuffer.StdHeader.Len  := 4 + 4 + SB_SDO_LENGTH_RETRY_COUNTER;                       // header + destination address + length of data
            SDORequestBuffer.ud_Address     := SB_SDO_ADDRESS_RETRY_COUNTER;                              // address of retrycounter
            SDORequestBuffer.us_Length      := SB_SDO_LENGTH_RETRY_COUNTER;                               // length of data        
            
            LastRequest := _ReadRetryCounter; 
            
            
  #ifdef SAFETY_PROTOCOL_ANALYZER_ACTIVATED
  RecordFrame((#SDORequestBuffer)$^DINT, 1);
  #endif

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));

            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;
            
            //reset timemark
            ud_RetryCntTimeMark := ops.tAbsolute;
            
          else
            UnsafeScheduler := UnsafeSchedulerGetDiagVars; 
          end_if;
        else
          LogError("Undefined Scheduler-State");
        end_case; 
      end_while;
    end_if;
  end_if;

  // at the first run we write all variables independent of any changes
  if RunState > OldRunState then
    SendAllUnsafeValues();
  end_if;
  OldRunState := RunState;

	state := READY;

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StopTimeMeasurement(usMode := DMTIME_CY);
#endif	
//============================ Profiler end========================================================
END_FUNCTION


FUNCTION SafetyBase::GetPointer2IFPDOBuffer
	VAR_OUTPUT
		ud_PDOBuffer 	: UDINT;
	END_VAR

  IFPDOOutputIsUsed := TRUE;

  //set pointer to address of buffer pointer
  ud_PDOBuffer := ( #IFPDOOutputBuffer )$UDINT;
   
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::GetConfiguration

END_FUNCTION


FUNCTION SafetyBase::AddMovDOs
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	tempCmd         : CmdStruct;
    _result         : results;
    dataADDDO       : t_AddMoveDOCfg;
    i               : DINT;
  END_VAR
  
  ret_code := READY;

  // at the connect of the module we read the needed write size (written by the safety designer). at this point we know if the module needs data. if not => no move necessary
  if MyPDOWriteSize = 0 then
    return;
  end_if;

  // this stays the same for every DO
  tempCmd.uiCmd     := _BUS_IF_ADD_MOVE_DO;
  tempCmd.aPara[0]  := (#dataADDDO)$DINT;
  
  // initialize the parameter structure
  dataADDDO.ud_length_move        := MyPDOWriteSize;
  dataADDDO.ud_handle_source      := 0; // is set via SdiasManager or similar
  dataADDDO.ud_addressoff_source  := 0; // is set via SdiasManager or similar
  dataADDDO.p_sourcedata          := pPDOReadData;
  dataADDDO.ud_handle_dest        := 0; // is set via SdiasManager or similar
  dataADDDO.ud_addressoff_dest    := 0; // is set via SdiasManager or similar
  dataADDDO.p_destdata            := pPDOWriteData;
  dataADDDO.Priority              := _BUS_IF_ISO_MOVE;
  
  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
    InputMovSettings.MoveSettingsBusIF.Handle               := _result.aData$t_AddMoveDORet.Handle;
    InputMovSettings.MoveSettingsBusIF.ud_length_move       := dataADDDO.ud_length_move;
    InputMovSettings.MoveSettingsBusIF.ud_handle_source     := dataADDDO.ud_handle_source;
    InputMovSettings.MoveSettingsBusIF.ud_addressoff_source := dataADDDO.ud_addressoff_source;
    InputMovSettings.MoveSettingsBusIF.p_sourcedata         := dataADDDO.p_sourcedata;
    InputMovSettings.MoveSettingsBusIF.ud_handle_dest       := dataADDDO.ud_handle_dest;
    InputMovSettings.MoveSettingsBusIF.ud_addressoff_dest   := dataADDDO.ud_addressoff_dest;
    InputMovSettings.MoveSettingsBusIF.p_destdata           := dataADDDO.p_destdata;
    InputMovSettings.EnableState                            := _BUS_IF_RUN_STATE_NO_RUN;
    
    // addresses of local PDOs (set after creating the Move-DO, because we don't have the pointers to the DPRAM before (only in local memory)
    ud_LocalMoveSourceAddr := dataADDDO.p_sourcedata$UDINT;
    ud_LocalMoveDestAddr   := dataADDDO.p_destdata$UDINT;
    
    ud_LocalReadHandle     := dataADDDO.ud_handle_source;
    ud_LocalReadOffset     := dataADDDO.ud_addressoff_source;
    
    ud_LocalWriteHandle    := dataADDDO.ud_handle_dest;
    ud_LocalWriteOffset    := dataADDDO.ud_addressoff_dest;
  else
    LogError("(SafetyBase::AddMovDOs) Failed to add move DO");
    ret_code := ERROR;
  end_if;

  if (AdditionalSPDOs > 0) then      
    for i := 0 to (AdditionalSPDOs-1) do
      dataADDDO.p_destdata  := aAdditionalPDOs[i].pPDOWriteData;

      ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
      if _result.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.Handle                := _result.aData$t_AddMoveDORet.Handle;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.ud_length_move        := dataADDDO.ud_length_move;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.ud_handle_source      := dataADDDO.ud_handle_source;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.ud_addressoff_source  := dataADDDO.ud_addressoff_source;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.p_sourcedata          := dataADDDO.p_sourcedata;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.ud_handle_dest        := dataADDDO.ud_handle_dest;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.ud_addressoff_dest    := dataADDDO.ud_addressoff_dest;
        aAdditionalPDOs[i].InputMovSettings.MoveSettingsBusIF.p_destdata            := dataADDDO.p_destdata;
        aAdditionalPDOs[i].InputMovSettings.EnableState                             := _BUS_IF_RUN_STATE_NO_RUN;

        aAdditionalPDOs[i].ud_LocalMoveDestAddr := dataADDDO.p_destdata$UDINT;
        aAdditionalPDOs[i].ud_LocalWriteHandle  := dataADDDO.ud_handle_dest$UDINT;
        aAdditionalPDOs[i].ud_LocalWriteOffset  := dataADDDO.ud_addressoff_dest$UDINT;
      else
        LogError("(SafetyBase::AddMovDOs) Failed to add move DO for additional write PDOs");
        ret_code := ERROR;
      end_if;
    end_for;
  end_if;

  // now get the access info needed for the move command
  tempCmd.uiCmd     := _BUS_IF_GET_ACCESS_INFO;
  tempCmd.aPara[0]  := pPDOIFReadData$DINT;

  ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
  if _result.aData[0]$t_AccessInfoRet.retcode = _BUS_IF_RETVAL_OK then
    ud_LocalMoveIFSourceAddr  := (_result.aData[0]$t_AccessInfoRet.p_dataDPRAM)$HDINT;
    ud_LocalIFReadHandle      := _result.aData[0]$t_AccessInfoRet.ud_handle;
    ud_LocalIFReadOffset      := _result.aData[0]$t_AccessInfoRet.ud_addressoff;
  else
    LogError("(SafetyBase::AddMovDOs) Failed to get access info for interface read access");
    ret_code := ERROR;
  end_if;

  b_MoveDOsCreated := TRUE;

END_FUNCTION


FUNCTION SafetyBase::UpdateMovDO
	VAR_INPUT
		p_MoveSettings 	: ^t_MoveSettings;
		ud_NewSourceHandle 	: UDINT;
		ud_NewSourceOffset 	: UDINT;
		ud_NewSourcePointer 	: UDINT;
		ui_NewLength 	: UINT;
	END_VAR
  VAR
  	b_DifferenceDetected : BOOL;
  	tempCmd         : CmdStruct;
    _result         : results;
  END_VAR
  
  // check if there is a difference to the old settings
  b_DifferenceDetected := FALSE;
  
  if ud_NewSourceHandle <> p_MoveSettings^.MoveSettingsBusIF.ud_handle_source then
    p_MoveSettings^.MoveSettingsBusIF.ud_handle_source := ud_NewSourceHandle;
    b_DifferenceDetected := TRUE;
  end_if;

  if ud_NewSourceOffset <> p_MoveSettings^.MoveSettingsBusIF.ud_addressoff_source then
    p_MoveSettings^.MoveSettingsBusIF.ud_addressoff_source := ud_NewSourceOffset;
    b_DifferenceDetected := TRUE;
  end_if;

  if ud_NewSourcePointer <> p_MoveSettings^.MoveSettingsBusIF.p_sourcedata$UDINT then
    p_MoveSettings^.MoveSettingsBusIF.p_sourcedata$UDINT := ud_NewSourcePointer;
    b_DifferenceDetected := TRUE;
  end_if;

  if ui_NewLength <> p_MoveSettings^.MoveSettingsBusIF.ud_length_move then
    p_MoveSettings^.MoveSettingsBusIF.ud_length_move := ui_NewLength;
    b_DifferenceDetected := TRUE;
  end_if;
  
  // if there is a difference to the old settings => change the move DO
  if b_DifferenceDetected then
    tempCmd.uiCmd     := _BUS_IF_UPDATE_MOVE_DO;
    tempCmd.aPara[0]  := (#p_MoveSettings^.MoveSettingsBusIF)$DINT;
        
    ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
    if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then
      LogError("(SafetyBase::UpdateMovDO) Failed to change move-DO");
    end_if;
  end_if;
  
  // if the Move-DO is'nt started
  if p_MoveSettings^.EnableState <> _BUS_IF_RUN_STATE_CONT_RUN then
    // => start it, because we have to move in every cycle
    SetDORunState(Handle := p_MoveSettings^.MoveSettingsBusIF.Handle, NewState:=_BUS_IF_RUN_STATE_CONT_RUN);
    p_MoveSettings^.EnableState := _BUS_IF_RUN_STATE_CONT_RUN;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::SetSafetyState
	VAR_INPUT
		NewState 	: SafetyConfigStateType;
	END_VAR

  // use it locally => can also be forwarded in derivation
  SafetyState := NewState;

END_FUNCTION


FUNCTION VIRTUAL SafetyBase::RefreshAsySrv
  // derive this
END_FUNCTION


FUNCTION VIRTUAL SafetyBase::SetRetryCounter

  SafetyRetryCounter := -1;
  
END_FUNCTION


FUNCTION SafetyBase::IsInCache
	VAR_INPUT
		ud_Address 	: UDINT;
		us_Length 	: USINT;
	END_VAR
	VAR_OUTPUT
		ItsInside 	: BOOL;
	END_VAR

  if CachedSize &
     (ud_Address >= CachedAddr) &
     ((ud_Address + us_Length) <= (CachedAddr + CachedSize)) then
    ItsInside := TRUE;
  else
    ItsInside := FALSE;
  end_if;

END_FUNCTION


FUNCTION SafetyBase::AddToCache
	VAR_INPUT
		p_SDORequestBuffer 	: ^SDORequReadConfig;
		p_SDOResponseBuffer 	: ^SDORespReadConfig;
	END_VAR

  if p_SDORequestBuffer^.us_Length then
    CachedAddr := p_SDORequestBuffer^.ud_Address;
    CachedSize := p_SDORequestBuffer^.us_Length;
    _memcpy(ptr1:=#Cache, ptr2:=#p_SDOResponseBuffer^.ud_Data, cntr:=p_SDORequestBuffer^.us_Length);
  end_if;

END_FUNCTION
