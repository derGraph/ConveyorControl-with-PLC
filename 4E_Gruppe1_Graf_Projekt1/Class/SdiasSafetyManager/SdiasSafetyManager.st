//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\SdiasSafetyManager\SdiasSafetyManager.h"
#include "..\..\Class\SdiasManager\SdiasManager.h"

(*!
<Class
	Name               = "SdiasSafetyManager"
	Revision           = "1.25"
	GUID               = "{6FBD76A2-0A99-4F57-A9DF-7CF82984424F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Safety.ico"
	SharedCommandTable = "true"
	Objectsize         = "(670,120)">
	<Channels>
		<Server Name="CanOut" GUID="{CB55BF80-F965-4F8C-9CAD-9F670106CDEF}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassSvr">
		</Server>
		<Server Name="DesignerPrjName" GUID="{1EDD0C5B-6B2C-453F-8C0E-8DD1592A1FBA}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="DesignerPrjRev" GUID="{BED72B78-EFE4-41A7-B1C1-C778A9AF18F7}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="FastUnsafeInputs" GUID="{6C8E124B-3C5E-40E6-A4A8-8F32D5EFD74E}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="FastUnsafeOutputs" GUID="{35134FCD-2E3B-49BE-A31C-EB4BDCA5D659}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="SdiasSafetyOut" GUID="{42C79A2C-03BB-441B-BF91-1C561077C787}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ValidationButtonState" GUID="{1A865F4D-AC2D-4D2A-AC13-81FFC1931D46}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the validation button&#13;&#10;0: Validation button not used at the moment&#13;&#10;1: Select a command by pressing the button&#13;&#10;2: Command is executed&#13;&#10;3: Error in module"/>
		<Client Name="ProjectNameStr" Required="true" Internal="true"/>
		<Client Name="ProjectRevisionStr" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SdiasSafetyManager\SdiasSafetyManager.h" Include="true"/>
			<File Path=".\Class\SdiasManager\SdiasManager.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.25" Date="31.08.2015" Author="RamAnd" Company="Sigmatek" Description="If no configuration is available at the CPU, the optional settings are now ignored since they are not available in this state. This could have lead to SDIAS errors if safety modules were set to required."/>
		<Dokumentation Revision="1.24" Date="31.07.2015" Author="RamAnd" Company="Sigmatek" Description="Added server DesignerPrjConfigCRC to show the CRC of the SafetyDesigner project.&#13;&#10;Added support for optional Safe-IOs (configured in SafetyDesigner)."/>
		<Dokumentation Revision="1.23" Date="14.04.2015" Author="RamAnd" Company="Sigmatek" Description="Configured sync out of pll so firmware can detect a reset of the application."/>
		<Dokumentation Revision="1.22" Date="11.02.2015" Author="RamAnd&#13;&#10;&#13;&#10;EisMic" Company="Sigmatek" Description="If slave configurations have been used, it has been necessary to restart the application more than once.&#13;&#10;SDO Requests of the SafetyCPU now get disabled during initialisation of the module to prevent timeouts at the SDO transfer. (Safety CIL-Version 1.2 needed)&#13;&#10;Wrong State at server SafetyState if an HBG was connected to the SCP."/>
		<Dokumentation Revision="1.21" Date="31.10.2014" Author="LanSte" Company="Sigmatek" Description="Fixed error: Safe IO were displayed on wrong safety hardwareclass if the class is not required and not online.&#13;&#10;Fixed error: Safe IO were displayed on wrong safety hardwareclass if the hardware configuration did not match the project configuration."/>
		<Dokumentation Revision="1.20" Date="08.10.2014" Author="RamAnd" Company="Sigmatek" Description="If the project name or one of the unsafe variable names had more than 56 characters, the string has not been fetched correctly from the firmware."/>
		<Dokumentation Revision="1.19" Date="31.07.2014" Author="PieSte" Company="Sigmatek" Description="Added NewInst command to quit error from connected safety modules."/>
		<Dokumentation Revision="1.18" Date="21.07.2014" Author="LanSte" Company="Sigmatek" Description="Added support for reading hardware diagnosis."/>
		<Dokumentation Revision="1.17" Date="04.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to detect a periphery reset which may be caused by a lost power supply.&#13;&#10;Crash fixed, if there is no IO module or HGB projected."/>
		<Dokumentation Revision="1.16" Date="25.04.2014" Author="RamAnd" Company="Sigmatek" Description="If a module is plugged via VARAN during runtime, the state of the class was set to _SafetyClassOK too early. This could have caused problems with the PDOs."/>
		<Dokumentation Revision="1.15" Date="24.04.2014" Author="RamAnd" Company="Sigmatek" Description="Clear module info at the servers of safe IO modules if a disconnect event occurs."/>
		<Dokumentation Revision="1.14" Date="22.04.2014" Author="EisMic" Company="Sigmatek" Description="Added new command for safetyretry counter. Only send values when the readout is available in the firmware."/>
		<Dokumentation Revision="1.13" Date="28.03.2014" Author="EisMic" Company="Sigmatek" Description="Added function to set retry counters of safety modules."/>
		<Dokumentation Revision="1.12" Date="25.03.2014" Author="RamAnd" Company="Sigmatek" Description="Changed read out of SafetyConfiguration to speed up startup time."/>
		<Dokumentation Revision="1.11" Date="26.03.2014" Author="ZoePat" Company="Sigmatek" Description="A connected HBG didn&apos;t work if no other safetymodul was use."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Invalid SDO Responses on the first SDO request to a module are now discarded. Now only a log message is shown instead of canceling the initialisation.&#13;&#10;Debug message if the number or size of DOs increased was too long and is now split up in 2 messages.&#13;&#10;Removed double assignment which could lead to a problem on ARM targets.&#13;&#10;Corrected handling of REAL variable which could lead to a memory problem on ARM targets."/>
		<Dokumentation Revision="1.0" Date="15.10.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SdiasSafetyManager">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{1713A788-AF54-4467-A458-A70B3CB0153D}"
				Class      = "SafetyBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="DesignerPrjConfigCRC"/>
					<Server Name="ErrorState"/>
					<Server Name="FirmwareVersion"/>
					<Server Name="QuitComError"/>
					<Server Name="RunState"/>
					<Server Name="SafetyNumber"/>
					<Server Name="SafetyRetryCounter"/>
					<Server Name="SafetyState"/>
					<Server Name="ServiceMode"/>
					<Server Name="VoltageOK"/>
					<Client Name="DeviceID"/>
					<Client Name="FileSys"/>
					<Client Name="ServerUpdateTime" Value="50"/>
					<Client Name="ToBusInterface"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "ProjectNameStr"
				GUID       = "{5E928B8B-DE93-4E55-BF01-79D1B70B8D33}"
				Class      = "String"
				Position   = "(600,960)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "ProjectRevisionStr"
				GUID       = "{A4C6B3B3-93A9-4170-90AB-5604A9FCF09C}"
				Class      = "String"
				Position   = "(600,1110)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1088,210),(904,210),"/>
			<Connection Source="this.SafetyState" Destination="_base.SafetyState" Vertices="(1088,270),(904,270),"/>
			<Connection Source="this.VoltageOK" Destination="_base.VoltageOK" Vertices="(1088,330),(904,330),"/>
			<Connection Source="this.RunState" Destination="_base.RunState" Vertices="(1088,390),(904,390),"/>
			<Connection Source="this.ServiceMode" Destination="_base.ServiceMode" Vertices="(1088,450),(904,450),"/>
			<Connection Source="this.ErrorState" Destination="_base.ErrorState" Vertices="(1088,510),(904,510),"/>
			<Connection Source="this.QuitComError" Destination="_base.QuitComError" Vertices="(1088,570),(904,570),"/>
			<Connection Source="this.FirmwareVersion" Destination="_base.FirmwareVersion" Vertices="(1088,630),(904,630),"/>
			<Connection Source="this.SafetyNumber" Destination="_base.SafetyNumber" Vertices="(1088,690),(904,690),"/>
			<Connection Source="_base.ServerUpdateTime" Destination="this.ServerUpdateTime" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.ToBusInterface" Destination="this.ToBusInterface" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.DeviceID" Destination="this.DeviceID" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.ProjectNameStr" Destination="ProjectNameStr.Data"/>
			<Connection Source="this.ProjectRevisionStr" Destination="ProjectRevisionStr.Data"/>
			<Connection Source="this.DesignerPrjName" Destination="ProjectNameStr.Data" Vertices="(1088,870),(916,1050),"/>
			<Connection Source="this.DesignerPrjRev" Destination="ProjectRevisionStr.Data" Vertices="(1088,930),(916,1200),"/>
			<Connection Source="this.SafetyRetryCounter" Destination="_base.SafetyRetryCounter" Vertices="(1088,750),(904,750),"/>
			<Connection Source="this.DesignerPrjConfigCRC" Destination="_base.DesignerPrjConfigCRC" Vertices="(1088,810),(904,810),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SafetyBase

SdiasSafetyManager : CLASS
: SafetyBase
	TYPE
	  t_CheckIDSSW :
	  (
	    _Nothing,
	    _Wait4Idle,
	    _GetIDs
	  )$UDINT;
	  t_ConfigSSW :
	  (
	    _PrepareAccess,
	    _StartFirstAccess,
	    _StartAccess,
	    _Wait4Answer
	  )$UDINT;
#pragma pack(push, 1)
	  t_ConfigStruct : STRUCT
	    pData : pVoid;
	    Length : UINT;
	    Offset : HDINT;
	    BusConfigSSW : t_ConfigSSW;
	    SDOTimeMark : UDINT;
	    RestLength : UINT;
	    pActData : pVoid;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_HBG : STRUCT
	    pThis : pVirtualBase;
	    usExpectedDeviceID : USINT;
	    sdRequired : DINT;
	    pIOStates : ^HDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _PrepareInit,
	    _GetOptionalSettings,
	    _ReadModuleIDs,
	    _GetSafetyNr:=3,
	    _GetFirmwareVersion:=4,
	    _GetConfiguredState:=5,
	    _GetPDOSizes:=6,
	    _DisablePLL:=7,
	    _GetPLLSettings:=8,
	    _ConfigurePLL:=9,
	    _Finished:=10,
	    _InitError:=11
	  )$UDINT;
#pragma pack(push, 1)
	  t_LastSDO : STRUCT
	    Command : HINT;
	    Offset : DINT;
	    Length : UINT;
	    ResponseArrived : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LedAndIOStates : STRUCT
	    biLEDs : BINT
	    [
	      1 ValidationButtonBit0,
	      2 ValidationButtonBit1,
	      9 CanActiveBit0,
	      10 CanActiveBit1,
	      11 RunStateBit0,
	      12 RunStateBit1,
	      13 ServiceModeBit0,
	      14 ServiceModeBit1,
	      15 ErrorStateBit0,
	      16 ErrorStateBit1,
	    ];
	    HBGInputs : BINT
	    [
	    ];
	    IOStates : ARRAY [0..63] OF BSINT
	    [
	    ];
	  END_STRUCT;
#pragma pack(pop)
	  t_ModuleIDs : ARRAY [0..16] OF USINT;
#pragma pack(push, 1)
	  t_OptionalSettings : STRUCT
	    OptionalFlagsIOModules : BINT
	    [
	    ];
	    OptionalFlagHBG : BSINT
	    [
	    ];
	    ModuleIDsConfigured : ARRAY [0..15] OF USINT;
	    ModuleIDHBG : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SyncConfig : STRUCT
	    Offset : UINT;
	    PeriodMultiplier : USINT;
	    SyncStartDelay : USINT;
	    SyncOutID : USINT;
	    ControlStatusRegister : BSINT
	    [
	      1 SyncOutEnable,
	      2 StartDelayEnable,
	      3 SyncSelector,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PllRegister : STRUCT
	    SystemPeriodTime : UDINT;
	    SystemPeriodMeasured : UDINT;
	    StatusControl : BSINT
	    [
	      1 Locked,
	      2 Unlocked,
	      3 SyncEnable,
	    ];
	    PeriodDivider : BSINT
	    [
	    ];
	    CompensationDelay : USINT;
	    Reserved : USINT;
	    SyncOut0 : t_SyncConfig;
	    reserved2 : UINT;
	    SyncOut1 : t_SyncConfig;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
	  t_SerNoStr : ARRAY [0..11] OF CHAR;
#pragma pack(push, 1)
	  t_SafetySerNr : STRUCT
	    aSafetyNumbers : ARRAY [0..15] OF HDINT;
	    aSerialNumbers : ARRAY [0..15] OF t_SerNoStr;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SdiasSafetyModuleInfo : STRUCT
	    pThis : pVirtualBase;
	    usExpectedDeviceID : USINT;
	    sdRequired : DINT;
	    usInputsNeeded : USINT;
	    usOutputsNeeded : USINT;
	    usIOsNeeded : USINT;
	    hdOutputMask : HDINT;
	    pIOStates : ^HDINT;
	    pUnsafeOutputStates : ^HDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	DesignerPrjName 	: SvrChCmd_UDINT;
	DesignerPrjRev 	: SvrChCmd_UDINT;
	ValidationButtonState 	: SvrCh_DINT;
	FastUnsafeInputs 	: SvrCh_BDINT;
	FastUnsafeOutputs 	: SvrCh_BDINT;
	SdiasSafetyOut 	: SvrChCmd_DINT;
	CanOut 	: SvrChCmd_DINT;
  //Clients:
	ProjectNameStr 	: CltChCmd_String;
	ProjectRevisionStr 	: CltChCmd_String;
  //Variables:
		aSafetyModuleInfo : ARRAY [0..SDIAS_SAFETY_MAX_PLACE_NR] OF t_SdiasSafetyModuleInfo;

		aModuleIDs 	: t_ModuleIDs;
		MaxPlace 	: UDINT;
		Config 	: t_ConfigStruct;
		sPllRegister 	: t_PllRegister;
		eInitSSW 	: t_InitSSW;
		eInitSSWErrorStep 	: t_InitSSW;
		eInitAccessSSW 	: t_InitSSW;
		eInitAccessSSWErrorStep 	: t_InitSSW;
		eResponseState 	: t_ResponseState;
		SDOTimeMark 	: UDINT;
		LastSDO 	: t_LastSDO;
		b_AnyModuleRequired 	: BOOL;
		StateBytesUsed 	: UDINT;
		StateBitsUsed 	: UDINT;
		sHBG 	: t_HBG;
		sSafetySerNrs 	: t_SafetySerNr;
		CanActive 	: BOOL;
		OldCanActive 	: BOOL;
		b_DOsCreated 	: BOOL;
		RtRefreshData 	: t_RtRefresh;
		eCheckIDSSW 	: t_CheckIDSSW;
		pFastUnsafeOutThis 	: pVirtualBase;
		bUpdateModuleConfig 	: BOOL;
		b_GetOptionalSettings 	: BOOL;
		b_GotOptionalSettings 	: BOOL;
		OptionalSettings 	: t_OptionalSettings;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION SdiasSafetyManager
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="initialize safety module (e.g. CPU) specific data" Name="InitSafeModule"/>
	FUNCTION VIRTUAL InitSafeModule
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="update of non SDO and PDO data" Name="UpDateNotStd"/>
	FUNCTION VIRTUAL UpDateNotStd;
	
	FUNCTION VIRTUAL ShowProjectRevision;
	
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
	
	FUNCTION VIRTUAL GetConfiguration;
	
	FUNCTION VIRTUAL SetSafetyState
		VAR_INPUT
			NewState 	: SafetyConfigStateType;
		END_VAR;
	
	FUNCTION VIRTUAL RefreshAsySrv;
	
	FUNCTION VIRTUAL SetRetryCounter;
	
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			ModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL InitAccess
		VAR_OUTPUT
			AccessInitState 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL BusConfigWrite
		VAR_INPUT
			Offset 	: HDINT;
			Length 	: UINT;
			pData 	: pVoid;
			IsControlAccess 	: BOOL := FAL;
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL BusConfigRead
		VAR_INPUT
			Offset 	: HDINT;
			Length 	: UINT;
			pData 	: pVoid;
			IsControlAccess 	: BOOL := FAL;
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeInputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastUnsafeOutputs::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SdiasSafetyOut::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CanOut::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SdiasSafetyManager::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDIASSAFETYMANAGER
1$UINT, 25$UINT, (SIZEOF(::SdiasSafetyManager))$UINT, 
7$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2292222393), "SdiasSafetyManager", //Class
TO_UDINT(4109957215), "SafetyBase", 1$UINT, 22$UINT, //Baseclass
//Servers:
(::SdiasSafetyManager.DesignerPrjName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2397083450), "DesignerPrjName", 
(::SdiasSafetyManager.DesignerPrjRev.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2854741250), "DesignerPrjRev", 
(::SdiasSafetyManager.ValidationButtonState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2335086012), "ValidationButtonState", 
(::SdiasSafetyManager.FastUnsafeInputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1891345754), "FastUnsafeInputs", 
(::SdiasSafetyManager.FastUnsafeOutputs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(766673388), "FastUnsafeOutputs", 
(::SdiasSafetyManager.SdiasSafetyOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1660330439), "SdiasSafetyOut", 
(::SdiasSafetyManager.CanOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4133122455), "CanOut", 
//Clients:
(::SdiasSafetyManager.ProjectNameStr.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1313311979), "ProjectNameStr", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::SdiasSafetyManager.ProjectRevisionStr.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1540301848), "ProjectRevisionStr", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_SdiasSafetyManager 73

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SdiasSafetyManager] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SdiasSafetyManager::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SafetyBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SafetyBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SafetyBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SdiasSafetyManager;
	vmt.CmdTable.NewInstr		:= #ClassSvr::NewInst();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #InitSafeModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #UpDateNotStd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #ShowProjectRevision();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[64]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[66]		:= #GetConfiguration();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[67]		:= #SetSafetyState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[68]		:= #RefreshAsySrv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[69]		:= #SetRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[70]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[71]		:= #BusConfigWrite();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[72]		:= #BusConfigRead();

#pragma warning (default : 74)
	SafetyBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SafetyBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DesignerPrjRev.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DesignerPrjRev.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DesignerPrjRev.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeInputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeInputs::Write() );
	IF FastUnsafeInputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastUnsafeOutputs.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastUnsafeOutputs::Write() );
	IF FastUnsafeOutputs.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SdiasSafetyOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #SdiasSafetyOut::NewInst();
	SdiasSafetyOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasSafetyOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CanOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #CanOut::NewInst();
	CanOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SdiasSafetyManager();

END_FUNCTION

//{{LSL_IMPLEMENTATION
VAR_EXTERNAL
  pSafetyManagerThis   : pVirtualBase;
// b_SafetyOnLocalCDIAS = TRUE means there is a CDIAS safety module on local CDIAS/SDIAS Bus => using internal move command is not possible
  b_SafetyOnLocalCDIAS : BOOL;
END_VAR

VAR_PRIVATE  
  a_SerialNo			      : ARRAY[0..sizeof(SdiasSafetyManager::t_SerNoStr) ] OF CHAR;  
  a_HWTEntryStr         : ARRAY[0.. VARAN_MAX_DEPTH+1] OF CHAR; //+1 because lenght is 2 byte
END_VAR

FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::SdiasSafetyOut::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	Place             : UDINT;
  	tempCmd           : CmdStruct;
    _result           : results;
    pSafetyModuleInfo : ^t_SdiasSafetyModuleInfo;
  END_VAR
  
	ret_code := READY;

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		SDIAS_SAFETY_LOGIN:
      // check parameters
      if pPara^.aPara[0] & (pPara^.aPara[1]$UDINT < SDIAS_SAFETY_MAX_MODULE_NO) then
        // save the module info
        Place := pPara^.aPara[1]$UDINT;
        pSafetyModuleInfo := #aSafetyModuleInfo[Place];
        
        pSafetyModuleInfo^.pThis               := pPara^.aPara[0]$pVirtualBase;
        pSafetyModuleInfo^.usExpectedDeviceID  := pPara^.aPara[2]$USINT;
        pSafetyModuleInfo^.sdRequired          := pPara^.aPara[3];
        pSafetyModuleInfo^.usInputsNeeded      := pPara^.aPara[4]$USINT;
        pSafetyModuleInfo^.usOutputsNeeded     := pPara^.aPara[5]$USINT;
        pSafetyModuleInfo^.pIOStates           := pPara^.aPara[6]$^HDINT;
        pSafetyModuleInfo^.pUnsafeOutputStates := pPara^.aPara[7]$^HDINT;

        // saves time, because we don't have to add them in rt
        pSafetyModuleInfo^.usIOsNeeded := pSafetyModuleInfo^.usInputsNeeded + pSafetyModuleInfo^.usOutputsNeeded;

        // output mask to write the correct number of outputs to the memory (set as many bits as we need outputs)
        pSafetyModuleInfo^.hdOutputMask := to_udint(2.0**to_real(pSafetyModuleInfo^.usOutputsNeeded)) - 1;

        InputsCount  += pSafetyModuleInfo^.usInputsNeeded;
        OutputsCount += pSafetyModuleInfo^.usOutputsNeeded;

        // remember the highest place to save time in module scanning operations
        if (Place > MaxPlace) | (MaxPlace = SDIAS_SAFETY_INVALID_MAX_PLACE) then
          MaxPlace := Place;
        end_if;
        
        // if leds/hgb not added so far, add them
        if StateBytesUsed = 0 then
          StateBitsUsed := (sizeof(t_LedAndIOStates.biLEDs) + sizeof(t_LedAndIOStates.HBGInputs)) * 8;
        end_if;
        
        // add the number of used bits (2 bits for every I/O)
        StateBitsUsed += 2 * pSafetyModuleInfo^.usIOsNeeded;
        
        // refresh state bytes used value
        StateBytesUsed := ((StateBitsUsed-1) / 8) + 1;
        
        if pSafetyModuleInfo^.sdRequired & (b_AnyModuleRequired = FALSE) then
          b_AnyModuleRequired := TRUE;
          // if any access is required => the businterface is also required
          tempCmd.uiCmd := _BUS_IF_SET_REQUIRED;
          ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
          if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then  
            LogError("(SdiasSafetyManager::SdiasSafetyOut::NewInst) Failed to set the BusInterface to required");
          end_if;
        end_if;
      else
        ret_code := ERROR;
      end_if; 
      
            
//**********************************************************************************************************************************************************
		SDIAS_SET_QUITCOMERROR_IO:
      ret_code$DINT := QuitComError.Write(input:=pPara^.aPara[0]);
      
//**********************************************************************************************************************************************************
    // forward commands from clients to manager 
    SDIAS_CMD_ADD_RD_ACCESS,
    SDIAS_CMD_ADD_WR_ACCESS,
    SDIAS_CMD_SDO_SEND_REQUEST,
    SDIAS_CMD_CHANGE_LED_STATE,
    SDIAS_CMD_DA_RD_ACCESS,
    SDIAS_CMD_DA_WR_ACCESS,
    SDIAS_CMD_REQUIRED_ERROR,
    SDIAS_CMD_INIT_STATE_LOGIN,
    SDIAS_CMD_GET_HW_PATH,
    SDIAS_CMD_INSTALL_CYCLIC_TASK:
      ret_code := ToBusInterface.NewInst(pPara, pResult);
//**********************************************************************************************************************************************************
	END_CASE;

END_FUNCTION


FUNCTION SdiasSafetyManager::SdiasSafetyManager
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  MaxPlace := SDIAS_SAFETY_INVALID_MAX_PLACE;

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::UpDateNotStd
  VAR
  	i                       : UDINT;
    pSafetyModuleInfo       : ^t_SdiasSafetyModuleInfo;
    sTempStates             : t_LedAndIOStates;
    pActIOStates            : ^BSINT;
    usActIOBitsUsed         : USINT;
    pActUnsafeOuts          : ^BSINT;
    usActUnsafeOutBitsUsed  : USINT;
		MyPara 	                : CmdStruct;
		MyResult	              : results;  	
  END_VAR

  // copy only as many data as we need (safe time, because this may be PCI accesses)
  _memcpy(ptr1:=#sTempStates, ptr2:=pLEDandIOStates, cntr:=StateBytesUsed);

  // if AcceptState bit is set => accept state
  if sTempStates.biLEDs.ValidationButtonBit1 then
    ValidationButtonState := sTempStates.biLEDs.ValidationButtonBit0;
  else
    // otherwise, we have a blink code => state 2 or 3
    ValidationButtonState := sTempStates.biLEDs.ValidationButtonBit0 OR 2#10;
  end_if;
  RtRefreshData.LEDValidationButtonState := ValidationButtonState;

  // if AcceptState bit is set => accept state
  if sTempStates.biLEDs.CanActiveBit1 then
    CanActive := sTempStates.biLEDs.CanActiveBit0;
  end_if;

  // if AcceptState bit is set => accept state
  if sTempStates.biLEDs.RunStateBit1 then
    RunState := sTempStates.biLEDs.RunStateBit0;
  else
    // otherwise, there's an error
    RunState := -1;
  end_if;
  RtRefreshData.LEDRunState := RunState;

  // if AcceptState bit is set => accept state
  if sTempStates.biLEDs.ServiceModeBit1 then
    ServiceMode := sTempStates.biLEDs.ServiceModeBit0;
  else
    // otherwise, we have a blink code => state 2
    ServiceMode := 2;
  end_if;
  RtRefreshData.LEDServiceMode := ServiceMode;

  // if AcceptState bit is set => accept state
  if sTempStates.biLEDs.ErrorStateBit1 then
    ErrorState := sTempStates.biLEDs.ErrorStateBit0;
  else
    // otherwise, we have a blink code => state 2
    ErrorState := 2;
  end_if;
  RtRefreshData.LEDErrorState := ErrorState;

  // if we got a HBG, refresh it's inputs first
  if sHBG.pThis then
    // select the IO bits for the next module (shift out the IO bits we already used before)
    sHBG.pIOStates^ := sTempStates.HBGInputs;

    // let the module update the io servers
    sHBG.pThis^.RtWork(0);
  end_if;

  // if there are modules to update
  if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
    pSafetyModuleInfo := #aSafetyModuleInfo[0];
    
    pActIOStates := #sTempStates.IOStates[0];
    usActIOBitsUsed := 0;
    
    pActUnsafeOuts := pUnsafeOutWrData;
    usActUnsafeOutBitsUsed := 0;
    for i := 0 to MaxPlace do
      if ((pSafetyModuleInfo^.pThis) & 
          (pSafetyModuleInfo^.pThis^.pSvrChCmd$t_e_VaranErrors = _ClassOk )) then
        // if there are inputs available
        if pSafetyModuleInfo^.usInputsNeeded then

//*****************************************************************************
//** IO STATES FOR THE LOCAL INPUTS                                          **
//*****************************************************************************

          // select the IO bits for the next module (shift out the IO bits we already used before)
          pSafetyModuleInfo^.pIOStates^ := (pActIOStates$^HDINT)^ SHR usActIOBitsUsed;

          // let the module update the io servers
          pSafetyModuleInfo^.pThis^.RtWork(0);
          
          // increase the number of used bits (every input needs 2 bit)
          usActIOBitsUsed += pSafetyModuleInfo^.usInputsNeeded * 2;
          
          // increase pointer if we already passed more than 1 byte
          pActIOStates += usActIOBitsUsed / 8;
          
          // remember the rest of the bits
          usActIOBitsUsed := usActIOBitsUsed MOD 8;
        end_if;
      end_if;

      pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
    end_for;

    // start again with the first module
    pSafetyModuleInfo := #aSafetyModuleInfo[0];

    // now we got the io states for the outputs
    for i := 0 to MaxPlace do
      if (( pSafetyModuleInfo^.pThis) & 
          ( pSafetyModuleInfo^.pThis^.pSvrChCmd$t_e_VaranErrors = _ClassOk )) then

//*****************************************************************************
//** IO STATES FOR THE LOCAL OUTPUTS                                         **
//*****************************************************************************
        // if there are outputs available
        if pSafetyModuleInfo^.usOutputsNeeded then

          // select the IO bits for the next module (shift out the IO bits we already used before)
          pSafetyModuleInfo^.pIOStates^ := (pActIOStates$^HDINT)^ SHR usActIOBitsUsed;

          // let the module update the io servers
          pSafetyModuleInfo^.pThis^.RtWork(1);
          
          // increase the number of used bits (every output needs 2 bit)
          usActIOBitsUsed += pSafetyModuleInfo^.usOutputsNeeded * 2;
          
          // increase pointer if we already passed more than 1 byte
          pActIOStates += usActIOBitsUsed / 8;
          
          // remember the rest of the bits
          usActIOBitsUsed := usActIOBitsUsed MOD 8;

//*****************************************************************************
//** UNSAFE ENABLE SIGNALS FOR OUTPUTS                                       **
//*****************************************************************************
          // we take the part of the old value which is not modified by our masked bits and save our masked bits into the right place
          (pActUnsafeOuts$^HDINT)^ := ((pActUnsafeOuts$^HDINT)^ AND (NOT (pSafetyModuleInfo^.hdOutputMask SHL usActUnsafeOutBitsUsed))) OR ((pSafetyModuleInfo^.pUnsafeOutputStates^ AND pSafetyModuleInfo^.hdOutputMask) SHL usActUnsafeOutBitsUsed);
          
          // increase the number of used bits
          usActUnsafeOutBitsUsed += pSafetyModuleInfo^.usOutputsNeeded;
          
          // increase pointer if we already passed more than 1 byte
          pActUnsafeOuts += usActUnsafeOutBitsUsed / 8;
          
          // remember the rest of the bits
          usActUnsafeOutBitsUsed := usActUnsafeOutBitsUsed MOD 8;
        end_if;
      end_if;

      pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
    end_for;
  end_if;
  
  // update fast unsafe variables
  if b_FastUnsafeInputsActive then
    pFastUnsafeInputs^ := FastUnsafeInputs;
  end_if;

  if b_FastUnsafeOutputsActive then
    FastUnsafeOutputs := pFastUnsafeOutputs^;
    RtRefreshData.FastUnsafeOutputs := FastUnsafeOutputs;
  end_if;
  
  MyPara.uiCmd := SDIAS_SET_RT_DATA;
  MyPara.aPara[0] := (#RtRefreshData)$DINT;
  ToBusInterface.NewInst(#MyPara, #MyResult);
  if pFastUnsafeOutThis then
    pFastUnsafeOutThis^.NewInst(#MyPara, #MyResult);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL SdiasSafetyManager::InitAccess
	VAR_OUTPUT
		AccessInitState 	: iprStates;
	END_VAR
  VAR
		SDORequestBuffer  : SDORequReadConfig;
    us_SDO_length     : USINT;
  END_VAR

  AccessInitState := BUSY;

  case eInitAccessSSW of      
//**********************************************************************************************************************************************************
    _PrepareInit:
      //add module to safety communication task with SDO
      if ( AddModuleToSafetyTask() ) then
        LogError(e_msg:="(SdiasSafetyManager::InitAccess) Failed to add module to safety task");
        eInitAccessSSWErrorStep := eInitAccessSSW;
        eInitAccessSSW := _InitError;
        return;
      end_if;

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=1);
        
        // clear the flag of the actual buffer if there is something
        if p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID then
          p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
        end_if;
      end_if;
#endif
      
      eInitAccessSSW := _GetConfiguredState;
      eResponseState := _idle;

//**********************************************************************************************************************************************************
    _GetConfiguredState:
      case eResponseState of
        _idle:
          if (LastRequest = _NoOpenRequest) & (p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA) then
          
            // get state via SDO communication                                  
            SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_GET_STATE;                            // get-state command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            SDORequestBuffer.StdHeader.Len  := 4;                                                   // header
            SDORequestBuffer.ud_Address     := 0;
            SDORequestBuffer.us_Length      := 0;

            LastRequest := _DiagState;

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;

            SDOTimeMark := ops.tAbsolute;
            eResponseState:= _wait; 
                  
            // check timeout
          elsif ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitAccess) Timeout while waiting for the SDO Send buffer to get ready (get configured state)");
            eInitAccessSSWErrorStep := eInitAccessSSW;
            eInitAccessSSW := _InitError;
          end_if;
          
      //*****************************************************
        _wait: // wait for response

          //read SDO from module and send it to the target module
          //check, if SDO is available and valid
          if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
        
            //calculate length of SDO
            us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
            
            //copy SDO without first byte (=status byte)
            ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

            //mark data as received
            p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
          
            //check, if it's our answer
            if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
              StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
              if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then
                if LastRequest = _DiagState then
                  if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_GET_STATE then
                    _memcpy(ptr1 := #DiagVars.UserGetStateResp, 
                            ptr2 := #StandardResponse.aData + SIZEOF(USINT), 
                            cntr := sizeof(GetStateResponseType) );

                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    eResponseState:= _valid; 
                  else
                    LogError(e_msg:="(SdiasSafetyManager::InitAccess) SDO Receive: Invalid command in standard frame response");
                  end_if;
                else
                  LogError(e_msg:="(SdiasSafetyManager::InitAccess) SDO Receive: Invalid standard frame response");
                end_if;

                // if request is deleted, increase sequence number to set next request
                if LastRequest = _NoOpenRequest then
                  if StandardSeqNr < 16#7F then
                    StandardSeqNr += 1;
                  else
                    StandardSeqNr := 0;
                  end_if;
                end_if;
              else
                LogError("(SdiasSafetyManager::InitAccess) SDO Receive: Invalid sequence number in Standard SDO response");
                LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
              end_if;
            else
              // ignore non-standard frames => the module may try to distribute it's configuration
            end_if;
          end_if;
        
          // check timeout
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitAccess) SDO Response timeout while waiting for the module configuration");
            eInitAccessSSWErrorStep := eInitAccessSSW;
            eInitAccessSSW := _InitError;
          end_if;
      //*****************************************************
        _valid:
          // if the module is configured and we didn't create the DOs so far
          if (DiagVars.UserGetStateResp.ConfigState <> SB_CFG_STATE_UNKNOWN) &
             (DiagVars.UserGetStateResp.ConfigState <> SB_CFG_STATE_INVALID) &
             (DiagVars.UserGetStateResp.ConfigState <> SB_CFG_STATE_NOT_CONFIGURED) &
             (b_DOsCreated = FALSE)
             then
             
            // remember to get the optional settings since the config seems to be ok
            b_GetOptionalSettings := TRUE;
            
            // get the pdo sizes
            eInitAccessSSW := _GetPDOSizes;
          else

            // don't get the optional settings, because there is no config => no optional settings to compare
            b_GetOptionalSettings := FALSE;

            // otherwise => assume them as zero
            _memset(dest:=#PdoSizeInfo, usByte:=0, cntr:=sizeof(t_PDOSizeInfo));

            eInitAccessSSW := _Finished;            
          end_if;

          eResponseState  := _idle;
      //*****************************************************
      end_case;
    
//**********************************************************************************************************************************************************
    _GetPDOSizes:
      case eResponseState of
        _idle:
            if (LastRequest = _NoOpenRequest) & (p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA) then
              SDORequestBuffer.StdHeader.CRC  := 0;                                                         // CRC is always 0 in Std communication
              SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_READ;                                       // read command
              SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                                   // standard frame type
              SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                                    // sequence number
              SDORequestBuffer.StdHeader.Len  := 4 + 4 + 1;                                                 // header + destination address + length of data
              SDORequestBuffer.ud_Address     := SB_SDO_ADDRESS_SPECIAL_INFO;                               // address of pdo size info
              SDORequestBuffer.us_Length      := sizeof(UDINT) + sizeof(t_PDOSizeInfo);                     // length info + length of pdo size info

              LastRequest := _ReadData;

              //copy SDO into write-buffer
              ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                    
              //mark SDO data as valid
              p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
              
              if ( pISafety^.udVersion >= 16#1001 ) then
                SAFETY_iPushSafetyTask();
              end_if;

              SDOTimeMark := ops.tAbsolute;
              eResponseState:= _wait; 
                  
              // check timeout
            elsif ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
              LogError("(SdiasSafetyManager::InitAccess) Timeout while waiting for the SDO Send buffer to get ready (get PDO sizes)");
              eInitAccessSSWErrorStep := eInitAccessSSW;
              eInitAccessSSW := _InitError;
            end_if;
            
      //*****************************************************
        _wait: // wait for response

          //read SDO from module and send it to the target module
          //check, if SDO is available and valid
          if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
        
            //calculate length of SDO
            us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
            
            //copy SDO without first byte (=status byte)
            ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

            //mark data as received
            p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
          
            //check, if it's our answer
            if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
              StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
              if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then
                if LastRequest = _ReadData then
                  // if we did read command, then save the value to corresponding server
                  if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ then
                    // if returncode is 0 read succeeded
                    if StandardResponse.aData[0] = 0 then
                      // delete request
                      LastRequest := _NoOpenRequest;
                      ud_AsyComRetryCounter := 0; // reset retry counter

                      if StandardResponse.aData[2]$UDINT >= (sizeof(UDINT) + sizeof(t_PDOSizeInfo)) then
                        // copy the pdo length info to our local memory
                        _memcpy(ptr1:=#PdoSizeInfo, 
                                ptr2:=#StandardResponse.aData[6], 
                                cntr:=sizeof(t_PDOSizeInfo));

                        MyPDOReadSize   := PdoSizeInfo.PDORdLen;
                        MyIFPDOReadSize := PdoSizeInfo.PDOIFRdLen;
                        MyPDOWriteSize  := PdoSizeInfo.PDOWrLen;
                        
                        // the 5 lower bits represent the number of write DOs needed
                        AdditionalSPDOs := (PdoSizeInfo.WrDONrFastUnsafe AND SB_PDO_WR_MASK) - 1;
                        
                        // the msb contains the info if there are fast unsafe IOs
                        ActivateFastUnsafeIOs := PdoSizeInfo.WrDONrFastUnsafe SHR 7;
                        
                        eResponseState:= _valid; 
                      else
                        LogError("(SdiasSafetyManager::InitAccess) SDO Receive: Invalid length of PDO size info");
                        eInitAccessSSWErrorStep := eInitAccessSSW;
                        eInitAccessSSW := _InitError;
                      end_if;
                    end_if;
                  else
                    LogError("(SdiasSafetyManager::InitAccess) SDO Receive: Invalid command, read expected");              
                    eInitAccessSSWErrorStep := eInitAccessSSW;
                    eInitAccessSSW := _InitError;
                  end_if;
                else
                  LogError(e_msg:="(SdiasSafetyManager::InitAccess) SDO Receive: Invalid standard frame response");
                  eInitAccessSSWErrorStep := eInitAccessSSW;
                  eInitAccessSSW := _InitError;
                end_if;

                // if request is deleted, increase sequence number to set next request
                if LastRequest = _NoOpenRequest then
                  if StandardSeqNr < 16#7F then
                    StandardSeqNr += 1;
                  else
                    StandardSeqNr := 0;
                  end_if;
                end_if;
              else
                LogError("(SdiasSafetyManager::InitAccess) SDO Receive: Invalid sequence number in Standard SDO response");
                LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
                eInitAccessSSWErrorStep := eInitAccessSSW;
                eInitAccessSSW := _InitError;
              end_if;
            else
              // ignore non-standard frames => the module may try to distribute it's configuration
            end_if;
          end_if;
        
          // check timeout
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitAccess) SDO Response timeout while waiting for the module configuration");
            eInitAccessSSWErrorStep := eInitAccessSSW;
            eInitAccessSSW := _InitError;
          end_if;
      //*****************************************************
        _valid:
          eInitAccessSSW := _Finished;
          eResponseState  := _idle;
      //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _Finished:
      eInitAccessSSW         := _PrepareInit;
      
      if b_DOsCreated then
        AccessInitState := READY;
      else
        AccessInitState := AddDO();
        b_DOsCreated    := TRUE;
      end_if;
      
      if AccessInitState = READY then
        b_ModuleAccessReady := TRUE;
      end_if;

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=0);
      end_if;
#endif

//**********************************************************************************************************************************************************
    _InitError:
      eInitAccessSSW    := _PrepareInit;      
      AccessInitState   := ERROR; 

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=0);
      end_if;
#endif

//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::InitModule
	VAR_OUTPUT
		ModuleInitState 	: iprStates;
	END_VAR
  VAR
		MyPara 	          : CmdStruct;
		MyResult	        : results;  	
    TmpRetCode        : iprStates;
		SDORequestBuffer  : SDORequReadConfig;
    us_SDO_length     : USINT;
  	TempPathInfo      : PathInfoType;
    udBusTime         : UDINT;
    udBusTime_us      : UDINT;
  END_VAR

  ModuleInitState := BUSY;

  case eInitSSW of
//**********************************************************************************************************************************************************
    _PrepareInit:
      //add module to safety communication task with SDO (has to be done here too, for plug out/plug in case)
      if ( AddModuleToSafetyTask() ) then
        LogError(e_msg:="(SdiasSafetyManager::InitModule) Failed to add module to safety task");
        eInitSSWErrorStep := eInitSSW;
        eInitSSW := _InitError;
        return;
      end_if;

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=1);
        
        // clear the flag of the actual buffer if there is something
        if p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID then
          p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
        end_if;
      end_if;
#endif

      eResponseState := _idle;
      
      if b_GetOptionalSettings then
        eInitSSW := _GetOptionalSettings;
      else
        eInitSSW := _ReadModuleIDs;
      end_if;
      
//**********************************************************************************************************************************************************

    _GetOptionalSettings:
      case eResponseState of
        _idle:
          if (LastRequest = _NoOpenRequest) & (p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA) then
          
            // get state via SDO communication                                  
            SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_READ;                                 // read command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            SDORequestBuffer.StdHeader.Len  := 4 + 4 + 1;                                           // header + destination address + length of data
            SDORequestBuffer.ud_Address     := SB_SDO_ADDRESS_OPTIONAL_CFG;
            SDORequestBuffer.us_Length      := sizeof(t_OptionalSettings);

            LastRequest := _ReadData;

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;

            SDOTimeMark := ops.tAbsolute;
            eResponseState:= _wait; 
                  
            // check timeout
          elsif ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManagerFSoE::InitModule) Timeout while waiting for the SDO Send buffer to get ready (get optional settings)");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
          
      //*****************************************************
        _wait: // wait for response

          //read SDO from module and send it to the target module
          //check, if SDO is available and valid
          if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
        
            //calculate length of SDO
            us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
            
            //copy SDO without first byte (=status byte)
            ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

            //mark data as received
            p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
          
            //check, if it's our answer
            if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
              StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
              if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then
                if LastRequest = _ReadData then
                  if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_READ then
                    // delete request
                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter
                    
                    eResponseState:= _valid;
                    
                    // if returncode is 0 read succeeded
                    if StandardResponse.aData[0] = 0 then

                      // copy the data into our local memory
                      _memcpy(ptr1:=#OptionalSettings, 
                              ptr2:=#StandardResponse.aData[2], 
                              cntr:=sizeof(OptionalSettings));

                      b_GotOptionalSettings := TRUE;
                    else
                      // if we get an error => we might have an old firmware version, ignore it
                      b_GotOptionalSettings := FALSE;
                    end_if;
                  else
                    LogError(e_msg:="(SdiasSafetyManagerFSoE::InitModule) SDO Receive: Invalid command in standard frame response");
                    eInitSSWErrorStep := eInitSSW;
                    eInitSSW := _InitError;
                  end_if;
                else
                  LogError(e_msg:="(SdiasSafetyManagerFSoE::InitModule) SDO Receive: Invalid standard frame response");
                  eInitSSWErrorStep := eInitSSW;
                  eInitSSW := _InitError;
                end_if;

                // if request is deleted, increase sequence number to set next request
                if LastRequest = _NoOpenRequest then
                  if StandardSeqNr < 16#7F then
                    StandardSeqNr += 1;
                  else
                    StandardSeqNr := 0;
                  end_if;
                end_if;
              else
                LogError("(SdiasSafetyManagerFSoE::InitModule) SDO Receive: Invalid sequence number in Standard SDO response");
                LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
                eInitSSWErrorStep := eInitSSW;
                eInitSSW := _InitError;
              end_if;
            else
              // ignore non-standard frames => the module may try to distribute it's configuration
            end_if;
          end_if;
        
          // check timeout
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManagerFSoE::InitModule) SDO Response timeout while waiting for the optional configuration");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
      //*****************************************************
        _valid:
          eResponseState := _idle;
          eInitSSW := _ReadModuleIDs;
      //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ReadModuleIDs:
      case eResponseState of
        _idle:
          LastSDO.Command := _BUS_IF_READ_VIA_SDO;
          LastSDO.Offset  := SB_OFFSET_IO_MODULE_IDS;
          LastSDO.Length  := sizeof(t_ModuleIDs);
        
          MyPara.uiCmd    := LastSDO.Command$UINT;
          MyPara.aPara[0] := LastSDO.Offset;
          MyPara.aPara[1] := LastSDO.Length;
          TmpRetcode := ToBusInterface.NewInst(#MyPara, #MyResult);    
          if TmpRetcode = READY then
            SDOTimeMark  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            ModuleInitState := ERROR;
            LogError("(SafetyBase::InitModule) Failed to add read SDO for module configuration");
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) then
            LogError("(SdiasSafetyManager::InitModule) SDO Response timeout while waiting for the module configuration");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW := _GetSafetyNr;
          eResponseState  := _idle;
          SDOTimeMark := ops.tAbsolute;
        //*****************************************************
      end_case;

//**********************************************************************************************************************************************************
    _GetSafetyNr:
      case eResponseState of
        _idle:
          if (LastRequest = _NoOpenRequest) & (p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA) then
          
            // get state via SDO communication                                  
            SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_GET_SAFENBR;                          // get-safety-number command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            SDORequestBuffer.StdHeader.Len  := 4;                                                   // header
            SDORequestBuffer.ud_Address     := 0;
            SDORequestBuffer.us_Length      := 0;

            LastRequest := _GetSafetyNbr;

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;

            SDOTimeMark := ops.tAbsolute;
            eResponseState:= _wait; 
                  
            // check timeout
          elsif ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitModule) Timeout while waiting for the SDO Send buffer to get ready (get safety number)");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
          
      //*****************************************************
        _wait: // wait for response

          //read SDO from module and send it to the target module
          //check, if SDO is available and valid
          if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
        
            //calculate length of SDO
            us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
            
            //copy SDO without first byte (=status byte)
            ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

            //mark data as received
            p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
          
            //check, if it's our answer
            if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
              StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
              if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then
                if LastRequest = _GetSafetyNbr then
                  if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_GET_SAFENBR then
                    SafetyNumber := StandardResponse.aData[1]$HDINT;

                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    eResponseState:= _valid; 
                  else
                    LogError(e_msg:="(SdiasSafetyManager::InitModule) SDO Receive: Invalid command in standard frame response");
                    eInitSSWErrorStep := eInitSSW;
                    eInitSSW := _InitError;
                  end_if;
                else
                  LogError(e_msg:="(SdiasSafetyManager::InitModule) SDO Receive: Invalid standard frame response");
                  eInitSSWErrorStep := eInitSSW;
                  eInitSSW := _InitError;
                end_if;

                // if request is deleted, increase sequence number to set next request
                if LastRequest = _NoOpenRequest then
                  if StandardSeqNr < 16#7F then
                    StandardSeqNr += 1;
                  else
                    StandardSeqNr := 0;
                  end_if;
                end_if;
              else
                LogError("(SdiasSafetyManager::InitModule) SDO Receive: Invalid sequence number in Standard SDO response");
                LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
                eInitSSWErrorStep := eInitSSW;
                eInitSSW := _InitError;
              end_if;
            else
              // ignore non-standard frames => the module may try to distribute it's configuration
            end_if;
          end_if;
        
          // check timeout
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitModule) SDO Response timeout while waiting for the module configuration");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
      //*****************************************************
        _valid:
          eInitSSW := _GetFirmwareVersion;            
          eResponseState  := _idle;
      //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _GetFirmwareVersion:
      case eResponseState of
        _idle:
          if (LastRequest = _NoOpenRequest) & (p_Handle_SDO_Write^.us_Status = SAFETY_SDO_NO_DATA) then
          
            // get state via SDO communication                                  
            SDORequestBuffer.StdHeader.CRC  := 0;                                                   // CRC is always 0 in Std communication
            SDORequestBuffer.StdHeader.Cmd  := SB_SDO_COMMAND_GET_FW_VERSION;                       // get-fw-version command
            SDORequestBuffer.StdHeader.Typ  := SDO_STD;                                             // standard frame type
            SDORequestBuffer.StdHeader.SeqNr:= StandardSeqNr OR 16#80;                              // sequence number
            SDORequestBuffer.StdHeader.Len  := 4;                                                   // header
            SDORequestBuffer.ud_Address     := 0;
            SDORequestBuffer.us_Length      := 0;

            LastRequest := _GetFWVersion;

            //copy SDO into write-buffer
            ToStdLib.MemCpy(dest := #p_Handle_SDO_Write^.SDOStructure, source := #SDORequestBuffer, size := (sizeof(SDOHeader.StdHeader.CRC) + SDORequestBuffer.StdHeader.Len));
                  
            //mark SDO data as valid
            p_Handle_SDO_Write^.us_Status := SAFETY_SDO_DATA_VALID;
            
            if ( pISafety^.udVersion >= 16#1001 ) then
              SAFETY_iPushSafetyTask();
            end_if;

            SDOTimeMark := ops.tAbsolute;
            eResponseState:= _wait; 
                  
            // check timeout
          elsif ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitModule) Timeout while waiting for the SDO Send buffer to get ready (get firmware version)");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
          
      //*****************************************************
        _wait: // wait for response

          //read SDO from module and send it to the target module
          //check, if SDO is available and valid
          if ( p_Handle_SDO_Read^.us_Status = SAFETY_SDO_DATA_VALID ) then
        
            //calculate length of SDO
            us_SDO_length := sizeof(SDOHeader.StdHeader.CRC) + p_Handle_SDO_Read^.SDOStructure.SDOHeader.StdHeader.Len;
            
            //copy SDO without first byte (=status byte)
            ToStdLib.MemCpy(dest := p_SDOOutputBuffer, source := #p_Handle_SDO_Read^.SDOStructure, size := us_SDO_length );

            //mark data as received
            p_Handle_SDO_Read^.us_Status := SAFETY_SDO_NO_DATA;
          
            //check, if it's our answer
            if ((p_SDOOutputBuffer^.SDOHeader.StdHeader.Typ$USINT AND SB_SSDO_MASK_TYPE)$t_SafetyFrameType = SDO_STD) then
              StandardResponse := (p_SDOOutputBuffer$^StandardFrameType)^;
              if StandardResponse.SDOHeader.SeqNr = (StandardSeqNr OR 16#80) then
                if LastRequest = _GetFWVersion then
                  if StandardResponse.SDOHeader.Cmd = SB_SDO_COMMAND_GET_FW_VERSION then
                    _memcpy(ptr1 := #sFirmwareVersion, 
                            ptr2 := #StandardResponse.aData + SIZEOF(USINT), 
                            cntr := sizeof(FirmwareVersionType) );

                    LastRequest := _NoOpenRequest;
                    ud_AsyComRetryCounter := 0; // reset retry counter

                    eResponseState:= _valid; 
                  else
                    LogError(e_msg:="(SdiasSafetyManager::InitModule) SDO Receive: Invalid command in standard frame response");
                    eInitSSWErrorStep := eInitSSW;
                    eInitSSW := _InitError;
                  end_if;
                else
                  LogError(e_msg:="(SdiasSafetyManager::InitModule) SDO Receive: Invalid standard frame response");
                  eInitSSWErrorStep := eInitSSW;
                  eInitSSW := _InitError;
                end_if;

                // if request is deleted, increase sequence number to set next request
                if LastRequest = _NoOpenRequest then
                  if StandardSeqNr < 16#7F then
                    StandardSeqNr += 1;
                  else
                    StandardSeqNr := 0;
                  end_if;
                end_if;
              else
                LogError("(SdiasSafetyManager::InitModule) SDO Receive: Invalid sequence number in Standard SDO response");
                LogValue(pString:="expected: 0x{0} / received: 0x{1}", Value:=(StandardSeqNr OR 16#80), Value2:=StandardResponse.SDOHeader.SeqNr);
                eInitSSWErrorStep := eInitSSW;
                eInitSSW := _InitError;
              end_if;
            else
              // ignore non-standard frames => the module may try to distribute it's configuration
            end_if;
          end_if;
        
          // check timeout
          if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) & (eResponseState <> _valid) then
            LogError("(SdiasSafetyManager::InitModule) SDO Response timeout while waiting for the module configuration");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
      //*****************************************************
        _valid:
          FirmwareVersion := sFirmwareVersion.RevMinor OR (sFirmwareVersion.RevMajor SHL 16);

          // Minor Versions starting with 9xxx mark Bootloader versions
          if (sFirmwareVersion.RevMinor >= 9000) & (sFirmwareVersion.RevMinor < 10000) then
            LogError("(SdiasSafetyManager::InitModule) Bootloader version of safety firmware detected! Download a firmware or contact Sigmatek Support!");
          end_if;
          
           //Minor Versions higher than 338 mark versions which support the readout of the safety retry counters.
          if (sFirmwareVersion.RevMinor >= SB_RETRY_COUNTER_AVAILABLE_MINOR_REV) & (sFirmwareVersion.RevMajor = SB_RETRY_COUNTER_AVAILABLE_MAJOR_REV) then
            b_RetryCounterAvailable := TRUE;
          else
            b_RetryCounterAvailable := FALSE;
            SetRetryCounter();
          end_if;


          InitPathInfo(#TempPathInfo);
          
          // add own safety number to routing table
          AddRoutingElement( ud_SafeNumber       := SafetyNumber
                           , ud_thisp            := this$UDINT
                           , pObject             := #TempPathInfo
                           );

          // give the manager more details about the module
          if pSafetyManagerThis then
            MyPara.uiCmd := CMD_SM_ADD_MODULE_INFO;
            MyPara.aPara[0] := THIS$DINT;
            MyPara.aPara[1] := SafetyNumber$DINT;
            MyPara.aPara[2] := FirmwareVersion$DINT;
            MyPara.aPara[3] := 16#FF; // fake FPGA_Version (only needed for CDIAS CPUs)
            MyPara.aPara[4] := to_DINT(p_ObjectPath^$USINT) + 1; // size of path (length + 1 for the length information)
            MyPara.aPara[5] := p_ObjectPath$DINT;
            pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
          else
            LogError(e_msg:="(SafetyBase::GetSafetyNumber) Couldn't find object of HwControl class, which is needed for safety time synchronisation!");
          end_if;
          
          // if it has been reconnected, show the project name and revison from last time
          if pPrjNameStr & pPrjRevStr then
            ShowProjectRevision();
          end_if;

          eInitSSW := _DisablePLL;            
          eResponseState  := _idle;
      //*****************************************************
      end_case;

//**********************************************************************************************************************************************************
    _DisablePLL: // disable the PLL
      TmpRetCode := BusConfigWrite(Offset:=SDIAS_SAFETY_PLL_OFFSET + t_PllRegister.StatusControl, Length:=sizeof(sPllRegister.StatusControl), pData:=#sPllRegister.StatusControl, IsControlAccess:=TRUE);
    
      if TmpRetCode = READY then
        eInitSSW := _GetPLLSettings;
      elsif TmpRetCode = ERROR then
        eInitSSW := _InitError;
      end_if;

//**********************************************************************************************************************************************************
    _GetPLLSettings: // get the actual PLL settings
      TmpRetCode := BusConfigRead(Offset:=SDIAS_SAFETY_PLL_OFFSET, Length:=sizeof(sPllRegister), pData:=#sPllRegister, IsControlAccess:=TRUE);
    
      if TmpRetCode = READY then
        // get bus cycle time for the PLL settings
        MyPara.uiCmd     := _BUS_IF_GET_BUSCYCLE_TIME;

        ToBusInterface.NewInst(pPara:=#MyPara, pResult:=#MyResult);
        if MyResult.aData[0]$t_GetBusCycleTime.retcode = _BUS_IF_RETVAL_OK then
          udBusTime       := MyResult.aData[0]$t_GetBusCycleTime.udBusCycleTime;
        else
          // use this just to have 
          udBusTime := 1000;
          LogError("(NetX51Base::CreateMutex) Failed to get bus cycle settings BusInterface");
        end_if;

        udBusTime_us := udBusTime / 1000;

        // settings for pll
        sPllRegister.SystemPeriodTime           := udBusTime / 10;            // convert to 10*ns
        sPllRegister.StatusControl              := 0;
        sPllRegister.StatusControl.SyncEnable   := 1;
        sPllRegister.PeriodDivider              := to_usint(udBusTime_us / 1000);  // Bustime / 1ms to get divider (0 and 1 gets the same result)
        //sPllRegister.CompensationDelay // Keep value
        sPllRegister.SyncOut0.Offset            := 0;
        sPllRegister.SyncOut0.PeriodMultiplier  := to_usint(1000 / udBusTime_us);  // 1ms / Bustime to get multiplier (0 and 1 gets the same result);
        sPllRegister.SyncOut0.SyncStartDelay    := 0;
        sPllRegister.SyncOut0.ControlStatusRegister.SyncOutEnable     := 1;
        sPllRegister.SyncOut0.ControlStatusRegister.StartDelayEnable  := 0;
        if sPllRegister.PeriodDivider <= 1 then
          // no divider use system sync
          sPllRegister.SyncOut0.ControlStatusRegister.SyncSelector       := 1;  // no divider use system sync
        else
          // a divider is defined -> use it
          sPllRegister.SyncOut0.ControlStatusRegister.SyncSelector       := 0;
        end_if;

        eInitSSW := _ConfigurePLL;
      elsif TmpRetCode = ERROR then
        eInitSSW := _InitError;
      end_if;

//**********************************************************************************************************************************************************
    _ConfigurePLL:
      TmpRetCode := BusConfigWrite(Offset:=SDIAS_SAFETY_PLL_OFFSET, Length:=sizeof(sPllRegister), pData:=#sPllRegister, IsControlAccess:=TRUE);
    
      if TmpRetCode = READY then
        eInitSSW := _Finished;
      elsif TmpRetCode = ERROR then
        eInitSSW := _InitError;
      end_if;

//**********************************************************************************************************************************************************
    _Finished:
      if b_ModuleAccessReady then
        Online := 1;
      end_if;
      
      eInitSSW          := _PrepareInit;      
      ModuleInitState   := READY;

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=0);
      end_if;
#endif

//**********************************************************************************************************************************************************
    _InitError:
      eInitSSW          := _PrepareInit;      
      ModuleInitState   := ERROR; 

#ifdef SAFETY_iDisableNonClassCommunication
      if ( pISafety^.udVersion >= 16#1002 ) then
        SAFETY_iDisableNonClassCommunication(uiMaster:=0, pucNode:=p_ObjectPath, uiDisable:=0);
      end_if;
#endif
      
//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::ClassSvr::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	i                 : UDINT;
    pSafetyModuleInfo : ^t_SdiasSafetyModuleInfo;
		MyPara 	          : CmdStruct;
		MyResult          : Results;
    HBGPlace          : UDINT;
    bRequiredError    : BOOL;
    bHWConfigError    : BOOL;

    pStr_HWTRequested     : ^CHAR;
    tmpplace      : USINT;
    pStr_HWTreeEntry : ^CHAR;
    usNextPlace   : USINT;
  END_VAR
    
	ret_code := ERROR;

	CASE pPara^.uiCmd OF

//*****************************************************************************
//**  COMMANDS FROM BUS INTERFACE                                            **
//*****************************************************************************

//**********************************************************************************************************************************************************
    _BUS_IF_INIT_ACCESSES:
      // is called until the module is ready or in error state (only done once when no accesses have been created yet)
      ret_code := InitAccess();

//**********************************************************************************************************************************************************
    _BUS_IF_INIT_MODULE:
      // is called until the module is ready or in error state (done every time the module is connected)
      ret_code := InitModule();

//**********************************************************************************************************************************************************
    _BUS_IF_SDO_RESPONSE:
      // check if the command matches the one we're waiting for
      if (pPara^.aPara[0] = LastSDO.Command) &
         (pPara^.aPara[1] = LastSDO.Offset)  &
         (pPara^.aPara[2] = LastSDO.Length) then
      
        if pPara^.aPara[3]$iprStates = READY then
          if (LastSDO.Command = _BUS_IF_READ_VIA_SDO) then
            if (LastSDO.Offset = SB_OFFSET_IO_MODULE_IDS) then
              if eResponseState = _wait then
                if pPara^.aPara[5] = LastSDO.Length then  
                  if pPara^.aPara[4] then
                    // all parameters are fine, so we're ready
                    ret_code := READY;
                    
                    _memcpy(ptr1:=#aModuleIDs, ptr2:=pPara^.aPara[4]$pVoid, cntr:=LastSDO.Length);
                    
                    bRequiredError := FALSE;
                    bHWConfigError := FALSE;
                    
                    // search for a HBG in the module IDs
                    HBGPlace := SDIAS_SAFETY_INVALID_MAX_PLACE;
                    for i := 0 to 16 do
                      if (aModuleIDs[i] AND SDIAS_SAFETY_MODULE_ID_BUS_MASK) = SDIAS_SAFETY_MODULE_ID_CAN_BUS_MASK then
                        HBGPlace := i;
                        exit;
                      end_if;
                    end_for;

                    // now we got the module IDs according to the safety cpu => check if it matches our configuration (only available on newer firmware versions)
                    if b_GotOptionalSettings then
                      pSafetyModuleInfo := #aSafetyModuleInfo[0];
                      
                      // always the same command
                      MyPara.uiCmd := SDIAS_SET_CLASS_STATE;

                      for i := 0 to 15 do
                        MyPara.aPara[1] := aModuleIDs[i];

                        // if a required module is not matching => required error
                        if pSafetyModuleInfo^.sdRequired & (aModuleIDs[i] <> pSafetyModuleInfo^.usExpectedDeviceID) then
                          MyPara.aPara[0] := _RequiredError$DINT;
                          bRequiredError := TRUE;
                          if aModuleIDs[i] = SDIAS_SAFETY_INVALID_DEVICE_ID then
                            LogValue(pString:="No safety IO module at required place {0}", Value:=i);                              
                          else
                            LogValue(pString:="Wrong safety IO module at required place {0}", Value:=i);                              
                          end_if;

                        // check if the configuration in the safety designer matches the configuration in the hardware classes
                        elsif pSafetyModuleInfo^.usExpectedDeviceID = OptionalSettings.ModuleIDsConfigured[i] then
                          // if it's an invalid device ID, it's only allowed if there is no module
                          if pSafetyModuleInfo^.usExpectedDeviceID = SDIAS_SAFETY_INVALID_DEVICE_ID then
                            if aModuleIDs[i] = SDIAS_SAFETY_INVALID_DEVICE_ID then
                              // correct (no module configured and no module found)
                              MyPara.aPara[0] := _ClassOk$DINT;  // this value is not being written to the module since if the ID is 0, there is also no this pointer to call the newinst
                            elsif (i <> HBGPlace) then
                              // no module configured but a module has been found at this place
                              LogValue(pString:="No module configured in hardware classes and safety designer but found module at place {0}", Value:=i);
                              MyPara.aPara[0] := _WrongHardware$DINT; // again no object to write this value to
                              bHWConfigError := TRUE;
                            end_if;
                        
                          // now check if we got the expected ID at this position
                          elsif aModuleIDs[i] = pSafetyModuleInfo^.usExpectedDeviceID then
                            // correct module
                            MyPara.aPara[0] := _ClassOk$DINT;
                          
                            // if this module is optional
                          elsif OptionalSettings.OptionalFlagsIOModules AND (1 SHL i) then  
                            // if it's a blank module
                            if aModuleIDs[i] = SDIAS_SAFETY_MODULE_ID_BLANK_MODULE then
                              // ok: blank is allowed at optional place
                              MyPara.aPara[0] := _NoHardware$DINT;
                              
                              // don't send the black-module ID
                              MyPara.aPara[1] := SDIAS_SAFETY_INVALID_DEVICE_ID;
                            else
                              if aModuleIDs[i] = SDIAS_SAFETY_INVALID_DEVICE_ID then
                                // ok: no module instead of the configured one (allowed since it's the last module. no more modules possible after an invalid device id)
                                MyPara.aPara[0] := _NoHardware$DINT;
                              else
                                // wrong module detected
                                MyPara.aPara[0] := _WrongHardware$DINT;
                                bHWConfigError := TRUE;
                                LogValue(pString:="Wrong safety IO module at place {0}. (configured as optional)", Value:=i);
                              end_if;
                            end_if;
                          else
                            // the module id does not match (missing or wrong module)
                            if aModuleIDs[i] = SDIAS_SAFETY_INVALID_DEVICE_ID then
                              MyPara.aPara[0] := _NoHardware$DINT;
                            else
                              MyPara.aPara[0] := _WrongHardware$DINT;
                            end_if;
                            
                            // check if it's required
                            if MyPara.aPara[0] = _NoHardware$DINT then
                              LogValue(pString:="No safety IO module at place {0}.", Value:=i);
                            else
                              LogValue(pString:="Wrong safety IO module at place {0}.", Value:=i);                              
                            end_if;

                            bHWConfigError := TRUE;
                          end_if;
                        else
                          // the configuration in the safety designer differs from the configuration via the hardware classes
                          LogValue(pString:="Module in hardware class configuration differs from safety designer configuration at place {0}", Value:=i);                          
                          MyPara.aPara[0] := _InvalidConfguration$DINT;
                          bHWConfigError := TRUE;
                        end_if;

                        if pSafetyModuleInfo^.pThis then
                          pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
                        end_if;
                          
                        pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
                      end_for;

                      // check for hbg
                      if sHBG.pThis then
                        CanActive := OldCanActive := FALSE;
                        MyPara.uiCmd := SDIAS_SET_CLASS_STATE;

                        if HBGPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                          MyPara.aPara[1] := aModuleIDs[HBGPlace];

                          // if it's the wrong module and it's required => required error
                          if sHBG.sdRequired & (aModuleIDs[HBGPlace] <> sHBG.usExpectedDeviceID) then
                            MyPara.aPara[0] := _RequiredError$DINT;
                            bRequiredError := TRUE;
                            LogError(e_msg:="Wrong safety CAN terminal found instead of the configured required module!");
                            
                          elsif (OptionalSettings.ModuleIDHBG = sHBG.usExpectedDeviceID) then
                            // the configured ID of LASAL and safety designer are equal
                            
                            // if the module ID found is also the same => everthing is fine
                            if aModuleIDs[HBGPlace] = sHBG.usExpectedDeviceID then
                              MyPara.aPara[0] := _ClassOk$DINT;
                              CanActive := OldCanActive := TRUE;
                            else
                              // found something else
                              LogError(e_msg:="Wrong safety CAN terminal found (config of safety designer and hw classes match)");
                              MyPara.aPara[0] := _WrongHardware$DINT;
                              bHWConfigError := TRUE;
                            end_if;
                          else
                            // configuration of safety designer and hw classes does not match
                            LogError(e_msg:="Safety CAN terminal in hardware class configuration differs from safety designer configuration.");
                            MyPara.aPara[0] := _InvalidConfguration$DINT;
                            bHWConfigError := TRUE;
                          end_if;
                        else
                          MyPara.aPara[1] := SDIAS_SAFETY_INVALID_DEVICE_ID;

                          // projected in LASAL but not found in hardware
                          if sHBG.sdRequired then
                            MyPara.aPara[0] := _RequiredError$DINT;
                            bRequiredError := TRUE;
                            LogError(e_msg:="Required safety CAN terminal not available!");
                          else
                            // module is configured in safety designer
                            if (OptionalSettings.ModuleIDHBG <> SDIAS_SAFETY_INVALID_DEVICE_ID) then
                              // if the configuration does not match with the hardware classes
                              if (OptionalSettings.ModuleIDHBG <> sHBG.usExpectedDeviceID) then
                                LogError(e_msg:="Safety CAN terminal in hardware class configuration differs from safety designer configuration.");
                                MyPara.aPara[0] := _InvalidConfguration$DINT;
                                bHWConfigError := TRUE;
                              
                              // the IDs match but it's not optional. since it's not available => error
                              elsif (OptionalSettings.OptionalFlagHBG.1 = FALSE) then
                                MyPara.aPara[0] := _NoHardware$DINT;
                                LogError(e_msg:="Could not find the non-optional Safety CAN terminal defined in the safety designer configuration.");
                                bHWConfigError := TRUE;
                              
                              else
                                // if the IDs match and it's optional => just show no hardware (no error)
                                MyPara.aPara[0] := _NoHardware$DINT;
                              end_if;
                            else
                              LogError(e_msg:="Safety CAN terminal in hardware class configuration but not in safety designer configuration.");
                              MyPara.aPara[0] := _InvalidConfguration$DINT;
                              bHWConfigError := TRUE;
                            end_if;
                          end_if;
                        end_if;
                        sHBG.pThis^.NewInst(#MyPara, #MyResult);
                      else
                        // nothing projected for HBG in the lasal project
                        
                        // if module is configured in safety designer
                        if (OptionalSettings.ModuleIDHBG <> SDIAS_SAFETY_INVALID_DEVICE_ID) then
                          // if a HBG has been found
                          if HBGPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                            // if it's not the configured module
                            if (aModuleIDs[HBGPlace] <> OptionalSettings.ModuleIDHBG) then
                              LogError(e_msg:="Safety CAN terminal found doesn't match the safety designer configuration.");
                              bHWConfigError := TRUE;
                            end_if;
                          else
                            // module not available (only a problem if it's not optional)
                            if (OptionalSettings.OptionalFlagHBG.1 = FALSE) then
                              LogError(e_msg:="Could not find the non-optional Safety CAN terminal defined in the safety designer configuration.");
                              bHWConfigError := TRUE;
                            end_if;
                          end_if;
                        else
                          // module not configured in safety designer. if there is a module available, the number of IOs in safety does not match the config
                          if HBGPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                            LogError(e_msg:="Safety CAN terminal found but not projected in the safety designer configuration.");
                            bHWConfigError := TRUE;
                          end_if;
                        end_if;
                      end_if;
                    else
                      // old firmware (no optional settings available)
                      if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                        pSafetyModuleInfo := #aSafetyModuleInfo[0];
                        
                        // always the same command
                        MyPara.uiCmd := SDIAS_SET_CLASS_STATE;

                        for i := 0 to MaxPlace do
                          if pSafetyModuleInfo^.pThis then
                            MyPara.aPara[1] := aModuleIDs[i];
                            if aModuleIDs[i] = pSafetyModuleInfo^.usExpectedDeviceID then
                              MyPara.aPara[0] := _ClassOk$DINT;
                            elsif aModuleIDs[i] <> SDIAS_SAFETY_INVALID_DEVICE_ID then
                              if pSafetyModuleInfo^.sdRequired then
                                MyPara.aPara[0] := _RequiredError$DINT;
                                bRequiredError := TRUE;   
                                LogValue(pString:="Wrong safety IO module at required place {0}.", Value:=i);
                              else
                                MyPara.aPara[0] := _WrongHardware$DINT;   
                                bHWConfigError  := TRUE;
                              end_if;
                            else
                              if pSafetyModuleInfo^.sdRequired then
                                MyPara.aPara[0] := _RequiredError$DINT;
                                bRequiredError := TRUE;
                                LogValue(pString:="No safety IO module at required place {0}.", Value:=i);
                              else
                                MyPara.aPara[0] := _NoHardware$DINT;  
                                // Hardwareclass placed in Project but no physical Hardware available is allowed
                                // bHWConfigError  := TRUE;
                              end_if;
                            end_if;
                            pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
                          
                          elsif aModuleIDs[i] <> SDIAS_SAFETY_INVALID_DEVICE_ID then  // HWK this pointer is NIL but a module is identified 
                            bHWConfigError  := TRUE;
                          end_if;

                          pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
                        end_for;
                      end_if;
                      
                      // Check if a module info was passed for which there is no corrosponding HWK object.
                      if MaxPlace + 1 < sizeof(t_ModuleIDs) then
                        // it's only a config error if it's not the HBG
                        if (aModuleIDs[MaxPlace + 1] <> SDIAS_SAFETY_INVALID_DEVICE_ID) & ((MaxPlace + 1) <> HBGPlace) then
                          bHWConfigError  := TRUE;
                        end_if;
                      end_if;
                      
                      // check for hbg
                      if sHBG.pThis then
                        MyPara.uiCmd := SDIAS_SET_CLASS_STATE;
                        if HBGPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                          MyPara.aPara[1] := aModuleIDs[HBGPlace];

                          if aModuleIDs[HBGPlace] = sHBG.usExpectedDeviceID then
                            MyPara.aPara[0] := _ClassOk$DINT;
                            CanActive := OldCanActive := TRUE;
                            bHWConfigError := FALSE;
                          elsif aModuleIDs[HBGPlace] <> SDIAS_SAFETY_INVALID_DEVICE_ID then
                            if sHBG.sdRequired then
                              MyPara.aPara[0] := _RequiredError$DINT;
                              bRequiredError := TRUE;
                              LogError(e_msg:="Wrong safety IO module at required HBG place.");
                            else
                              MyPara.aPara[0] := _WrongHardware$DINT;
                              CanActive := OldCanActive := FALSE;
                            end_if;
                          else
                            if sHBG.sdRequired then
                              MyPara.aPara[0] := _RequiredError$DINT;
                              bRequiredError := TRUE;
                              LogError(e_msg:="HBG required but not available!");
                            else
                              MyPara.aPara[0] := _NoHardware$DINT;
                              CanActive := OldCanActive := FALSE;
                            end_if;
                          end_if;
                        else
                          MyPara.aPara[1] := SDIAS_SAFETY_INVALID_DEVICE_ID;
                          if sHBG.sdRequired then
                            MyPara.aPara[0] := _RequiredError$DINT;
                            bRequiredError := TRUE;
                            LogError(e_msg:="Wrong safety IO module at required HBG place.");
                          else
                            MyPara.aPara[0] := _WrongHardware$DINT;
                            CanActive := OldCanActive := FALSE;
                          end_if;
                        end_if;
                        sHBG.pThis^.NewInst(#MyPara, #MyResult);
                      end_if;                    
                    end_if;
                    
                    if bRequiredError then
                      MyPara.uiCmd := _BUS_IF_SET_REQUIRED_ERROR;
                      ToBusInterface.NewInst(#MyPara, #MyResult);
                    end_if;                    

                    if bHWConfigError then
                      // if we have optional settings, we already logged the reason
                      if b_GotOptionalSettings = FALSE then
                        LogError("Hardwareconfiguration does not match objects placed in network.");                    
                      end_if;
                    
                      // Check if Safetymanyger is required                      
                      MyPara.uiCmd     := _BUS_IF_GET_REQUIRED_SETTING;
                      ToBusInterface.NewInst(pPara:=#MyPara, pResult:=#MyResult);
                      if MyResult.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
                        // if it's required => set required error
                        if MyResult.aData[4] then
                          
                          MyPara.uiCmd := _BUS_IF_SET_REQUIRED_ERROR;
                          ToBusInterface.NewInst(#MyPara, #MyResult);
                        else
                        
                          SetSafetyState(_WrongSafetyHW);
                          Online      := 0;
                          
                          // Update BusIF ClassState
                          MyPara.uiCmd := _BUS_IF_SET_CLASS_STATE;
                          MyPara.aPara[0] := _WrongHardware$DINT;
                          ToBusInterface.NewInst(#MyPara, #MyResult);
                          
                          // Cancel init
                          eInitSSWErrorStep := eInitSSW;
                          eInitSSW := _InitError;
                          
                          // Set Module states                          
                          pSafetyModuleInfo := #aSafetyModuleInfo[0];
                          // always the same command
                          MyPara.uiCmd := SDIAS_SET_CLASS_STATE;
                          MyPara.aPara[0] := _ModuleFoundButManagerIsOff$DINT;

                          if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
                            for i := 0 to MaxPlace do
                              if pSafetyModuleInfo^.pThis then
                                MyPara.aPara[1] := aModuleIDs[i];
                                pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);                              
                              end_if;
                              pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
                            end_for;
                          end_if;
                          
                          // check for hbg
                          if sHBG.pThis then
                            sHBG.pThis^.NewInst(#MyPara, #MyResult);
                          end_if;
                          
                        end_if;
                        
                      end_if;                      
                      
                    end_if;

                  else
                    LogError("(SdiasSafetyManager::ClassSvr::NewInst) Invalid SDO response buffer pointer");
                  end_if;
                else
                  LogError("(SdiasSafetyManager::ClassSvr::NewInst) Invalid length for SDO response data");
                end_if;
              
                eResponseState := _valid;
              else
                LogError("(SdiasSafetyManager::ClassSvr::NewInst) SDO response arrived when no response was expected");
              end_if;           
            end_if;
          elsif (LastSDO.Command = _BUS_IF_READ_VIA_SDO_CTRL) then
            if LastSDO.ResponseArrived = FALSE then
              if pPara^.aPara[5] = LastSDO.Length then  
                if pPara^.aPara[4] then
                  // all parameters are fine, so we're ready
                  ret_code := READY;
                  
                  // copy the response data
                  _memcpy(ptr1:=Config.pActData, ptr2:=pPara^.aPara[4]$pVoid, cntr:=LastSDO.Length);
                else
                  LogError("(SdiasSafetyManager::ClassState::NewInst) Invalid SDO response buffer pointer");
                end_if;
              else
                LogError("(SdiasSafetyManager::ClassState::NewInst) Invalid length for SDO response data");
              end_if;
            
              LastSDO.ResponseArrived := TRUE;
            else
              LogError("(SdiasSafetyManager::ClassState::NewInst) SDO response arrived when no response was expected");
            end_if;
          elsif (LastSDO.Command = _BUS_IF_WRITE_VIA_SDO_CTRL) then
            if LastSDO.ResponseArrived = FALSE then
              // all parameters are fine, so we're ready
              ret_code := READY;
            
              LastSDO.ResponseArrived := TRUE;
            else
              LogError("(SdiasSafetyManager::ClassState::NewInst) SDO response arrived when no response was expected");
            end_if;
          end_if;
        else
          LogError("(SdiasSafetyManager::ClassSvr::NewInst) SDO transfer failed");        
        end_if;
      else
        LogError("(SdiasSafetyManager::ClassSvr::NewInst) Received invalid SDO response");
      end_if;

//**********************************************************************************************************************************************************     
    _BUS_IF_DATA_POINTER_AVAILABLE:
      // only if connected via VARAN
      if b_VaranAvailable & (b_SafetyOnLocalCDIAS = FALSE) & (b_MoveDOsCreated = FALSE) then
        ret_code := AddMovDOs();
      else
        ret_code := READY;
      end_if;

//**********************************************************************************************************************************************************
    _BUS_IF_RESET_DETECTED:
      // don't overwrite other errors
      if SafetyState = _SafetyClassOK then      
        SafetyState := _LostPowerSupply;
      end_if;

      // check if module is requred
      MyPara.uiCmd     := _BUS_IF_GET_REQUIRED_SETTING;
      ToBusInterface.NewInst(pPara:=#MyPara, pResult:=#MyResult);
      if MyResult.aData[0]$t_BusIFRetvalErrorcode = _BUS_IF_RETVAL_OK then
        // if it's required => set required error
        if MyResult.aData[4] then
          
          MyPara.uiCmd := _BUS_IF_SET_REQUIRED_ERROR;
          ToBusInterface.NewInst(#MyPara, #MyResult);
        end_if;
      end_if;
    
      // drop config of connected modules
      
      // initialize the message for the periphery
      MyPara.uiCmd := SDIAS_SET_CLASS_STATE;
      MyPara.aPara[1] := 0;// no device ID
      MyPara.aPara[0] := _NoHardware$DINT;

      // tell the connected IO module objects
      if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
        pSafetyModuleInfo := #aSafetyModuleInfo[0];

        for i := 0 to MaxPlace do
          if pSafetyModuleInfo^.pThis then
            pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
          end_if;

          pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
        end_for;
      end_if;
      
      // tell the hbg (if available)
      if sHBG.pThis then
        sHBG.pThis^.NewInst(#MyPara, #MyResult);
      end_if; 
      
//**********************************************************************************************************************************************************
    _BUS_IF_RESET_GONE_DETECTED:
      if SafetyState = _LostPowerSupply then
      
        // get safety and serial numbers of connected modules
        bUpdateModuleConfig := TRUE;

        // refetch IDs of connected modules
        eCheckIDSSW := _Wait4Idle;

        SafetyState := _SafetyClassOK;
      end_if;

//**********************************************************************************************************************************************************
    
    CMD_GET_HARDWARE_DIAGNOSIS:
      //Returns module info
      ret_code := ERROR;
      pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR;

      pStr_HWTRequested := pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.pStr_HardewareTreeEntry;
      
      tmpplace := (pStr_HWTRequested+pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.us_current_index)^$USINT;  
      
      //Check if pointer is valid
      if aSafetyModuleInfo[tmpplace].pThis then
        
        // Set Offline Device ID        
        pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_DeviceID := (aSafetyModuleInfo[tmpplace].usExpectedDeviceID AND 2#00111000 ) shr 3;   // Bit 3-5 Modul typ
        pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_Variante :=  aSafetyModuleInfo[tmpplace].usExpectedDeviceID AND 2#00000111;  // Bit 0-2 Submodul typ
        
        if aModuleIDs[tmpplace] = aSafetyModuleInfo[tmpplace].usExpectedDeviceID then
          
          ret_code := READY;
          pResult^.aData$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_OK;
          
          pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_DeviceID  := (aModuleIDs[tmpplace] AND 2#00111000 ) shr 3;  // Bit 3-5 Modul typ
          pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_Variante  :=  aModuleIDs[tmpplace] AND 2#00000111; // // Bit 0-2 Submodul typ
          pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_Place     := tmpplace;
          
          // Get Serialno ---------------------------------------------------------------------------------------------          
          _memcpy(ptr1 := #a_SerialNo[0]
                , ptr2 := #sSafetySerNrs.aSerialNumbers[tmpplace]
                , cntr := sizeof(sSafetySerNrs.aSerialNumbers[tmpplace]) );
          
          a_SerialNo[sizeof(sSafetySerNrs.aSerialNumbers[tmpplace])] := 0;  // 0 Terminierung
          
          pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_SerialNo := #a_SerialNo[0];
          
          
          pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.hd_SafetyNumber  := sSafetySerNrs.aSafetyNumbers[tmpplace];        
          
        elsif aModuleIDs[tmpplace] <> SDIAS_SAFETY_INVALID_DEVICE_ID then          
          pResult^.aData$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR_WRONG_HARDWARE;
        else          
          pResult^.aData$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR_NO_HARDWARE;
        end_if;
      
      else
        pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR_SDIAS_MODULE_NOT_FOUND;
      end_if;

      
//**********************************************************************************************************************************************************    
    CMD_GET_HARDWARE_TREE_ENTRY:
      //Returns module info
      
      ret_code := ERROR;
      pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_ERROR;
      
      pStr_HWTreeEntry := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry;
      
      //First HWT Path
      if (pStr_HWTreeEntry + pStr_HWTreeEntry$^UINT^)^ <> HWT_ESCAPE_INTERNALBUS_SDIAS_SAFETY then  // + 1 for Byte length -1 for 2nd last element of string
        
        if aSafetyModuleInfo[0].pThis then
        
          _memcpy(ptr1 := #a_HWTEntryStr[0]
                , ptr2 := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry
                , cntr := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry$^UINT^ +2 );  // +2 2 Byte Strlength is not included in the stringlength 
          
          // Add escape sequence 
          a_HWTEntryStr[0]$UINT += 1;
          a_HWTEntryStr[a_HWTEntryStr[0]$UINT+1] := HWT_ESCAPE_INTERNALBUS_SDIAS_SAFETY;
          
          // Add Place
          a_HWTEntryStr[0]$UINT += 1;
          a_HWTEntryStr[a_HWTEntryStr[0]$UINT+1] := 0;   
          
          //Return Hardware Tree Entry and set return codes
          pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.pStr_NextHardewareTreeEntry := #a_HWTEntryStr[0];
          
          pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_OK_HWTSTR_RETURNED;
          ret_code := READY;          
          
        else
          pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_ERROR_SDIAS_MODULE_NOT_FOUND;
        end_if;

      //search next module
      else
      
        usNextPlace := (pStr_HWTreeEntry  + pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.us_current_index)^$USINT+1;
            
        if usNextPlace <= SDIAS_SAFETY_MAX_PLACE_NR &
           aSafetyModuleInfo[usNextPlace].pThis then
        
          _memcpy(ptr1 := #a_HWTEntryStr[0]
                , ptr2 := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry
                , cntr := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry$^UINT^ +2 );  // +2 2 Byte Strlength is not included in the stringlength 
          
          // Set new Place
          a_HWTEntryStr[a_HWTEntryStr[0]$UINT + 1] := usNextPlace; 
          
          pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.pStr_NextHardewareTreeEntry := #a_HWTEntryStr[0];
          
          //Return Hardware Tree Entry and set return codes
          pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_OK_HWTSTR_RETURNED;
          ret_code := READY; 
          
        else
          ret_code := READY;
          pResult^.aData$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_OK_END_OF_LIST;
        end_if;
      end_if;

//**********************************************************************************************************************************************************     

//*****************************************************************************
//** INTERNAL COMMANDS                                                       **
//*****************************************************************************

//**********************************************************************************************************************************************************     
    CMD_SM_READ_PDO_SIZE:
      // get the size of the PDO and the IF PDO
      LastSDO.Command := _BUS_IF_READ_VIA_SDO;
      LastSDO.Offset  := SB_OFFSET_SPDO_LENGTH;
      LastSDO.Length  := 2*sizeof(USINT);
    
      MyPara.uiCmd    := LastSDO.Command$UINT;
      MyPara.aPara[0] := LastSDO.Offset;
      MyPara.aPara[1] := LastSDO.Length;
      ret_code := ToBusInterface.NewInst(#MyPara, #MyResult);    

//**********************************************************************************************************************************************************
  else
    ret_code := SafetyBase::NewInst(pPara, pResult);
//**********************************************************************************************************************************************************
	END_CASE;

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::ShowProjectRevision

  ProjectNameStr.WriteDataOff(udLen:=PrjNameStrLen + 1, udOff:=0, pData:=pPrjNameStr);

  ProjectRevisionStr.WriteDataOff(udLen:=PrjRevStrLen + 1, udOff:=0, pData:=pPrjRevStr);

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::InitSafeModule
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  // allocate memory for finding unsafe-IO-Servers
  // in first place we allocate 512 byte for our blocked transfers
  p_BlockedTransferMemory := ToStdLib.Malloc( size := SB_CONFIG_MEMORY_BLOCK_SIZE );
  IF p_BlockedTransferMemory <> NIL THEN
    ud_BlockedTransferMemorySize := SB_CONFIG_MEMORY_BLOCK_SIZE;
  ELSE
    SafetyState := _MemAllocFailed;
    sd_retval := -100;
    return;
  END_IF;

  // if there is a safety manager to gather the configuration
  if pSafetyManagerThis then
    // allocate memory for gathering configuration information => in first place we allocate 512 byte
    pConfigMem := ToStdLib.Malloc( size := SB_CONFIG_MEMORY_BLOCK_SIZE );
    IF pConfigMem <> NIL THEN
      ConfigMemSize := SB_CONFIG_MEMORY_BLOCK_SIZE;
      ConfigMemSizeUsed := 4;
    ELSE
      SafetyState := _MemAllocFailed;
      sd_retval := -100;
      return;
    END_IF;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::CanOut::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	tempCmd         : CmdStruct;
    _result         : results;
  END_VAR

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		SDIAS_SAFETY_LOGIN_HBG:
      // check parameters
      if pPara^.aPara[0] & pPara^.aPara[1] then
        
        sHBG.pThis               := pPara^.aPara[0]$pVirtualBase;
        sHBG.usExpectedDeviceID  := pPara^.aPara[1]$USINT;
        sHBG.sdRequired          := pPara^.aPara[2];
        sHBG.pIOStates           := pPara^.aPara[3]$^HDINT;

        // if leds/hgb not added so far, add them
        if StateBytesUsed = 0 then
          StateBitsUsed := (sizeof(t_LedAndIOStates.biLEDs) + sizeof(t_LedAndIOStates.HBGInputs)) * 8;
          // refresh state bytes used value
          StateBytesUsed := ((StateBitsUsed-1) / 8) + 1;
        end_if;

        if sHBG.sdRequired & (b_AnyModuleRequired = FALSE) then
          b_AnyModuleRequired := TRUE;
          // if any access is required => the businterface is also required
          tempCmd.uiCmd := _BUS_IF_SET_REQUIRED;
          ToBusInterface.NewInst(pPara:=#tempCmd, pResult:=#_result);
          if _result.aData[0]$t_BusIFRetvalErrorcode <> _BUS_IF_RETVAL_OK then  
            LogError("(SdiasSafetyManager::CanOut::NewInst) Failed to set the BusInterface to required");
          end_if;
        end_if;
      else
        ret_code := ERROR;
      end_if;
//**********************************************************************************************************************************************************
	END_CASE;

	ret_code := READY;

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::GetConfiguration
  VAR
  	pHelp                 : ^void;
    SizeToGo              : UINT;
    ActSize               : UINT;
    ActAddr               : HDINT;
    SDOReqBuf             : SDORequReadConfig;
    SDORspBuf             : ARRAY [0..SB_SDO_MAX_LENGTH-1] OF USINT;
    pRspBuf               : ^SDORespReadConfig;
    i                     : DINT;
    pSafetyModuleInfo     : ^t_SdiasSafetyModuleInfo;
		MyPara 	              : CmdStruct;
		MyResult              : Results;
  END_VAR

  //initialize header-data for request
  
  //calculate length without crc
  SDOReqBuf.StdHeader.Len := sizeof(SDORequReadConfig) - sizeof(SDOHeader.StdHeader.CRC);
  
  //type
  SDOReqBuf.StdHeader.Typ := SDO_STD;
  
  //command for reading config data
  SDOReqBuf.StdHeader.Cmd := SB_SDO_COMMAND_READ;


  // read the complete 256 Bytes of safety and serial number info
  pHelp    := #sSafetySerNrs;
  SizeToGo := sizeof(sSafetySerNrs);
  pRspBuf  := (#SDORspBuf)$^SDORespReadConfig;
  ActAddr  := SB_SDO_ADDRESS_SER_NR_DATA;

  while SizeToGo do
    if SizeToGo > SDIAS_SAFTEY_SDO_MAX_DATA_PER_PAKET then
      ActSize := SDIAS_SAFTEY_SDO_MAX_DATA_PER_PAKET;
    else
      ActSize := SizeToGo;
    end_if;

    if SDOReadCfgRequ(p_SDORequestBuffer  := #SDOReqBuf, 
                      p_SDOResponseBuffer := pRspBuf, 
                      ud_Address          := ActAddr, 
                      us_Length           := ActSize$USINT,
                      b_UseCache          := FALSE) then
      LogError("(SdiasSafetyManager::GetConfiguration) Failed to get safety and serial numbers of the IO modules");
      return;
    else
      _memcpy(ptr1:=pHelp, ptr2:=#pRspBuf^.ud_Data, cntr:=ActSize);
    end_if;
  
    SizeToGo  -= ActSize;
    ActAddr   += ActSize;
    pHelp     += ActSize;
  end_while;

  // only available for IOs, not the HBG
  if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
    // always the same command
    MyPara.uiCmd := SDIAS_SET_NUMBERS;
  
    pSafetyModuleInfo := #aSafetyModuleInfo[0];
    for i := 0 to MaxPlace$DINT do
      // safety number
      MyPara.aPara[0] := (sSafetySerNrs.aSafetyNumbers[i])$DINT;
      
      // pointer to serial number string
      MyPara.aPara[1] := (#sSafetySerNrs.aSerialNumbers[i][0])$DINT;

      pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
      
      pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::DisconnectEvent
  VAR
  	i                 : UDINT;
    pSafetyModuleInfo : ^t_SdiasSafetyModuleInfo;
		MyPara 	          : CmdStruct;
		MyResult          : Results;
  END_VAR

  SafetyBase::DisconnectEvent();

  // initialize the message for the periphery
  MyPara.uiCmd := SDIAS_SET_CLASS_STATE;
  MyPara.aPara[1] := 0;// no device ID
  MyPara.aPara[0] := _NoHardware$DINT;

  // tell the connected IO module objects
  if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
    pSafetyModuleInfo := #aSafetyModuleInfo[0];

    for i := 0 to MaxPlace do
      if pSafetyModuleInfo^.pThis then
        pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
      end_if;

      pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
    end_for;
  end_if;
  
  // tell the hbg (if available)
  if sHBG.pThis then
    sHBG.pThis^.NewInst(#MyPara, #MyResult);
  end_if; 
  
  // clear the strings
  ProjectNameStr.Clear();
  ProjectRevisionStr.Clear();

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::SetSafetyState
	VAR_INPUT
		NewState 	: SafetyConfigStateType;
	END_VAR
  VAR
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR

  // use it locally
  SafetyState := NewState;
  
  // tell the outer class
  MyPara.uiCmd := SDIAS_SET_SAFETY_STATE;
  MyPara.aPara[0] := NewState$DINT;
  ToBusInterface.NewInst(#MyPara, #MyResult);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
		MyPara 	          : CmdStruct;
		MyResult          : Results;
    TmpRetCode        : iprStates;
  END_VAR

  // if the initialisiation has been finished and there is an object for the hbg check if it's has been connected or disconnected
  if Online then

    case eCheckIDSSW of
  //**********************************************************************************************************************************************************
      _Nothing:
        if sHBG.pThis then
          // check for a can connect event
          if CanActive > OldCanActive then
            // if we're already idle => get it on
            if eResponseState = _idle then
              eCheckIDSSW := _GetIDs;        
            else
              // otherwise, wait for it (need to remember the connect event)
              eCheckIDSSW := _Wait4Idle;
            end_if;
            
          // check for a can disconnect event
          elsif CanActive < OldCanActive then
            if sHBG.sdRequired then
              // if it's required => required error
              MyPara.uiCmd := _BUS_IF_SET_REQUIRED_ERROR;
              ToBusInterface.NewInst(#MyPara, #MyResult);
            else
              // otherwise show that it has been disconnected
              MyPara.uiCmd := SDIAS_SET_CLASS_STATE;
              MyPara.aPara[1] := 0;// no device ID
              MyPara.aPara[0] := _NoHardware$DINT;
              sHBG.pThis^.NewInst(#MyPara, #MyResult);
            end_if;
          end_if;
          OldCanActive := CanActive;        
        end_if;
        
  //**********************************************************************************************************************************************************
      _Wait4Idle:
        if eResponseState = _idle then
          eCheckIDSSW := _GetIDs;        
        end_if;

  //**********************************************************************************************************************************************************
      _GetIDs:
        case eResponseState of
        //*****************************************************
          _idle:
            LastSDO.Command := _BUS_IF_READ_VIA_SDO;
            LastSDO.Offset  := SB_OFFSET_IO_MODULE_IDS;
            LastSDO.Length  := sizeof(t_ModuleIDs);
          
            MyPara.uiCmd    := LastSDO.Command$UINT;
            MyPara.aPara[0] := LastSDO.Offset;
            MyPara.aPara[1] := LastSDO.Length;
            TmpRetcode := ToBusInterface.NewInst(#MyPara, #MyResult);    
            if TmpRetcode = READY then
              SDOTimeMark  := ops.tAbsolute;
              eResponseState:= _wait; 
            elsif TmpRetcode = ERROR then
              LogError("(SafetyBase::InitModule) Failed to add read SDO for module configuration");
            end_if;
        //*****************************************************
          _wait:
            // wait for response
            if ((ops.tAbsolute - SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) then
              LogError("(SdiasSafetyManager::InitModule) SDO Response timeout while waiting for the module configuration");
              eCheckIDSSW := _Nothing;
              eResponseState := _idle;
            end_if;
        //*****************************************************
          _valid:
            eCheckIDSSW := _Nothing;
            eResponseState := _idle;
        //*****************************************************
        end_case;
  //**********************************************************************************************************************************************************
    end_case;
  end_if;

	state := SafetyBase::CyWork(0);

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::RefreshAsySrv
  VAR
  	i                 : UDINT;
    pSafetyModuleInfo : ^t_SdiasSafetyModuleInfo;
		MyPara 	          : CmdStruct;
		MyResult          : Results;
    AsyValues         : t_AsyRefresh;
  END_VAR

  // tell the outer class
  MyPara.uiCmd := SDIAS_SET_ASY_STATE;
  AsyValues.QuitComError := QuitComError;
  MyPara.aPara[0] := (#AsyValues)$DINT;
  ToBusInterface.NewInst(#MyPara, #MyResult);  

  // tell the connected IO module objects
  if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
    pSafetyModuleInfo := #aSafetyModuleInfo[0];

    for i := 0 to MaxPlace do
      if pSafetyModuleInfo^.pThis then
        pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
      end_if;

      pSafetyModuleInfo += sizeof(t_SdiasSafetyModuleInfo);
    end_for;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::FastUnsafeOutputs::Write
	VAR_INPUT
		input (EAX) 	: BDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: BDINT;
	END_VAR
  VAR
  	pUnsafeOutLogin : ^t_FastUnsafeOuts;
  END_VAR

  // if the pointer is valid and we're in the first init run (the firstscan check prevents a crash caused by someone writing on the server during runtime)
	if input & (us_FirstScan < 2) then
    pUnsafeOutLogin := input$^t_FastUnsafeOuts;
    // check if it's the correct usage of the class
    if pUnsafeOutLogin^.Kennung = SDIAS_SAFETY_FAST_UNSAFE_KENNUNG then
      pFastUnsafeOutThis := pUnsafeOutLogin^.pThis;
    end_if;
  end_if;
  
	result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::FastUnsafeInputs::Write
	VAR_INPUT
		input (EAX) 	: BDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: BDINT;
	END_VAR

	FastUnsafeInputs := input;
	result := FastUnsafeInputs;

END_FUNCTION

FUNCTION VIRTUAL SdiasSafetyManager::SetRetryCounter
	VAR
    pSafetyModuleInfo : ^t_SdiasSafetyModuleInfo;
		MyPara 	 : CmdStruct;
		MyResult : Results;
    i        :  USINT;
	END_VAR
    
  if b_RetryCounterAvailable then

    if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
      //Command for new inst call in sdiassafetybase
      MyPara.uiCmd := SDIAS_SET_RETRY_COUNTER;

      //calls newinst method of all safety modules which exists.
      for i := 0 to MaxPlace do
        pSafetyModuleInfo := #aSafetyModuleInfo[i];
        MyPara.aPara[0] := a_RetryCnt[i];
        MyPara.aPara[1] := a_RetryCnt[i+16];  //+16 for retry counter of C2
        pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
      end_for;
    end_if;
  else
    //Retrycounter not available -> show -1 at servers.
    SafetyRetryCounter := -1; //Not available

    if MaxPlace <> SDIAS_SAFETY_INVALID_MAX_PLACE then
      MyPara.uiCmd := SDIAS_RETRY_COUNTER_NOT_AVAILABLE;
      for i := 0 to MaxPlace do
        pSafetyModuleInfo := #aSafetyModuleInfo[i];
        pSafetyModuleInfo^.pThis^.NewInst(#MyPara, #MyResult);
      end_for;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasSafetyManager::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  if bUpdateModuleConfig & (eCheckIDSSW = _Nothing) then
    GetConfiguration();    
  end_if;

	state := SafetyBase::Background(0);

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::BusConfigWrite
	VAR_INPUT
		Offset 	: HDINT;
		Length 	: UINT;
		pData 	: pVoid;
		IsControlAccess 	: BOOL;(* := FALSE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode  : iprStates;
    MyPara      : CmdStruct;
    MyResult    : results;
  END_VAR

  retcode := BUSY;

  case Config.BusConfigSSW of
//**********************************************************************************************************************************************************
    _PrepareAccess:
      Config.RestLength := Length;
      Config.pActData   := pData;
      
      Config.BusConfigSSW := _StartAccess;
      
//**********************************************************************************************************************************************************
    _StartAccess:
      if IsControlAccess then
        LastSDO.Command := _BUS_IF_WRITE_VIA_SDO_CTRL;
      else
        LastSDO.Command := _BUS_IF_WRITE_VIA_SDO;      
      end_if;

      LastSDO.Offset  := Offset$DINT;
      if Config.RestLength > SDIAS_SAFETY_MAX_SDO_DATA_PER_CYCLE then
        LastSDO.Length  := SDIAS_SAFETY_MAX_SDO_DATA_PER_CYCLE;
      else
        LastSDO.Length  := Config.RestLength;
      end_if;
      LastSDO.ResponseArrived := FALSE;

      MyPara.uiCmd    := LastSDO.Command;
      MyPara.aPara[0] := LastSDO.Offset;
      MyPara.aPara[1] := LastSDO.Length;
      MyPara.aPara[2] := Config.pActData$DINT;
      TmpRetcode := ToBusInterface.NewInst(#MyPara, #MyResult);    
      if TmpRetcode = READY then
        Config.SDOTimeMark  := ops.tAbsolute;
        Config.BusConfigSSW := _Wait4Answer;
      elsif TmpRetcode = ERROR then
        retcode := ERROR;
        LogError("(SdiasSafetyManager::BusConfigWrite) Failed to add write SDO for module configuration");
      end_if;

//**********************************************************************************************************************************************************
    _Wait4Answer:
      // wait for response
      
      // check for response
      if LastSDO.ResponseArrived then
        Config.RestLength -= LastSDO.Length;
        Config.pActData   += LastSDO.Length;

        if Config.RestLength = 0 then
          retcode := READY;
          Config.BusConfigSSW := _PrepareAccess;
        end_if;
      elsif ((ops.tAbsolute - Config.SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) then
        LogError("(SdiasSafetyManager::BusConfigWrite) SDO Response timeout while waiting for the write response");
        retcode := ERROR;
      end_if;
      
//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL SdiasSafetyManager::BusConfigRead
	VAR_INPUT
		Offset 	: HDINT;
		Length 	: UINT;
		pData 	: pVoid;
		IsControlAccess 	: BOOL;(* := FALSE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode  : iprStates;
    MyPara      : CmdStruct;
    MyResult    : results;
  END_VAR

  retcode := BUSY;

  case Config.BusConfigSSW of
//**********************************************************************************************************************************************************
    _PrepareAccess:
      Config.RestLength := Length;
      Config.pActData   := pData;
      
      Config.BusConfigSSW := _StartAccess;
      
//**********************************************************************************************************************************************************
    _StartAccess:
      if IsControlAccess then
        LastSDO.Command := _BUS_IF_READ_VIA_SDO_CTRL;
      else
        LastSDO.Command := _BUS_IF_READ_VIA_SDO;      
      end_if;

      LastSDO.Offset  := Offset$DINT;
      if Config.RestLength > SDIAS_SAFETY_MAX_SDO_DATA_PER_CYCLE then
        LastSDO.Length  := SDIAS_SAFETY_MAX_SDO_DATA_PER_CYCLE;
      else
        LastSDO.Length  := Config.RestLength;
      end_if;
      LastSDO.ResponseArrived := FALSE;

      MyPara.uiCmd    := LastSDO.Command;
      MyPara.aPara[0] := LastSDO.Offset;
      MyPara.aPara[1] := LastSDO.Length;
      TmpRetcode := ToBusInterface.NewInst(#MyPara, #MyResult);    
      if TmpRetcode = READY then
        Config.SDOTimeMark  := ops.tAbsolute;
        Config.BusConfigSSW := _Wait4Answer;
      elsif TmpRetcode = ERROR then
        retcode := ERROR;
        LogError("(SdiasSafetyManager::BusConfigRead) Failed to add write SDO for module configuration");
      end_if;

//**********************************************************************************************************************************************************
    _Wait4Answer:
      // wait for response
      
      // check for response
      if LastSDO.ResponseArrived then
        Config.RestLength -= LastSDO.Length;
        Config.pActData   += LastSDO.Length;

        if Config.RestLength = 0 then
          retcode := READY;
          Config.BusConfigSSW := _PrepareAccess;
        end_if;
      elsif ((ops.tAbsolute - Config.SDOTimeMark) > SDIAS_SAFTEY_SDO_RESPONSE_TIMEOUT) then
        LogError("(SdiasSafetyManager::BusConfigRead) SDO Response timeout while waiting for the write response");
        retcode := ERROR;
      end_if;
      
//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION