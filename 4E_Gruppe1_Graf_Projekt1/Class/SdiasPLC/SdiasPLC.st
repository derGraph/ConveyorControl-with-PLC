//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SDIASM_OBJECT_PATH            16#88000002   // Object Path for VSDIASmanager Length = 2 (First 2byte), Domain = 0 (3rd byte), Escape Sequence SDIAS (4th byte) 
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SdiasPLC"
	Revision           = "1.38"
	GUID               = "{8EE0BE0E-BEE7-4218-A4AF-A0AB0DE83F43}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(502,120)">
	<Channels>
		<Server Name="ClassState" GUID="{CC338568-5E5E-4B72-BB67-E573CD9CE59F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the SDIAS Manager."/>
		<Server Name="FirmwareVersion" GUID="{110EDFDE-5D00-4525-834D-7E99AA65EEF4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server shows the actual FW Version of the Module in the format xx.yy&#13;&#10;&#13;&#10;e.g. 16#0130 means v01.30"/>
		<Server Name="InterfaceState">
		</Server>
		<Server Name="RetryCounter" GUID="{3BC15DE0-3955-4B15-86D2-18FB43792F0F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual Number of Retries on SDIAS-Bus."/>
		<Server Name="SdiasOut_1" GUID="{80FBEABF-F831-4CD7-B6AC-3A0056083736}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connect a SDIAS Client Class"/>
		<Client Name="SdiasHubBase1" Required="true" Internal="true"/>
		<Client Name="SdiasManager1" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.38" Date="11.05.2015" Author="RamAnd" Company="Sigmatek" Description="Corrected initialisation: It could have happened that a partial read list has been executed during startup, which could cause problems on SDIAS modules with FIFO-Buffers."/>
		<Dokumentation Revision="1.37" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="Added another step in initialisation to prevent watchdog error."/>
		<Dokumentation Revision="1.36" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="Added support for VaranMux."/>
		<Dokumentation Revision="1.35" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.34" Date="09.02.2015" Author="PieSte" Company="Sigmatek" Description="Avoid error on local sdias if there is no or wrong hardware at module initialization."/>
		<Dokumentation Revision="1.33" Date="27.01.2015" Author="RamAnd" Company="Sigmatek" Description="Increased the size of the SDO buffer from 30 to 64 (1 SDO for every module).&#13;&#10;If there are errors on single modules which are not required, other modules now work properly.&#13;&#10;The cyclic-method of SDIAS objects is now only called if the correct module hardware is available."/>
		<Dokumentation Revision="1.32" Date="09.12.2014" Author="RamAnd" Company="Sigmatek" Description="It has been possible that a SDIAS error has been triggered caused by issues which were corrected by the following retries."/>
		<Dokumentation Revision="1.31" Date="13.11.2014" Author="RamAnd" Company="Sigmatek" Description="Refresh Retrycounters before crashing with a required or SDIAS error.&#13;&#10;Removed call in interrupt method to save time and stack size."/>
		<Dokumentation Revision="1.30" Date="13.10.2014" Author="RamAnd" Company="Sigmatek" Description="If an error occurs and the project should not crash with SDIAS error, the bus is turned off now."/>
		<Dokumentation Revision="1.29" Date="30.09.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to create a SDIAS control access.&#13;&#10;Improved startup and error handling."/>
		<Dokumentation Revision="1.28" Date="11.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.27" Date="17.06.2014" Author="RamAnd" Company="Sigmatek" Description="The class no longer crashes if there are no required modules connected or no modules projected."/>
		<Dokumentation Revision="1.26" Date="28.04.2014" Author="ZoePat" Company="Sigmatek" Description="Added support for CP112 (Before a SDIAS error occured at startup)."/>
		<Dokumentation Revision="1.25" Date="15.04.2014" Author="RamAnd" Company="Sigmatek" Description="Corrected creation of isochronous DOs, which was done in cyclic priority and is now down in realtime priority."/>
		<Dokumentation Revision="1.24" Date="10.04.2014" Author="RamAnd" Company="Sigmatek" Description="Corrected initialisation of data objects which could have lead to problems with time synchronisation at safety modules."/>
		<Dokumentation Revision="1.23" Date="10.04.2014" Author="RamAnd" Company="Sigmatek" Description="Added dynamic read and write access, which can change it&apos;s size and offset during runtime."/>
		<Dokumentation Revision="1.22" Date="07.04.2014" Author="RamAnd" Company="Sigmatek" Description="Init start time wasn&apos;t set correctly for the timeout detection during initialization."/>
		<Dokumentation Revision="1.21" Date="06.03.2014" Author="RamAnd" Company="Sigmatek" Description="Corrected memory initialisation to support SDIAS PC. Changed limits of IsoStartPoint from 10-90% to 1-99%."/>
		<Dokumentation Revision="1.20" Date="12.02.2014" Author="RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Corrected error in SDO handling at local SDIAS, where the offset and length of read or write accesses was always delivered as 0 in the callback.&#13;&#10;Added interface to get task info before the payload to detect task errors more accurately."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd" Company="Sigmatek" Description="Added support for SDIAS PC."/>
		<Dokumentation Revision="1.0" Date="09.12.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SdiasPLC">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{0876B3F6-7B0D-4DDD-A261-E4AFE2F441AA}"
				Class      = "BusInterfaceSDIASInternal"
				Position   = "(158,120)"
				Visualized = "true">
				<Channels>
					<Server Name="CallCommand"/>
					<Server Name="InterfaceState"/>
					<Client Name="CycleTime" Value="1000"/>
					<Client Name="IsoStartPoint" Value="50"/>
					<Client Name="ToHwControl"/>
					<Client Name="ToOSKernel"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "SdiasHubBase1"
				GUID       = "{0E4AC654-3AAF-47F8-801F-8E6412D5D92B}"
				Class      = "SdiasHubBase"
				Position   = "(1860,600)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="SplitterPlace" Value="0"/>
					<Client Name="ToNextSDIAS"/>
				</Channels>
			</Object>
			<Object
				Name       = "SdiasManager1"
				GUID       = "{A6CE8FF7-1B3C-49A6-976D-ED8995566590}"
				Class      = "SdiasManager"
				Position   = "(1050,360)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="FirmwareVersion"/>
					<Server Name="IsoRdTaskDuration"/>
					<Server Name="IsoTaskErrorCount"/>
					<Server Name="IsoWrTaskDuration"/>
					<Server Name="RetryCounter"/>
					<Client Name="DeviceID" Value="0"/>
					<Client Name="ToBusInterface"/>
					<Client Name="ToMultiTask"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SdiasManager1" Destination="SdiasManager1.ClassState"/>
			<Connection Source="SdiasManager1.ToBusInterface" Destination="_base.CallCommand" Vertices="(1050,450),(658,270),"/>
			<Connection Source="_base.ToHwControl" Destination="this.ToHwControl" Vertices="(158,210),(38,210),"/>
			<Connection Source="this.InterfaceState" Destination="_base.InterfaceState" Vertices="(2458,210),(658,210),"/>
			<Connection Source="this.SdiasHubBase1" Destination="SdiasHubBase1.ClassSvr"/>
			<Connection Source="SdiasHubBase1.ToNextSDIAS" Destination="SdiasManager1.ClassState" Vertices="(1860,690),(1634,450),"/>
			<Connection Source="this.FirmwareVersion" Destination="SdiasManager1.FirmwareVersion" Vertices="(2458,390),(1634,570),"/>
			<Connection Source="this.ClassState" Destination="SdiasManager1.ClassState" Vertices="(2458,450),(1634,450),"/>
			<Connection Source="this.RetryCounter" Destination="SdiasManager1.RetryCounter" Vertices="(2458,510),(1634,510),"/>
			<Connection Source="this.SdiasOut_1" Destination="SdiasHubBase1.ClassSvr" Vertices="(2458,570),(2286,690),"/>
			<Connection Source="_base.CycleTime" Destination="this.CycleTime" Vertices="(158,270),(38,270),"/>
			<Connection Source="_base.IsoStartPoint" Destination="this.IsoStartPoint" Vertices="(158,330),(38,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using BusInterfaceSDIASInternal

SdiasPLC : CLASS
: BusInterfaceSDIASInternal
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	ClassState 	: SvrCh_t_e_VaranErrors;
	RetryCounter 	: SvrCh_UDINT;
	SdiasOut_1 	: SvrChCmd_DINT;
  //Clients:
	SdiasManager1 	: CltChCmd_SdiasManager;
	SdiasHubBase1 	: CltChCmd_SdiasHubBase;
  //Variables:
		ud_SDIASPosition 	: UDINT;
		a_StrFirmwareVersion : ARRAY [0..10] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL InterfaceState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FirmwareVersion::Read
		VAR_OUTPUT
			output (EAX) 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::Read
		VAR_OUTPUT
			output (EAX) 	: t_e_VaranErrors;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RetryCounter::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SdiasOut_1::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using SdiasHubBase
#pragma using SdiasManager


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SdiasPLC::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDIASPLC
1$UINT, 38$UINT, (SIZEOF(::SdiasPLC))$UINT, 
4$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1159122596), "SdiasPLC", //Class
TO_UDINT(3882880897), "BusInterfaceSDIASInternal", 1$UINT, 27$UINT, //Baseclass
//Servers:
(::SdiasPLC.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SdiasPLC.ClassState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::SdiasPLC.RetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3383993698), "RetryCounter", 
(::SdiasPLC.SdiasOut_1.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1297821089), "SdiasOut_1", 
//Clients:
(::SdiasPLC.SdiasManager1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3054961826), "SdiasManager1", TO_UDINT(2118381352), "SdiasManager", 1$UINT, 75$UINT, 
(::SdiasPLC.SdiasHubBase1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1699155000), "SdiasHubBase1", TO_UDINT(4173303375), "SdiasHubBase", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_SdiasPLC 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SdiasPLC] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SdiasPLC::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= BusInterfaceSDIASInternal::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= BusInterfaceSDIASInternal::InterfaceState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, BusInterfaceSDIASInternal::InterfaceState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SdiasPLC;
	vmt.CmdTable.NewInstr		:= #InterfaceState::NewInst();
	BusInterfaceSDIASInternal::InterfaceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF BusInterfaceSDIASInternal::InterfaceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FirmwareVersion.pMeth			:= StoreMethod( #FirmwareVersion::Read(), #M_NO_F() );
	IF FirmwareVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ClassState.pMeth			:= StoreMethod( #ClassState::Read(), #M_NO_F() );
	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RetryCounter.pMeth			:= StoreMethod( #RetryCounter::Read(), #M_NO_F() );
	IF RetryCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SdiasOut_1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #SdiasOut_1::Read();
	SdiasOut_1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasOut_1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SdiasPLC::FirmwareVersion::Read
	VAR_OUTPUT
		output (EAX) 	: HDINT;
	END_VAR

	FirmwareVersion := SdiasManager1.FirmwareVersion.Read();
	output := FirmwareVersion;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasPLC::ClassState::Read
	VAR_OUTPUT
		output (EAX) 	: t_e_VaranErrors;
	END_VAR

	ClassState := SdiasManager1.ClassState.Read();
	output := ClassState;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasPLC::RetryCounter::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	RetryCounter := SdiasManager1.RetryCounter.Read();
	output := RetryCounter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasPLC::SdiasOut_1::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SdiasOut_1 := SdiasHubBase1.ClassSvr.Read();
	output := SdiasOut_1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SdiasPLC::InterfaceState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	// local variables for the Requested HWTString
    pStr_HWTRequested     : ^CHAR;
  END_VAR

  pStr_HWTRequested := NIL;
  
  ret_code := READY;

  CASE pPara^.uiCmd OF
     
//**********************************************************************************************************************************************************
    CMD_GET_HARDWARE_DIAGNOSIS:
      
      ret_code := ERROR;
      pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR;
      
      pStr_HWTRequested     := pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.pStr_HardewareTreeEntry;
      
      if pStr_HWTRequested then
      
        // Check for SDIAS String
        if (pStr_HWTRequested)$^UINT^ = 2 then
          
          if (pStr_HWTRequested)$^UDINT^ = SDIASM_OBJECT_PATH then
            
            // Return OK, string was found
            ret_code  := READY;
            pResult^.aData$t_HWCGetHardwareDiagnosisOut.retcode       := _HWC_RETVAL_OK;
            
            pResult^.aData$t_HWCGetHardwareDiagnosisOut.ud_DeviceID   := SdiasManager1.DeviceID.Read();
            
            _itoa(udNumber := FirmwareVersion.Read(), pString := #a_StrFirmwareVersion[0]);  
            pResult^.aData$t_HWCGetHardwareDiagnosisOut.pStr_FWVersion := #a_StrFirmwareVersion[0];
            
          else
          
            // Length 2 and not the SDIAS HWT string is impossible
            ret_code := ERROR;
            pResult^.aData$t_HWCGetHardwareDiagnosisOut.retcode     := _HWC_RETVAL_ERROR_SDIAS_MODULE_NOT_FOUND;
            
          end_if;
          
          return;
        
        else
          // Pass on to base
          ret_code := BusInterfaceSDIASInternal::InterfaceState.NewInst(pPara, pResult);
        end_if;
      end_if;  

//**********************************************************************************************************************************************************
    CMD_GET_HARDWARE_TREE_ENTRY:
      
      ret_code := ERROR;
      pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_ERROR_VARAN_MODULE_NOT_FOUND;     
     
      pStr_HWTRequested     := pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.pStr_HardewareTreeEntry;
      
      //First HWT Path
      if pStr_HWTRequested = nil then
      
        ud_SDIASPosition := SDIASM_OBJECT_PATH;
      
        // Return String of the SDIASmanger
        ret_code := READY;
        pResult^.aData$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_OK_HWTSTR_RETURNED;
        pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.pStr_NextHardewareTreeEntry := (#ud_SDIASPosition)$^CHAR;
      
      elsif (pStr_HWTRequested)$^UINT^ = 2 then
        
        if pStr_HWTRequested^$UDINT = SDIASM_OBJECT_PATH then
          // Set passed string to nil so that it is identified as the 1st module after the manager
          pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.pStr_HardewareTreeEntry := nil;
          pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.us_current_index := 4;  // Point to place after SDIAS ESC.
          ret_code := BusInterfaceSDIASInternal::InterfaceState.NewInst(pPara, pResult);
        end_if;
      else
        // Pass on to base
        pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.us_current_index := 4;  // Point to place after SDIAS ESC.
        ret_code := BusInterfaceSDIASInternal::InterfaceState.NewInst(pPara, pResult);
      end_if;      

//**********************************************************************************************************************************************************    
    else
      ret_code := BusInterfaceSDIASInternal::InterfaceState.NewInst(pPara, pResult);
  END_CASE;
  
		
END_FUNCTION