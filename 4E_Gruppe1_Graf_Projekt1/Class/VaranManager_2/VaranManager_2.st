//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
// needed to use the same code as the other managing modules
#define VM2_SYNCHRON SuperiorSystemOK

#define VM2_SDO_INIT_CMD_LENGTH   12
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "VaranManager_2"
	Revision           = "1.68"
	GUID               = "{703CCEFE-8388-41CF-9CAF-868EA297FA66}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\VaranManager_2\VaranManager.ico"
	SharedCommandTable = "true"
	Objectsize         = "(678,120)"
	Comment            = "Class to handle a VaranManager component with 2 VARAN Out ports and the communication via VMC (VARAN Manager Client)">
	<Channels>
		<Server Name="Control">
		</Server>
		<Server Name="SafetyAsyRdMemUsed" GUID="{CAD80ECC-A820-473D-AC30-A442378A0D01}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This Server shows the actual size of the ReadData.&#13;&#10;The size of the User Data is not considered"/>
		<Server Name="SafetyAsyWrMemUsed" GUID="{8697ED00-E916-44AF-964A-089186071A58}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This Server shows the actual size of the WriteData.&#13;&#10;The size of the User Data is not considered"/>
		<Server Name="SafetyIsoRdMemUsed" GUID="{B4050056-4EF3-4402-8083-A5EF372E011E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This Server shows the actual size of the ReadData.&#13;&#10;The size of the User Data is not considered"/>
		<Server Name="SafetyIsoWrMemUsed" GUID="{B36DE46F-7911-4E69-B787-47B613A6CE19}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This Server shows the actual size of the WriteData.&#13;&#10;The size of the User Data is not considered"/>
		<Server Name="SafetyMemState" GUID="{0E3C8CB6-DA94-4605-8D58-8C16871BACB8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the Safety Data Transfer&#13;&#10;&#13;&#10; _ALL_OK&#13;&#10;-----------------------------------------------------&#13;&#10;The Data Transfer is active, No Error occured&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SAFETY_TRANSFER_NOT_ACTIVE&#13;&#10;-----------------------------------------------------&#13;&#10;Safety Data Transfer is not active.&#13;&#10;Last identified Error&#13;&#10;&#13;&#10;Reasons&#13;&#10;  SafetyIsoMemRead = 0&#13;&#10;  SafetyIsoMemWrite = 0&#13;&#10;  SafetyAsyMemRead = 0&#13;&#10;  SafetyAsyMemWite = 0&#13;&#10;  on the Varanmanager: IsAlsoClient = 0&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ASY_MEM_NOT_EQUAL&#13;&#10;-----------------------------------------------------&#13;&#10;The size of Client: &quot;SafetyAsyMemRead&quot; on the &#13;&#10;Manager side(Client side) and the &quot;SafetyAsyMemWrite&quot; &#13;&#10;on the Client side(Manager side) is not identically &#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ISO_MEM_NOT_EQUAL&#13;&#10;-----------------------------------------------------&#13;&#10;The size of Client: &quot;SafetyIsoMemRead&quot; on the &#13;&#10;Manager side(Client side) and the &quot;SafetyIsoMemWrite&quot; &#13;&#10;on the Client side(Manager side) is not identically &#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SET_ASY_WR_SIZE_TO_HIGH&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyAsyMemWrite is higher,&#13;&#10;than the maximal available memory size.&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SET_ASY_RD_SIZE_TO_HIGH&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyAsyMemRead is higher,&#13;&#10;than the maximal available memory size.&#13;&#10;=====================================================&#13;&#10; &#13;&#10; _SET ISO_WR_SIZE_TO_HIGH&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyIsoMemWrite is higher,&#13;&#10;than the maximal available memory size.&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SET_ISO_RD_SIZE_TO_HIGH&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyIsoMemRead is higher,&#13;&#10;than the maximal available memory size.&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SET_ASY_RD_SIZE_TO_SMALL&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyAsyMemRead is lower,&#13;&#10;than the minimal needed memory size.&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _SET ISO_WR_SIZE_TO_SMALL&#13;&#10;-----------------------------------------------------&#13;&#10;The appointed size for SafetyAsyMemWrite is lower,&#13;&#10;than the minimal needed memory size.&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ASY_WR_INSTALL_ERROR&#13;&#10;-----------------------------------------------------&#13;&#10;An Error has occured, during the allocation of &#13;&#10;the memory for the asynchronous write data.&#13;&#10;data transfer not possible&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ASY_RD_INSTALL_ERROR&#13;&#10;-----------------------------------------------------&#13;&#10;An Error has occured, during the allocation of &#13;&#10;the memory for the asynchronous read data.&#13;&#10;data transfer not possible&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ISO_WR_INSTALL_ERROR&#13;&#10;-----------------------------------------------------&#13;&#10;An Error has occured, during the allocation of &#13;&#10;the memory for the isochronous write data.&#13;&#10;data transfer not possible&#13;&#10;=====================================================&#13;&#10;&#13;&#10; _ISO_RD_INSTALL_ERROR&#13;&#10;-----------------------------------------------------&#13;&#10;An Error has occured, during the allocation of &#13;&#10;the memory for the isochronous read data.&#13;&#10;data transfer not possible&#13;&#10;=====================================================&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Server Name="VaranOut_1" GUID="{EFAE6743-B53A-45D2-AA3E-F9482724A92C}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="VaranOut_2" GUID="{A71F126B-B989-4037-BDBE-1C06440E16EE}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Client Name="Hub_Base_Root0" Required="true" Internal="true"/>
		<Client Name="Hub_Base_Root1" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.68" Date="11.11.2015" Author="EisMic" Company="Sigmatek" Description="Check for unallowed safety topology."/>
		<Dokumentation Revision="1.67" Date="29.06.2015" Author="EisMic" Company="Sigmatek" Description="- Prevented access exception if a varanmanagertime greater 32ms was set at the client.&#13;&#10;- CyWork, RtWork, UpdateRTPostScan: Free Mutex if there are returns in the methods.&#13;&#10;- Electronic Typelabel: Supported more information at varanmanager module (eg. Vendorname, DeviceName, SerialNo, LicenseNo, OrderingNo,...)"/>
		<Dokumentation Revision="1.66" Date="21.05.2015" Author="EisMic" Company="Sigmatek" Description="Corrected handling of SyncFrameCounter in RtWork which could lead to a problem at isochrone CAN behind varan (e.g. CIV 521)."/>
		<Dokumentation Revision="1.65" Date="12.05.2015" Author="EisMic" Company="Sigmatek" Description="Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.64" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="Added another step in initialisation to prevent watchdog error."/>
		<Dokumentation Revision="1.63" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="Added support for VaranMux."/>
		<Dokumentation Revision="1.62" Date="04.12.2014" Author="RamAnd" Company="Sigmatek" Description="Added support for safety via FSoE"/>
		<Dokumentation Revision="1.61" Date="23.03.2015" Author="RamAnd" Company="Sigmatek" Description="Prevent crash if the user calls public methods and the VARAN interface is not available (e.g. on LARS)"/>
		<Dokumentation Revision="1.60" Date="24.01.2015" Author="RamAnd" Company="Sigmatek" Description="If a post init object is finished (completed or error) than it&apos;s still called during the post init phase to allow triggering of watchdogs.&#13;&#10;Furthermore this module is removed from the list of modules to wait for (creating DOs and Move-DOs)."/>
		<Dokumentation Revision="1.59" Date="25.11.2014" Author="LanSte" Company="Sigmatek" Description="Corrected IsoVaranTime calcualtion with MultivaranInterface.&#13;&#10;Corrected Trace Message when an unknown NewInst command was recieved."/>
		<Dokumentation Revision="1.58" Date="11.08.2014" Author="EisMic" Company="Sigmatek" Description="Deactivated Varan Error when running a programm in LARS."/>
		<Dokumentation Revision="1.57" Date="01.08.2014" Author="RamAnd" Company="Sigmatek" Description="Asynchron VARAN DOs may not have been started on ARM CPUs, because the image of the DOs wasn&apos;t copied correctly to the VM DPRAM."/>
		<Dokumentation Revision="1.56" Date="30.07.2014" Author="RamAnd" Company="Sigmatek" Description="Added flag for every post init object, so it is only called if it hasn&apos;t finished post init work yet."/>
		<Dokumentation Revision="1.55" Date="11.07.2014" Author="LanSte" Company="Sigmatek" Description="Added support for reading hardware diagnosis."/>
		<Dokumentation Revision="1.54" Date="19.05.2014" Author="LanSte" Company="Sigmatek" Description="Added support for INTERFACE_MULTIVARANMANAGER dol timing Methods. Removed PayloadMEM clients as they are not supported."/>
		<Dokumentation Revision="1.53" Date="15.04.2014" Author="RamAnd" Company="Sigmatek" Description="Changed initialisation:&#13;&#10; - Asynchron work is now independent of isochronous initialisation state machine&#13;&#10; - Removed thread for sorting DOs. This is now done in a seperate init step called by the HwControl"/>
		<Dokumentation Revision="1.52" Date="26.03.2014" Author="ZoePat" Company="Sigmatek" Description="Overwritten Servers deleted, because there is no need to change anything. Min_RtTime, Max_RtTime, Min_RtCallTime and Max_RtCallTime are now &quot;WriteProtected=false&quot;."/>
		<Dokumentation Revision="1.51" Date="11.03.2014" Author="EisMic" Company="Sigmatek" Description="Added Server IsoVaranTimeMax."/>
		<Dokumentation Revision="1.50" Date="12.02.2014" Author="RamAnd&#13;&#10;PieSte&#13;&#10;ZoePat" Company="Sigmatek" Description="Thread for sorting DOs is now created in init to prevent errors in task handling on Salamander systems.&#13;&#10;Changed min/max value for IsoStartPoint in base to get more flexibilty.&#13;&#10;Corrected AccessException if no VaranInterface is avaliable."/>
		<Dokumentation Revision="1.40" Date="22.01.2014" Author="RamAnd&#13;&#10;&#13;&#10;PieSte" Company="Sigmatek" Description="Initialisation of VaranManager and SdiasManager has been reworked for cases where multiple Safety cpus are connected via VI021.&#13;&#10;Fixed free FileDate before use in Base VaranManager."/>
		<Dokumentation Revision="1.30" Date="04.12.2013" Author="LanSte&#13;&#10;RamAnd&#13;&#10;FucHer" Company="Sigmatek" Description="Added NewInst Method to allow force endeing PostInit on timeout.&#13;&#10;Fixed call to end VM own PostInit Phase.&#13;&#10;Added postinit call to prevent user classes being called before the Varanmanager has finished its config.&#13;&#10;Fixed case dureing startup where the ISO DOL was started twice in one cycle.&#13;&#10;The manager has added himself to the internal client list, which lead to writing 68 to the control server if a required error occured.&#13;&#10;Fixed crash if no VARAN interface was available, but objects of VARAN module classes were placed.&#13;&#10;Added payload support&#13;&#10;GetVaranPosition(): keyword AWL removed.  Mutex replaces CLI, STI.&#13;&#10;Renamed define to make them class specific. Class was not compatible with VBC021."/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="RamAnd" Company="Sigmatek" Description="Changed range of the safety NewInst commands. Range for HW-Classes: 0x8000-0x8FFF; Range for Safety HW-Classes: 0x8100-0x81FF"/>
		<Dokumentation Revision="1.10" Date="22.01.2013" Author="RamAnd&#13;&#10;SvePau&#13;&#10;SvePau" Company="Sigmatek" Description="Improved handshake for isochronous safety data&#13;&#10;Included TRACE message output if SDOData are sent, before the SDO init has finished. &#13;&#10;Included handling that SDO data transfer for receiving Init CMD is only active if receive memory is empty or containing the init information."/>
		<Dokumentation Revision="1.5" Date="27.03.2012" Author="SvePau" Company="Sigmatek" Description="Integration of safety data handling routines"/>
		<Dokumentation Revision="1.4" Date="05.10.2011" Author="RamAnd" Company="Sigmatek" Description="The Client To_Multitask of the base class has been moved to the bottom, since it has no connection to the derivations."/>
		<Dokumentation Revision="1.3" Date="17.02.2011" Author="BleErn" Company="Sigmatek" Description="Content of corresponding LASAL Hardware Description file (.lhd) which is necessary for the hardware editor has been updated"/>
		<Dokumentation Revision="1.2" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="1.1" Date="15.10.2010" Author="BleErn" Company="Sigmatek" Description="Added new method GetNsTimeBPLLTicks for easier internal time measurements.&#13;&#10;Added new methods AddDAClientRdData and SendDAClientWrData to access new direct access alternating buffer on VMC hardware.&#13;&#10;Function to display CDIAS/DIAS required error&#13;&#10;VaranManager crashed if the master was shut-down when the master was not started (eg. _NoVaranInterface on LARS)&#13;&#10;Read-Method of clients is now always called before using a value.&#13;&#10;Trace-Messages now only appear once&#13;&#10;Act_RtTime showed incorrect values if no hardware was connected&#13;&#10;Comment of Server ManagerOn was not complete&#13;&#10;Server SuperiorSystemOK now shows if VaranManagerClient functionality is not used&#13;&#10;Time-Measurement of VaranManager did not stop if Manager was set off but rest of system was still alive"/>
		<Dokumentation Revision="1.0" Date="13.07.2010" Author="BleErn" Company="Sigmatek" Description="Content of corresponding LASAL Hardware Description file (.lhd) which is necessary for the hardware editor has been corrected"/>
	</RevDoku>
	<Network Name="VaranManager_2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{515CA848-9327-4920-A75E-32F9274FA403}"
				Class      = "VaranManager"
				Position   = "(420,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Act_RtCallTime"/>
					<Server Name="Act_RtTime"/>
					<Server Name="AsyVaranTime"/>
					<Server Name="Control"/>
					<Server Name="IsoVaranTime"/>
					<Server Name="IsoVaranTimeMax"/>
					<Server Name="ManagerOn"/>
					<Server Name="Max_RtCallTime"/>
					<Server Name="Max_RtTime"/>
					<Server Name="Min_RtCallTime"/>
					<Server Name="Min_RtTime"/>
					<Server Name="Release"/>
					<Server Name="RetryCounter"/>
					<Server Name="State"/>
					<Server Name="SuperiorSystemOK"/>
					<Client Name="IRQTaskTime"/>
					<Client Name="IsAlsoClient"/>
					<Client Name="IsoStartPoint"/>
					<Client Name="PayloadFrame"/>
					<Client Name="PreventManagerError"/>
					<Client Name="SafetyAsyMemRead"/>
					<Client Name="SafetyAsyMemWrite"/>
					<Client Name="SafetyIsoMemRead"/>
					<Client Name="SafetyIsoMemWrite"/>
					<Client Name="SuperiorSystemTime"/>
					<Client Name="To_HwControl"/>
					<Client Name="To_Multitask"/>
					<Client Name="VaranManagerNr" Value="0"/>
					<Client Name="VaranManagerTime" Value="1000000"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base_Root0"
				GUID       = "{864E5914-5CA6-4EB6-AF58-0127F9869779}"
				Class      = "Hub_Base_Root"
				Position   = "(1470,1020)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="0"/>
					<Client Name="VaranConnect"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base_Root1"
				GUID       = "{95ED7D7B-6BB0-418D-A8DE-863330E90254}"
				Class      = "Hub_Base_Root"
				Position   = "(1470,1230)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="1"/>
					<Client Name="VaranConnect"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="_base.To_HwControl" Destination="this.To_HwControl" Vertices="(420,210),(38,210),"/>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(1942,210),(1064,210),"/>
			<Connection Source="this.State" Destination="_base.State" Vertices="(1942,270),(1064,270),"/>
			<Connection Source="this.ManagerOn" Destination="_base.ManagerOn" Vertices="(1942,330),(1064,330),"/>
			<Connection Source="this.Release" Destination="_base.Release" Vertices="(1942,390),(1064,390),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1942,450),(1064,450),"/>
			<Connection Source="this.IsoVaranTime" Destination="_base.IsoVaranTime" Vertices="(1942,510),(1064,510),"/>
			<Connection Source="this.AsyVaranTime" Destination="_base.AsyVaranTime" Vertices="(1942,630),(1064,630),"/>
			<Connection Source="_base.VaranManagerTime" Destination="this.VaranManagerTime" Vertices="(420,270),(38,270),"/>
			<Connection Source="_base.VaranManagerNr" Destination="this.VaranManagerNr" Vertices="(420,330),(38,330),"/>
			<Connection Source="this.VaranOut_1" Destination="Hub_Base_Root0.Control" Vertices="(1942,1110),(1800,1050),(1800,1110),(1770,1110),"/>
			<Connection Source="Hub_Base_Root0.VaranConnect" Destination="_base.Control" Vertices="(1470,1170),(1350,1170),(1350,210),(1064,210),"/>
			<Connection Source="Hub_Base_Root1.VaranConnect" Destination="_base.Control" Vertices="(1470,1380),(1350,1380),(1350,210),(1064,210),"/>
			<Connection Source="this.VaranOut_2" Destination="Hub_Base_Root1.Control" Vertices="(1942,1170),(1830,1110),(1830,1320),(1770,1320),"/>
			<Connection Source="this.Act_RtTime" Destination="_base.Act_RtTime" Vertices="(1942,690),(1064,690),"/>
			<Connection Source="this.Min_RtTime" Destination="_base.Min_RtTime" Vertices="(1942,750),(1064,750),"/>
			<Connection Source="this.Max_RtTime" Destination="_base.Max_RtTime" Vertices="(1942,810),(1064,810),"/>
			<Connection Source="this.Act_RtCallTime" Destination="_base.Act_RtCallTime" Vertices="(1942,870),(1064,870),"/>
			<Connection Source="this.Min_RtCallTime" Destination="_base.Min_RtCallTime" Vertices="(1942,930),(1064,930),"/>
			<Connection Source="this.Max_RtCallTime" Destination="_base.Max_RtCallTime" Vertices="(1942,990),(1064,990),"/>
			<Connection Source="_base.IsoStartPoint" Destination="this.IsoStartPoint" Vertices="(420,450),(38,450),"/>
			<Connection Source="this.Hub_Base_Root0" Destination="Hub_Base_Root0.Control"/>
			<Connection Source="this.Hub_Base_Root1" Destination="Hub_Base_Root1.Control"/>
			<Connection Source="_base.IRQTaskTime" Destination="this.IRQTaskTime" Vertices="(420,510),(38,510),"/>
			<Connection Source="_base.IsAlsoClient" Destination="this.IsAlsoClient" Vertices="(420,570),(38,570),"/>
			<Connection Source="_base.SuperiorSystemTime" Destination="this.SuperiorSystemTime" Vertices="(420,630),(38,630),"/>
			<Connection Source="this.SuperiorSystemOK" Destination="_base.SuperiorSystemOK" Vertices="(1942,1050),(1064,1050),"/>
			<Connection Source="_base.PreventManagerError" Destination="this.PreventManagerError" Vertices="(420,390),(38,390),"/>
			<Connection Source="_base.SafetyIsoMemRead" Destination="this.SafetyIsoMemRead" Vertices="(420,750),(38,690),"/>
			<Connection Source="_base.SafetyIsoMemWrite" Destination="this.SafetyIsoMemWrite" Vertices="(420,810),(38,750),"/>
			<Connection Source="_base.SafetyAsyMemRead" Destination="this.SafetyAsyMemRead" Vertices="(420,870),(38,810),"/>
			<Connection Source="_base.SafetyAsyMemWrite" Destination="this.SafetyAsyMemWrite" Vertices="(420,930),(38,870),"/>
			<Connection Source="_base.PayloadFrame" Destination="this.PayloadFrame" Vertices="(420,990),(38,930),"/>
			<Connection Source="this.IsoVaranTimeMax" Destination="_base.IsoVaranTimeMax" Vertices="(1942,570),(1064,570),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using VaranManager

VaranManager_2 : CLASS
: VaranManager
  //Servers:
	VaranOut_1 	: SvrChCmd_DINT;
	VaranOut_2 	: SvrChCmd_DINT;
	SafetyMemState 	: SvrCh_t_e_SafetyMemState;
	SafetyIsoRdMemUsed 	: SvrCh_DINT;
	SafetyIsoWrMemUsed 	: SvrCh_DINT;
	SafetyAsyRdMemUsed 	: SvrCh_DINT;
	SafetyAsyWrMemUsed 	: SvrCh_DINT;
  //Clients:
	Hub_Base_Root0 	: CltChCmd_Hub_Base_Root;
	Hub_Base_Root1 	: CltChCmd_Hub_Base_Root;
  //Variables:
		OldReadCounter 	: UINT;
		b_SynchronWatch 	: BOOL;
		SynchronFailCnt 	: DINT;
		OldSynchron 	: DINT;
		pNeedThisClass4GlobVarDef 	: ^SafetyCDIAS_Base;
		SDOTransfer 	: t_SdoBlock;
		pIsoWriteData 	: ^void;
		pIsoReadData 	: ^void;
		b_Safety 	: BOOL;
		bStartInit 	: BOOL;
		bReadAsyCtrs 	: BOOL;
		MyPath : ARRAY [0..3] OF USINT;

		bReadyForDataTransfer 	: BOOL;
		MyDummyCtr 	: USINT;
		b_InterfaceFramesPossible 	: BOOL;
		EarlyCmd 	: UINT;
		BitsInitSSW 	: UDINT;
		BitInitTime 	: UDINT;
		OldIsoRdCnt 	: UINT;
		b_FSoEAvailable 	: BOOL;
  //Functions:
				//! <Function Comment="Init for VaranManager" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This function is called in PostScan by VaranManagerPostScan" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Normal Rt - Funktion for VaranManager_Base" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION SDOTxDataTraffic;
	
	FUNCTION SDORxDataTraffic;
	
	FUNCTION SendSdoData
		VAR_INPUT
			pData 	: ^void;
			uLength 	: UINT;
			Cmd 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
	
	FUNCTION ResetSDODataTraffic;
	
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Hub_Base_Root


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB VaranManager_2::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VARANMANAGER_2
1$UINT, 68$UINT, (SIZEOF(::VaranManager_2))$UINT, 
7$UINT, 2$UINT, 0$UINT, 
TO_UDINT(4019434288), "VaranManager_2", //Class
TO_UDINT(2940693151), "VaranManager", 2$UINT, 26$UINT, //Baseclass
//Servers:
(::VaranManager_2.VaranOut_1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2138873746), "VaranOut_1", 
(::VaranManager_2.VaranOut_2.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3866480168), "VaranOut_2", 
(::VaranManager_2.SafetyMemState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2030950923), "SafetyMemState", 
(::VaranManager_2.SafetyIsoRdMemUsed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2442149559), "SafetyIsoRdMemUsed", 
(::VaranManager_2.SafetyIsoWrMemUsed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1641235284), "SafetyIsoWrMemUsed", 
(::VaranManager_2.SafetyAsyRdMemUsed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3173824998), "SafetyAsyRdMemUsed", 
(::VaranManager_2.SafetyAsyWrMemUsed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1299170309), "SafetyAsyWrMemUsed", 
//Clients:
(::VaranManager_2.Hub_Base_Root0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3781719598), "Hub_Base_Root0", TO_UDINT(1770276445), "Hub_Base_Root", 2$UINT, 10$UINT, 
(::VaranManager_2.Hub_Base_Root1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2523875000), "Hub_Base_Root1", TO_UDINT(1770276445), "Hub_Base_Root", 2$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_VaranManager_2 37

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_VaranManager_2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION VaranManager_2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= VaranManager::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= VaranManager_Base::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, VaranManager_Base::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_VaranManager_2;
	vmt.CmdTable.NewInstr		:= #Control::NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
	VaranManager_Base::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranManager_Base::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_2.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_2.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd SafetyCDIAS_Base

//{{LSL_IMPLEMENTATION
#pragma using HwControl
#pragma using Hub_Base

VAR_EXTERNAL
  pSafetyManagerThis   : pVirtualBase;
  b_SafetyOnLocalCDIAS : BOOL;
END_VAR

//#define SDO_TIME_MEASUREMENT


FUNCTION VIRTUAL GLOBAL VaranManager_2::Init
  VAR
		MyPara 	    : CmdStruct;
		MyResult	  : results;
  END_VAR

  VaranManager::Init();
  
  if bExternalInit = true then
    bExternalInit := false;
    return;
  end_if;
    
  us_InitCounter += 1;
  
  case us_InitCounter of

//**********************************************************************************************************************************************************
    1: // in first init we ensure that the pointer is NIL (and not any value that is in the memory)
          
        // look if safety functionality is active
        if IsAlsoClient         <> 0
           & SuperiorSystemTime <> 0 
           & SafetyIsoMemRead   <> 0 
           & SafetyIsoMemWrite  <> 0
           & SafetyAsyMemRead   <> 0 
           & SafetyAsyMemWrite  <> 0 then
           
          b_Safety := true;
         
          // this module is not connected via VARAN => tell the cdias safety modules
          b_SafetyOnLocalCDIAS := TRUE;
          
          // initialize old write counter from other side for comparison (invalid value, because it only counts only up to 16#7FFF)
          OldIsoRdCnt := 16#FFFF;
        else
          b_Safety          := false;
          SafetyAsyMemRead  := 0;
          SafetyAsyMemWrite := 0;
          SafetyIsoMemRead  := 0;
          SafetyIsoMemWrite := 0;
          return; // no safety init
        end_if;
  
        if b_Safety then
          pSafetyManagerThis := NIL;
          
          // this module is not connected via VARAN => tell the other objects of this class
          b_SafetyOnLocalCDIAS := TRUE;
          
          // the 3rd parameter of the calls from this class is always the this pointer
          SDOTransfer.MyPara.aPara[2] := this$DINT;
          
          if ((IsAlsoClient = 1) <> (SuperiorSystemTime <> 0)) then 
            IsAlsoClient        := 0;
            SuperiorSystemTime  := 0;  
            TRACE("(VaranManager_2) SuperiorSystemTime or IsAlsoClient settings are wrong");
          end_if;
          
        #ifdef SDO_TIME_MEASUREMENT
          for i:=0 to 2 by 1 do
            SDOTransfer.TimeMeasure[i].Maximum := 0;
            SDOTransfer.TimeMeasure[i].Minimum := 16#FFFFFFFF;
          end_for;
        #endif
        end_if;

//**********************************************************************************************************************************************************      
//  2:  // in the second init the SafetyManager sets the pointer (if there is an object of the SafetyManager)

//**********************************************************************************************************************************************************
    3: // in the third init we check for a safety manager and tell him that we're here    
        if b_Safety then
          if pSafetyManagerThis then 
            MyPara.uiCmd    := CMD_SM_ADD_MODULE;
            MyPara.aPara[0] := _VaranManager4VMC;
            MyPara.aPara[1] := THIS$DINT;

            // get our own path (needed for interface frames)
            // length
            MyPath[0] := 2;
            
            // domain number
  #ifdef HWT_ucGetMyDomain
            if pHardwareTree & (pHardwareTree^.udVersion >= 16#1003) then
              // domain info byte
              MyPath[1] := HWT_ucGetMyDomain();
              if (MyPath[1] < 0) | (MyPath[1] > 15) then
                // invalid domain number set in this system
                MyPath[1] := 0;
                TRACE("(VaranManager_2::Init) Invalid or no domain number set");
              end_if;
            else
              // domain info byte
              MyPath[1] := 0;
              TRACE("(VaranManager_2::Init) Newer OS version required for domain number support");
            end_if;
  #else
            // domain info byte
            MyPath[1] := 0;
            TRACE("(VaranManager_2::Init) Newer lsl_st_hardwaretree.h needed to get domain number from OS");
  #endif
            
            // VARAN escape sequence
            MyPath[2] := HWT_ESCAPE_VARAN;
            MyPara.aPara[2] := (#MyPath[0])$DINT;

            pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
          else
            // if there is no safety manager => problem, because this class won't work without
            State := _ManagerNotExists;
          end_if;
        end_if;
      
//**********************************************************************************************************************************************************     
  //4: // in the fourth init the managing slave objects log in (to be the last one called in the token ring => give the token back to master)

//**********************************************************************************************************************************************************     
    6:  // all ISO and ASY objects are added  
        
        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
        // evaluate safety ASY read mem size/state
        if SafetyAsyMemRead = 0 then 
          SafetyAsyMemWrite := 0;
          SafetyMemState    := _NOT_ACTIVE;
        elsif SafetyAsyMemRead = -1 then
          // set maximum possible memory size
          SafetyAsyMemRead := ((VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) - UserObjectData.udAsyReadLength)$DINT;
        elsif SafetyAsyMemRead >= (VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) then
          // the set size is too high
          SafetyAsyMemRead  := 0;
          SafetyAsyMemWrite := 0;
          SafetyMemState    := _ASY_RD_SIZE_TOO_HIGH;
        elsif ((SafetyAsyMemRead < MIN_SDO_MEMSIZE) & (SafetyAsyMemRead > 0)) then
          // set memory size to minimal needed size
          SafetyAsyMemRead := MIN_SDO_MEMSIZE;
          TRACE("(VaranManager_2::Init) set memory size of safety ASY Read data has been set to 16 byte");
        end_if;

        // evaluate safety ASY write mem size/state
        if SafetyAsyMemWrite = 0 then 
          SafetyAsyMemRead := 0;
          SafetyMemState   := _NOT_ACTIVE;
        elsif SafetyAsyMemWrite = -1 then
          // set maximum possible memory size
          SafetyAsyMemWrite := ((VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) - UserObjectData.udAsyReadLength)$DINT;
        elsif SafetyAsyMemWrite >= (VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) then
          // the set size is too high
          SafetyAsyMemRead  := 0;
          SafetyAsyMemWrite := 0;
          SafetyMemState := _ASY_WR_SIZE_TOO_HIGH;
        elsif ((SafetyAsyMemWrite < MIN_SDO_MEMSIZE) & (SafetyAsyMemWrite > 0)) then
          // set memory size to minimal needed size
          SafetyAsyMemWrite := MIN_SDO_MEMSIZE;
          TRACE("(VaranManager_2::Init) set memory size of safety ASY Write data has been set to 16 byte");
        end_if;
        
        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
        // evaluate safety ISO read mem size/state
        
        if SafetyIsoMemRead = 0 then
          SafetyMemState    := _NOT_ACTIVE;
        elsif SafetyIsoMemRead = -1 then
          // set maximum possible memory size
          SafetyIsoMemRead := ((VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) - UserObjectData.udIsoReadLength)$DINT;
        elsif SafetyIsoMemRead >= (VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) then
          // the set size is too high
          SafetyIsoMemRead := 0;
          SafetyMemState := _ISO_RD_SIZE_TOO_HIGH;
        else
          if b_FSoEAvailable then
            if ((SafetyIsoMemRead < MIN_PDO_MEMSIZE_FSOE) & (SafetyIsoMemRead > 0)) then
              // set memory size to minimal needed size
              SafetyIsoMemRead := MIN_PDO_MEMSIZE_FSOE;
              TRACE("(VaranManager_2::Init) set memory size of safety Iso read data has been set to 6 byte");
            end_if;
          elsif ((SafetyIsoMemRead < MIN_PDO_MEMSIZE) & (SafetyIsoMemRead > 0)) then
            // set memory size to minimal needed size
            SafetyIsoMemRead := MIN_PDO_MEMSIZE;
            TRACE("(VaranManager_2::Init) set memory size of safety Iso read data has been set to 60 byte");
          end_if;
        end_if;
        
        // evaluate safety ISO Write mem size/state
        if SafetyIsoMemWrite = 0 then
          SafetyMemState    := _NOT_ACTIVE;
        elsif SafetyIsoMemWrite = -1 then
          // set maximum possible memory size
          SafetyIsoMemWrite := ((VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) - UserObjectData.udIsoWriteLength)$DINT;
        elsif SafetyIsoMemWrite >= (VM_CLIENT_MAX_BUFFER_USE - VM_CLIENT_HEADER_SIZE) then
          // the set size is too high
          SafetyIsoMemWrite := 0;
          SafetyMemState := _ISO_WR_SIZE_TOO_HIGH;
        else
          if b_FSoEAvailable then
            if ((SafetyIsoMemWrite < MIN_PDO_MEMSIZE_FSOE) & (SafetyIsoMemWrite > 0)) then
              // set memory size to minimal needed size
              SafetyIsoMemWrite := MIN_PDO_MEMSIZE_FSOE;
              TRACE("(VaranManager_2::Init) set memory size of safety Iso write data has been set to 6 byte");
            end_if;
          elsif ((SafetyIsoMemWrite < MIN_PDO_MEMSIZE) & (SafetyIsoMemWrite > 0)) then
            // set memory size to minimal needed size
            SafetyIsoMemWrite := MIN_PDO_MEMSIZE;
            TRACE("(VaranManager_2::Init) set memory size of safety Iso write data has been set to 60 byte");
          end_if;
        end_if;
        
        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  
        // add ASY DOs
        if (SafetyAsyMemWrite$UDINT + UserObjectData.udAsyWriteLength) then
          // allocate memory for the Asy SDOs
          AsyWriteData.pSDOData := To_StdLib.Malloc(size:= SafetyAsyMemWrite$UDINT + UserObjectData.udAsyWriteLength);

          if AsyWriteData.pSDOData <> NIL then
            // reset allocated memory area
            _memset(dest:=AsyWriteData.pSDOData, usByte:=0, cntr:= SafetyAsyMemWrite$UDINT + UserObjectData.udAsyWriteLength);
          else
            TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ASY write data"); 
            SafetyMemState := _ASY_WR_INSTALL_ERROR;
          end_if;
        end_if;
        
        //allocated memory
        p_ASYDataWrite$^void := To_StdLib.Malloc( size := SafetyAsyMemWrite$UDINT + UserObjectData.udAsyWriteLength + VM_CLIENT_HEADER_SIZE );
        
        if p_ASYDataWrite <> NIL then
          // reset allocated memory area
          _memset(dest:= p_ASYDataWrite, usByte:=0, cntr:= SafetyAsyMemWrite$UDINT + UserObjectData.udAsyWriteLength + VM_CLIENT_HEADER_SIZE);
        else
          TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ASY write data"); 
          SafetyMemState := _ASY_WR_INSTALL_ERROR;
        end_if;
         
        if (SafetyAsyMemRead$UDINT + UserObjectData.udAsyReadLength) then
          // allocate memory for the Asy SDOs
          AsyReadData.pSDOData := To_StdLib.Malloc(size:= SafetyAsyMemRead$UDINT + UserObjectData.udAsyReadLength);
        
          if AsyReadData.pSDOData <> NIL then
            // reset allocated memory area
            _memset(dest:=AsyReadData.pSDOData, usByte:=0, cntr:= SafetyAsyMemRead$UDINT + UserObjectData.udAsyReadLength);
          else
            TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ASY Read data");  
            SafetyMemState := _ASY_RD_INSTALL_ERROR;
          end_if;
        end_if;
        
        //allocated memory
        p_ASYDataRead$^void := To_StdLib.Malloc( size := SafetyAsyMemRead$UDINT + UserObjectData.udAsyReadLength + VM_CLIENT_HEADER_SIZE );
        
        if p_ASYDataRead <> NIL then
          // reset allocated memory area
          _memset(dest:= p_ASYDataRead, usByte:=0, cntr:= SafetyAsyMemRead$UDINT + UserObjectData.udAsyReadLength + VM_CLIENT_HEADER_SIZE );
        else
          TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ASY Read data");  
          SafetyMemState := _ASY_RD_INSTALL_ERROR;
        end_if;

        

        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  
        // Add ISO DOs
        
        // allocate memory for the whole Iso PDO without user data 
        pIsoWriteSafetyData$^void := To_StdLib.Malloc(size:= SafetyIsoMemWrite$UDINT + VM_CLIENT_HEADER_SIZE);
        
        if pIsoWriteSafetyData <> NIL then
          // reset allocated memory area
          _memset(dest:=pIsoWriteSafetyData, usByte:=0, cntr:= SafetyIsoMemWrite$UDINT + VM_CLIENT_HEADER_SIZE); 

          if SafetyIsoMemWrite then
            pIsoWriteSafetyData^.Safety_Header.StateInfo.InterfaceFramesPossible := b_InterfaceFramesPossible;
          end_if;
        else
          TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ISO write data");  
          SafetyMemState := _ISO_WR_INSTALL_ERROR;
        end_if;
        

        // allocate memory for the whole Iso PDO without user data 
        pIsoReadSafetyData$^void := To_StdLib.Malloc(size:= SafetyIsoMemRead$UDINT + VM_CLIENT_HEADER_SIZE);
          
        if pIsoReadSafetyData <> NIL then
          // reset allocated memory area
          _memset(dest:=pIsoReadSafetyData, usByte:=0, cntr:= SafetyIsoMemRead$UDINT + VM_CLIENT_HEADER_SIZE); 
        else
          TRACE("(VaranManager_Safety_2::Init) Failed to allocate memory for ISO write data");  
          SafetyMemState := _ISO_RD_INSTALL_ERROR;
        end_if;
          
        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  
        
        SDOTransfer.DataBuffer := To_StdLib.Malloc(size:= SDO_BUFFER_SIZE);   // SDO buffer for splitted up data
        SDOTransfer.SDOBuffer.aPara[1] := SDOTransfer.DataBuffer$DINT;        // set data adress
        
        // write memory size informations
        SDOTransfer.MemorySizeInfo.SafetyIsoMemWrite := SafetyIsoMemWrite$UINT;
        SDOTransfer.MemorySizeInfo.SafetyIsoMemRead  := SafetyIsoMemRead$UINT;
        
        SDOTransfer.MemorySizeInfo.SafetyAsyMemWrite := SafetyAsyMemWrite$UINT;
        SDOTransfer.MemorySizeInfo.SafetyAsyMemRead  := SafetyAsyMemRead$UINT;

//**********************************************************************************************************************************************************     
    7: // in the seventh init we hand over the pointer to DPRAM 
        if b_Safety then
          if pSafetyManagerThis then
          
            MyPara.uiCmd := CMD_SM_ADD_MANAGING_INFO;

            if b_FSoEAvailable = FALSE then            
              //pointer to DPRAM write space
              MyPara.aPara[0] := ( p_ManagerClientSpace + VM_CLIENT_ISO_WR_OFFSET + sizeof(t_VMC_Header) + sizeof(t_VMC_Safety_Header) + sizeof(t_Iso_data.TDO)) $ DINT; 
              
              //pointer to DPRAM read space
              MyPara.aPara[1] := ( p_ManagerClientSpace + VM_CLIENT_ISO_RD_OFFSET + sizeof(t_VMC_Header) + sizeof(t_VMC_Safety_Header) + sizeof(t_Iso_data.TDO)) $ DINT; 
              
              // hand over this pointer
              MyPara.aPara[2] := THIS$DINT;
              
              MyPara.aPara[3] := (#pIsoWriteSafetyData^.PDO)$DINT;  //pointer to PDO WR data in appli mem
              MyPara.aPara[4] := (#pIsoReadSafetyData^.PDO)$DINT;   //pointer to PDO RD data in appli mem
      
              // max length for PDOs
              MyPara.aPara[5] := SafetyIsoMemWrite - sizeof(t_IsoMemXChange.WriteCnt) - sizeof(t_IsoMemXChange.StateInfo) - sizeof(t_IsoMemXChange.Length) - sizeof(t_IsoMemXChange.TDOData);
              MyPara.aPara[6] := SafetyIsoMemRead  - sizeof(t_IsoMemXChange.WriteCnt) - sizeof(t_IsoMemXChange.StateInfo) - sizeof(t_IsoMemXChange.Length) - sizeof(t_IsoMemXChange.TDOData);
            else
              //pointer to DPRAM write space
              MyPara.aPara[0] := ( p_ManagerClientSpace + VM_CLIENT_ISO_WR_OFFSET + sizeof(t_VMC_Header) + sizeof(t_VMC_Safety_Header)) $ DINT; 
              
              //pointer to DPRAM read space
              MyPara.aPara[1] := ( p_ManagerClientSpace + VM_CLIENT_ISO_RD_OFFSET + sizeof(t_VMC_Header) + sizeof(t_VMC_Safety_Header)) $ DINT; 
              
              // hand over this pointer
              MyPara.aPara[2] := THIS$DINT;
              
              MyPara.aPara[3] := (#pIsoWriteSafetyData^.TDO)$DINT;  //pointer to PDO WR data in appli mem
              MyPara.aPara[4] := (#pIsoReadSafetyData^.TDO)$DINT;   //pointer to PDO RD data in appli mem
      
              // max length for PDOs
              MyPara.aPara[5] := SafetyIsoMemWrite - sizeof(t_IsoMemXChange.WriteCnt) - sizeof(t_IsoMemXChange.StateInfo) - sizeof(t_IsoMemXChange.Length);
              MyPara.aPara[6] := SafetyIsoMemRead  - sizeof(t_IsoMemXChange.WriteCnt) - sizeof(t_IsoMemXChange.StateInfo) - sizeof(t_IsoMemXChange.Length);
            end_if;

            // Do Handles
            // VM doesn't use DOs Pass 0 incase they are used somewhere => Error if passed as value to the payload interface
            MyPara.aPara[7]$UDINT := 0;
            MyPara.aPara[8]$UDINT := 0;
            
            
            pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
          else
            // if there is no safety manager => problem, because this class won't work without
            State := _ManagerNotExists;
          end_if;
        end_if;
  end_case; 
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VaranManager_2::Control::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  
  // Handle Safty commands ===================================================================================================================================
  if pPara^.uiCmd >= CMD_SM_CMD_MIN_RANGE &
     pPara^.uiCmd <= CMD_SM_CMD_MAX_RANGE then

    CASE pPara^.uiCmd OF
  //**********************************************************************************************************************************************************
      CMD_SM_START_TIME_SYNC: // Timesync Token Forwarding
        if b_FSoEAvailable = FALSE then
          // check if ack is ready for handshake
          if pIsoReadSafetyData^.Safety_Header.StateInfo.TokenAck = FALSE then
            // send time sync token
            pIsoWriteSafetyData^.Safety_Header.StateInfo.TimeSyncToken := TRUE;
        
            // increase write counter
            if pIsoWriteSafetyData^.Safety_Header.WriteCnt < 16#7FFF then
              pIsoWriteSafetyData^.Safety_Header.WriteCnt += 1;
            else
              pIsoWriteSafetyData^.Safety_Header.WriteCnt := 0;
            end_if;
          end_if;
        else
          TRACE("(VaranManager_2::Control::NewInst) Starting time sync not possible with FSoE modules in the project");
        end_if;

        ret_code := READY;

  //**********************************************************************************************************************************************************      
      CMD_SM_TDO_TO_MODULE:
        if b_FSoEAvailable = FALSE then
          // store TDO data
          if (pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOInside = FALSE) & (pIsoReadSafetyData^.Safety_Header.StateInfo.TDOAck = FALSE) then
           
            // get TDO into our memory
            _memcpy(ptr1:=#pIsoWriteSafetyData^.TDO, ptr2:=(pPara^.aPara[1])$^void, cntr:=STDO_LENGTH);

            pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOInside := TRUE;
            
            // increase write counter
            if pIsoWriteSafetyData^.Safety_Header.WriteCnt < 16#7FFF then
              pIsoWriteSafetyData^.Safety_Header.WriteCnt += 1;
            else
              pIsoWriteSafetyData^.Safety_Header.WriteCnt := 0;
            end_if;
          end_if;
        else
          TRACE("(VaranManager_2::Control::NewInst) No TDOs possible with FSoE modules in the project");
        end_if;

        ret_code := READY;

  //**********************************************************************************************************************************************************
      CMD_SM_SYNC_CHECK:
        // check if it is synchrony
        if (VM2_SYNCHRON = 0) | (SDOTransfer.InitDone = false) then
          // if it's not => return error
          ret_code := ERROR;
        else
          // otherwise eveything's fine
          ret_code := READY;
        end_if;

  //**********************************************************************************************************************************************************
      CMD_SM_ITF_POSSIBLE:
        // tell the other side (which can't determine it that early)
        b_InterfaceFramesPossible := TRUE;
  //      pIsoWriteSafetyData^.Safety_Header.StateInfo.InterfaceFramesPossible := TRUE;
        
  //**********************************************************************************************************************************************************
      CMD_SM_PDO_MEM_USAGE_WR:
        // show the actual isochron safety memory load
        if (pPara^.aPara[0] = 0) then
          SafetyIsoWrMemUsed := 0;
        else
          if b_FSoEAvailable = FALSE then
            SafetyIsoWrMemUsed := pPara^.aPara[0] + sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData);
          else
            SafetyIsoWrMemUsed := pPara^.aPara[0] + sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData) - sizeof(t_IsoMemXChange.TDOData);
          end_if;
          
          if SafetyIsoWrMemUsed > SafetyIsoMemWrite then
            SafetyMemState := _ISO_WR_SIZE_TOO_SMALL;
          end_if;

          if SafetyIsoRdMemUsed = 0 then
            if b_FSoEAvailable = FALSE then
              SafetyIsoRdMemUsed := sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData);
            else              
              SafetyIsoRdMemUsed := sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData) - sizeof(t_IsoMemXChange.TDOData);
            end_if;
          end_if;
        end_if;
        
  //**********************************************************************************************************************************************************
      CMD_SM_PDO_MEM_USAGE_RD:
        // show the actual isochron safety memory load
        if (pPara^.aPara[0] = 0) then
          SafetyIsoRdMemUsed := 0;
        else
          if b_FSoEAvailable = FALSE then
            SafetyIsoRdMemUsed := pPara^.aPara[0] + sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData);
          else
            SafetyIsoRdMemUsed := pPara^.aPara[0] + sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData) - sizeof(t_IsoMemXChange.TDOData);
          end_if;
          
          if SafetyIsoRdMemUsed > SafetyIsoMemRead then
            SafetyMemState := _ISO_RD_SIZE_TOO_SMALL;
          end_if;
          
          if SafetyIsoWrMemUsed = 0 then
            if b_FSoEAvailable = FALSE then
              SafetyIsoWrMemUsed := sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData);
            else
              SafetyIsoWrMemUsed := sizeof(t_IsoMemXChange) - sizeof(t_IsoMemXChange.PDOData) - sizeof(t_IsoMemXChange.TDOData);
            end_if;
          end_if;
        end_if;
        
  //**********************************************************************************************************************************************************
      CMD_SM_PDO_COPY_MODE:
        // choose between automatich or manual PDO data copy from intern to class memory
        bPdoCopyDisable := pPara^.aPara[0]$BOOL;   

  //**********************************************************************************************************************************************************
      CMD_SM_FSOE_AVAILABLE:
        // FSoE modules available in the project
        b_FSoEAvailable := TRUE;

  //**********************************************************************************************************************************************************
    ELSE
      //aPara[0] ... Lnge
      //aPara[1] ... Pointer Adresse auf Daten 
      
      // write data to ring buffer to transmit them
      if SendSdoData(pData:= (pPara^.aPara[1])$^void, uLength:= (pPara^.aPara[0])$UINT, Cmd:= pPara^.uiCmd) then
        ret_code := ERROR;
      else
        ret_code := READY;
      end_if;
      
  //**********************************************************************************************************************************************************
    END_CASE;
  
  // Pass on other commands to base ==========================================================================================================================
  else
    ret_code := VaranManager::NewInst(pPara, pResult);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VaranManager_2::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  if b_Safety then
  
    if VM2_SYNCHRON > SDOTransfer.OldSynchron then    //show if state has changed to Synchron
      bStartInit := true;
      ResetSDODataTraffic();
    elsif  VM2_SYNCHRON < SDOTransfer.OldSynchron then
      bStartInit            := false;
      bReadyForDataTransfer := false;
    end_if;
    
    SDOTransfer.OldSynchron := VM2_SYNCHRON;
    
    
    if (bStartInit = true ) & ( bReadyForDataTransfer = false) then
      if AsyReadData.pSDOData <> NIL then
        // look if memory is empty or is containing init data
        if (AsyReadData.pSDOData$^UDINT^ = 0) 
          | (((AsyReadData.pSDOData$^UDINT)^ = VM2_SDO_INIT_CMD_LENGTH) & (((AsyReadData.pSDOData + sizeof(t_SdoBlockHeader.ReadCnt) + sizeof(t_SdoBlockHeader.WriteCnt) + sizeof(t_SdoBlock.SDOLength))$^UINT)^ = CMD_SM_SDO_INIT_INFORMATION)) then  
          bReadyForDataTransfer := true;
        end_if;
      end_if;
    end_if;


    // SYNCHRON         -> Server
    // b_SynchronWatch  -> wir einmalig bei hochfahren in update RT gesetzt
    
    
    if VM2_SYNCHRON & b_SynchronWatch & bReadyForDataTransfer then
      // SDO tx data of tx ring buffer is sent 
      SDOTxDataTraffic();

      // baseclass sends the new tx data and gets new rx data
      state := VaranManager::CyWork(0);

      //SDO rx data is putted in the rx ring buffer
      SDORxDataTraffic();
    else
      // baseclass sends the new tx data and gets new rx data
      state := VaranManager::CyWork(0);
    end_if;
  else
    // baseclass sends the new tx data and gets new rx data
    state := VaranManager::CyWork(0);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VaranManager_2::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
		MyPara 	  : CmdStruct;
		MyResult	: results;
    IncreaseWriteCnt : BOOL;
  END_VAR
 
	state := VaranManager::RtWork(0);

  if b_Safety then
    if pSafetyManagerThis then
      case BitsInitSSW of
        0:
          pIsoWriteSafetyData^.Safety_Header.StateInfo.Initialize := TRUE;
          BitsInitSSW += 1;
        
        1:
          if pIsoReadSafetyData^.Safety_Header.StateInfo.Initialize then
            BitInitTime := ops.tAbsolute;
            BitsInitSSW += 1;
          end_if;
          
        2: // wait 100ms to ensure the other side also got our bit
          if (ops.tAbsolute - BitInitTime) >= 100 then
            BitInitTime := ops.tAbsolute;
            pIsoWriteSafetyData^.Safety_Header.StateInfo.Initialize := FALSE;
            BitsInitSSW += 1;
          end_if;

        3:

        // if we got new TDO infos the write counter must be increased
        if pIsoReadSafetyData^.Safety_Header.WriteCnt <> OldIsoRdCnt then
          OldIsoRdCnt := pIsoReadSafetyData^.Safety_Header.WriteCnt;
          IncreaseWriteCnt := FALSE;
        
          // check if there is a tdo for us
          if pIsoReadSafetyData^.Safety_Header.StateInfo.TDOInside then
            if pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOAck = FALSE then
              MyPara.uiCmd := CMD_SM_TDO_TO_MODULE;
              MyPara.aPara[0] := STDO_LENGTH;
              MyPara.aPara[1] := (#pIsoReadSafetyData^.TDO)$DINT;
              MyPara.aPara[2] := this$DINT;
              pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
                            
              pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOAck := TRUE;
              
              IncreaseWriteCnt := TRUE;
            end_if;
          elsif pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOAck then
            pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOAck := FALSE;
            
            IncreaseWriteCnt := TRUE;
          end_if;

          if pIsoReadSafetyData^.Safety_Header.StateInfo.TimeSyncToken then
            if pIsoWriteSafetyData^.Safety_Header.StateInfo.TokenAck = FALSE then
              MyPara.uiCmd := CMD_SM_TDO_TOKEN_FWD;
              MyPara.aPara[2] := this$DINT;
              pSafetyManagerThis^.NewInst(#MyPara, #MyResult);

              pIsoWriteSafetyData^.Safety_Header.StateInfo.TokenAck := TRUE;

              IncreaseWriteCnt := TRUE;
            end_if;
          elsif pIsoWriteSafetyData^.Safety_Header.StateInfo.TokenAck then
            pIsoWriteSafetyData^.Safety_Header.StateInfo.TokenAck := FALSE;
          
            IncreaseWriteCnt := TRUE;
          end_if;

          // check if we got ack for our TDO data
          if pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOInside & pIsoReadSafetyData^.Safety_Header.StateInfo.TDOAck then
            pIsoWriteSafetyData^.Safety_Header.StateInfo.TDOInside := FALSE;

            IncreaseWriteCnt := TRUE;
          end_if;

          // check if we got ack for our token
          if pIsoWriteSafetyData^.Safety_Header.StateInfo.TimeSyncToken & pIsoReadSafetyData^.Safety_Header.StateInfo.TokenAck then
            pIsoWriteSafetyData^.Safety_Header.StateInfo.TimeSyncToken := FALSE;

            IncreaseWriteCnt := TRUE;
          end_if;

          // increase write counter
          if IncreaseWriteCnt then
            if pIsoWriteSafetyData^.Safety_Header.WriteCnt < 16#7FFF then
              pIsoWriteSafetyData^.Safety_Header.WriteCnt += 1;
            else
              pIsoWriteSafetyData^.Safety_Header.WriteCnt := 0;
            end_if;
          end_if;
        end_if;


        // if the other side tells us, there are interface frames possible, we remember that
        if pIsoReadSafetyData^.Safety_Header.StateInfo.InterfaceFramesPossible & (pIsoWriteSafetyData^.Safety_Header.StateInfo.InterfaceFramesPossible = FALSE) then
          pIsoWriteSafetyData^.Safety_Header.StateInfo.InterfaceFramesPossible := TRUE;
          
          MyPara.uiCmd := CMD_SM_ITF_POSSIBLE;
          MyPara.aPara[2] := this$DINT;
          pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
        end_if;

      end_case;
      
      if b_SynchronWatch then
        if (VM2_SYNCHRON = 0) then
          SynchronFailCnt += 1;
        end_if;
        if VM2_SYNCHRON < OldSynchron then
          // reconnect the safety manager
          MyPara.uiCmd := CMD_SM_DISCONNECT;
          MyPara.aPara[0] := this$DINT;
          pSafetyManagerThis^.NewInst(#MyPara, #MyResult);
        elsif VM2_SYNCHRON > OldSynchron then
          OldReadCounter := 0;
          BitsInitSSW := 0;
        end_if;
      end_if;
      OldSynchron := VM2_SYNCHRON;

      if VM2_SYNCHRON & (b_SynchronWatch = FALSE) then
        b_SynchronWatch := TRUE;
      end_if;
    end_if;  

  end_if;  

END_FUNCTION





FUNCTION VaranManager_2::SDOTxDataTraffic
VAR
  DiffToEnd         : UINT;
  RestOfData        : UINT;
  TxDataLength      : UINT;
END_VAR
  
  #ifdef SDO_TIME_MEASUREMENT
    Save_Flg();  
    CLI();
    SDOTransfer.TimeMeasure[1].Start := OS_READMICROSEC();
  #endif
  
  // this methode is called in the methode UpdateCy
  
  if SafetyAsyMemWrite = 0 then
    return;
  end_if;
  
  if SDOTransfer.bytesInBuffer > 0 then
    if AsyWriteData.SDOHeader.WriteCnt = AsyReadData.SDOHeader.ReadCnt then  // proof if written data are successfully transmitted (acknowledgement)
      
      if SDOTransfer.bytesInBuffer <= (SafetyAsyMemWrite - SDO_BLOCK_HEADERSIZE) then  // proof if data can be send without splitting
        TxDataLength := SDOTransfer.bytesInBuffer;
      else // Data have to be splitted up (TxDataLength = SDO general data size)                                                                                 
        TxDataLength := SafetyAsyMemWrite$UINT - SDO_BLOCK_HEADERSIZE;
      end_if;
          
      // increase write counter with the actual bytes to write (put length info into memory)
      AsyWriteData.SDOHeader.WriteCnt += TxDataLength;
      
      (AsyWriteData.pSDOData$^t_SdoBlockHeader)^ := AsyWriteData.SDOHeader;
      
      // get SDO data into our memory
      if (SDOTransfer.RdPlace + TxDataLength) <= SDO_BUFFER_SIZE then  // proof if data are splitted through ring buffer overflow                 
        
        _memcpy(ptr1:= AsyWriteData.pSDOData + SDO_BLOCK_HEADERSIZE, 
                ptr2:= SDOTransfer.pRingBuffer + SDOTransfer.RdPlace, 
                cntr:= TxDataLength );
        
        SDOTransfer.RdPlace       := (SDOTransfer.RdPlace + TxDataLength) MOD SDO_BUFFER_SIZE;
      else  // data are splitted because of ring buffer overflow
        DiffToEnd := SDO_BUFFER_SIZE - SDOTransfer.RdPlace;
        RestOfData:= TxDataLength - DiffToEnd;
        
        _memcpy(ptr1:= AsyWriteData.pSDOData + SDO_BLOCK_HEADERSIZE, 
                ptr2:= SDOTransfer.pRingBuffer + SDOTransfer.RdPlace, 
                cntr:= DiffToEnd );
                
        SDOTransfer.RdPlace       := (SDOTransfer.RdPlace + DiffToEnd) MOD SDO_BUFFER_SIZE;        
        
        _memcpy(ptr1:= AsyWriteData.pSDOData + SDO_BLOCK_HEADERSIZE + DiffToEnd, 
                ptr2:= SDOTransfer.pRingBuffer + SDOTransfer.RdPlace, 
                cntr:= RestOfData );
        
        SDOTransfer.RdPlace       := (SDOTransfer.RdPlace + RestOfData) MOD SDO_BUFFER_SIZE;
        
      end_if;
      

      if (SafetyAsyWrMemUsed < (TxDataLength + SDO_BLOCK_HEADERSIZE)) then  // write max used asy mem byte size to server
        SafetyAsyWrMemUsed := (TxDataLength + SDO_BLOCK_HEADERSIZE);
      end_if;
      
      SDOTransfer.bytesInBuffer -= TxDataLength;
          
      
      SDOTransfer.WrongAckCtr := 0; // reset wrong Acknowledgement counter (only 4 tests)
    else
      SDOTransfer.WrongAckCtr += 1;
      if SDOTransfer.WrongAckCtr > 100 then
        TRACE("(VaranManager_2) wrong acknowledgement!");
      end_if;  
    end_if;  
  end_if;
  
  #ifdef SDO_TIME_MEASUREMENT
    SDOTransfer.TimeMeasure[1].Stop := OS_READMICROSEC();
    SDOTransfer.TimeMeasure[1].Diff := SDOTransfer.TimeMeasure[1].Stop - SDOTransfer.TimeMeasure[1].Start;
    
    if SDOTransfer.TimeMeasure[1].Diff > SDOTransfer.TimeMeasure[1].Maximum then
      SDOTransfer.TimeMeasure[1].Maximum := SDOTransfer.TimeMeasure[1].Diff;
    end_if; 
    
    if SDOTransfer.TimeMeasure[1].Diff < SDOTransfer.TimeMeasure[1].Minimum then
      SDOTransfer.TimeMeasure[1].Minimum:= SDOTransfer.TimeMeasure[1].Diff;
    end_if;
    
    Restore_Flg();
  #endif
END_FUNCTION


FUNCTION VaranManager_2::SDORxDataTraffic
VAR   
  pMemInfo          : ^t_MemSizeInfo;
  MyResult          : results;
  #ifdef SDO_DATA_RECORDING
    ActualMicrosec : udint;
  #endif
END_VAR
  
  #ifdef SDO_TIME_MEASUREMENT
    Save_Flg();  
    CLI();
    SDOTransfer.TimeMeasure[2].Start := OS_READMICROSEC();
  #endif
  
  if SafetyAsyMemRead = 0 then
    return;
  end_if;
  
  // this methode is called in the methode UpdateCy
  SDOTransfer.actualRead  := 0;
  
  AsyReadData.SDOHeader.WriteCnt  := ((AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT)^;  // readout write counter
  SDOTransfer.actualRead += sizeof(AsyReadData.SDOHeader.WriteCnt);
  
  AsyReadData.SDOHeader.ReadCnt   := ((AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT)^;  // readout read counter
  SDOTransfer.actualRead += sizeof(AsyReadData.SDOHeader.ReadCnt);
  
  AsyReadData.Length := (AsyReadData.SDOHeader.WriteCnt - SDOTransfer.OldReadedWriteCnt) mod 16#FFFF; // get length of hole block (without header size)
  
  if AsyReadData.Length > 0 then  // check if there is a new message
    if AsyReadData.Length <= SafetyAsyMemRead then  // proof if data size exceeds memory 
      if SafetyAsyRdMemUsed < (AsyReadData.Length + SDO_BLOCK_HEADERSIZE) then   // write max received asy byte size to server
        SafetyAsyRdMemUsed := AsyReadData.Length + SDO_BLOCK_HEADERSIZE;
      end_if;             
      if pSafetyManagerThis then
         
            repeat
            
              if ((SDOTransfer.SplitInfo AND 2#111) = 0 & (SDOTransfer.SplitInfo.dataNext = 0)) then
              
                if (((SDOTransfer.actualRead + sizeof(SDOTransfer.SDOLength)) <= SafetyAsyMemRead) 
                   | (SDOTransfer.SplitInfo.lengthNext = 1)) then // look if lenght info is splitted
                  if SDOTransfer.SplitInfo.lengthNext = 0 then  // look if length info was splitted
                    SDOTransfer.SDOLength := ((AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT)^; // readout length of first SDO
                    SDOTransfer.actualRead += sizeof(SDOTransfer.SDOLength); 
                  else
                    SDOTransfer.SplitInfo.lengthNext := 0;
                  end_if;  
                  SDOTransfer.SDODataLength := SDOTransfer.SDOLength - sizeof(SDOTransfer.SDOCmd);
                  SDOTransfer.MyPara.aPara[0] := SDOTransfer.SDODataLength;
                  
                  if (SDOTransfer.actualRead + sizeof(SDOTransfer.SDOCmd) + SDOTransfer.SDODataLength) <= SafetyAsyMemRead  then  // look if CMD&DATA are splitted
                    SDOTransfer.SDOCmd := ((AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT)^; // readout cmd info of first SDO
                    SDOTransfer.actualRead += sizeof(SDOTransfer.SDOCmd);
                    SDOTransfer.MyPara.uiCmd := SDOTransfer.SDOCmd;  

                    if SDOTransfer.SDOLength > sizeof(SDOTransfer.SDOCmd) then  // look if data are available     
                      SDOTransfer.MyPara.aPara[1] := to_dint(AsyReadData.pSDOData$dint + SDOTransfer.actualRead); // pointer to data
                      SDOTransfer.actualRead += SDOTransfer.SDODataLength;
                    else
                      SDOTransfer.MyPara.aPara[1] := 0;  
                    end_if;

                    if SDOTransfer.MyPara.uiCmd = CMD_SM_SDO_INIT_INFORMATION then  // check for init cmd
                      // send SDO init cmd with memory Size informations of ASY and ISO DOs
//                      TRACE("(VaranManager_2::UpdateCy) send SDO init cmd with memory informations");
                      SendSdoData(pData:= #SDOTransfer.MemorySizeInfo, uLength:= sizeof(SDOTransfer.MemorySizeInfo) , Cmd:= CMD_SM_SDO_INIT_INFORMATION);
                      
                      pMemInfo := SDOTransfer.MyPara.aPara[1]$^t_MemSizeInfo;
                      SDOTransfer.InitDone := true;
                      if  (SDOTransfer.MemorySizeInfo.SafetyAsyMemRead  = pMemInfo^.SafetyAsyMemWrite) &  // compare memory size of Manager and Client
                          (SDOTransfer.MemorySizeInfo.SafetyAsyMemWrite = pMemInfo^.SafetyAsyMemRead) then
                          
//                        TRACE("(VaranManager_2::SDORxDataTraffic) Sizes of ASY DOs are EQUAL");
                      else
                        TRACE("(VaranManager_2::SDORxDataTraffic) ERROR: Sizes of ASY DOs are NOT EQUAL !!!");
                        SafetyAsyMemRead      := 0;
                        SafetyAsyMemWrite     := 0;
                        SDOTransfer.InitDone  := false;
                        SafetyMemState        := _ASY_MEM_NOT_EQUAL;
                        return;
                      end_if;

                      if (SDOTransfer.MemorySizeInfo.SafetyIsoMemRead  = SDOTransfer.MyPara.aPara[1]$^t_MemSizeInfo^.SafetyIsoMemWrite) & // compare memory size of Manager and Client
                         (SDOTransfer.MemorySizeInfo.SafetyIsoMemWrite = SDOTransfer.MyPara.aPara[1]$^t_MemSizeInfo^.SafetyIsoMemRead) then
//                        TRACE("(VaranManager_2::SDORxDataTraffic) Sizes of ISO DOs are EQUAL");
                      else
                        TRACE("(VaranManager_2::SDORxDataTraffic) ERROR: Sizes of ISO DOs are NOT EQUAL !!!");
                        SafetyAsyMemRead      := 0;
                        SafetyAsyMemWrite     := 0;
                        SDOTransfer.InitDone  := false;
                        SafetyMemState        := _ISO_MEM_NOT_EQUAL;
                        return;
                      end_if;
                    else
                      pSafetyManagerThis^.NewInst(#SDOTransfer.MyPara, #MyResult); // hand over buffer data
                      
                      #ifdef SDO_DATA_RECORDING
                        if (SDOTransfer.Recorder.Index < (sizeof(t_SdoDataRecording.Buffer)/sizeof(t_SdoDataRecordingEntry)) )then
                          if SDOTransfer.Recorder.FirstRecorded = false then
                            SDOTransfer.Recorder.StartTime := OS_READMICROSEC();
                            SDOTransfer.Recorder.FirstRecorded := true;

                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := 0; 
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := 0;
                          else
                            ActualMicrosec := OS_READMICROSEC();
                            ActualMicrosec -= SDOTransfer.Recorder.StartTime; // time to start time point
                            
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := ActualMicrosec - SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index - 1].udTimeSinceStart; 
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := ActualMicrosec;
                          end_if;
                          
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].bIsTx         := false;
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiCmd         := SDOTransfer.MyPara.uiCmd$t_AsyCMDType;
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiLength      := to_uint(SDOTransfer.MyPara.aPara[0]);
                        
                          SDOTransfer.Recorder.Index += 1;
                        end_if;
                      #endif
                      
                    end_if;
                  else  // CMD&DATA are splitted
                  
                    SDOTransfer.SplitInfo.data    := 1;
                    SDOTransfer.DataToEnd         := SafetyAsyMemRead$UINT - SDOTransfer.actualRead;
                    SDOTransfer.RestOfData        := SDOTransfer.SDOLength - SDOTransfer.DataToEnd;
                
                    _memcpy(ptr1:= #SDOTransfer.SDOBuffer.uiCmd, 
                            ptr2:= (AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT, 
                            cntr:= SDOTransfer.DataToEnd); 
                    SDOTransfer.BytesInSplitBuffer  += SDOTransfer.DataToEnd;        
                    SDOTransfer.actualRead          += SDOTransfer.DataToEnd;        
                  end_if;
                  
                else  // length info is splitted
                  SDOTransfer.SplitInfo.length  := 1; 
                  SDOTransfer.DataToEnd         := SafetyAsyMemRead$UINT - SDOTransfer.actualRead;
                  SDOTransfer.RestOfData        := sizeof(SDOTransfer.SDODataLength) - SDOTransfer.DataToEnd;
                  
                  _memcpy(ptr1:= #SDOTransfer.SDOLength, 
                          ptr2:= (AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT, 
                          cntr:= SDOTransfer.DataToEnd); 
                  SDOTransfer.actualRead += SDOTransfer.DataToEnd;         
                end_if;
                 
              else  //SDO Block is splitted
                
                //Length is splitted
                if SDOTransfer.SplitInfo.length = 1 then
                  if SDOTransfer.RestOfData <= SafetyAsyMemRead then 
                    _memcpy(ptr1:= #SDOTransfer.SDOLength + SDOTransfer.DataToEnd, 
                            ptr2:= (AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT, 
                            cntr:= SDOTransfer.RestOfData);
                            
                    SDOTransfer.actualRead += SDOTransfer.RestOfData; 
                    SDOTransfer.SplitInfo.lengthNext := 1;
                  else
                    TRACE("(VaranManager_2) data split up is here not possible");
                  end_if; 
                  
                // CMD&DATA are splitted
                elsif ((SDOTransfer.SplitInfo.data = 1) | (SDOTransfer.SplitInfo.dataNext = 1)) then
                  if SDOTransfer.RestOfData <= SafetyAsyMemRead - SDO_BLOCK_HEADERSIZE then 
                    _memcpy(ptr1:= #SDOTransfer.SDOBuffer.uiCmd + SDOTransfer.BytesInSplitBuffer, 
                            ptr2:= (AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT, 
                            cntr:= SDOTransfer.RestOfData);   
                            
                    SDOTransfer.actualRead          += SDOTransfer.RestOfData; 
                    SDOTransfer.MyPara.uiCmd        := SDOTransfer.SDOBuffer.uiCmd;
                    SDOTransfer.MyPara.aPara[1]     := (#SDOTransfer.SDOBuffer.aPara[0])$DINT;  // pointer to data
                    SDOTransfer.SplitInfo.dataNext  := 0;
                    SDOTransfer.BytesInSplitBuffer  := 0;
                    
                    if SDOTransfer.SDOBuffer.uiCmd = CMD_SM_SDO_INIT_INFORMATION then // check for init cmd
                      SDOTransfer.InitDone := false;
                      TRACE("(VaranManager_2) ERROR: CMD_SM_SDO_INIT_INFORMATION are splitted! ");
                    else
                      pSafetyManagerThis^.NewInst(#SDOTransfer.MyPara, #MyResult);  // hand over buffer data
                      
                      #ifdef SDO_DATA_RECORDING
                        if (SDOTransfer.Recorder.Index < (sizeof(t_SdoDataRecording.Buffer)/sizeof(t_SdoDataRecordingEntry)) )then
                          if SDOTransfer.Recorder.FirstRecorded = false then
                            SDOTransfer.Recorder.StartTime := OS_READMICROSEC();
                            SDOTransfer.Recorder.FirstRecorded := true;

                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := 0; 
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := 0;
                          else
                            ActualMicrosec := OS_READMICROSEC();
                            ActualMicrosec -= SDOTransfer.Recorder.StartTime; // time to start time point
                            
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := ActualMicrosec - SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index - 1].udTimeSinceStart; 
                            SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := ActualMicrosec;
                          end_if;
                          
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].bIsTx         := false;
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiCmd         := SDOTransfer.MyPara.uiCmd$t_AsyCMDType;
                          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiLength      := to_uint(SDOTransfer.MyPara.aPara[0]);
                        
                          SDOTransfer.Recorder.Index += 1;
                        end_if;
                      #endif
                      
                    end_if;
                  else
                    SDOTransfer.SplitInfo.dataNext := 1;
                    
                    _memcpy(ptr1:= #SDOTransfer.SDOBuffer.uiCmd + SDOTransfer.BytesInSplitBuffer, 
                            ptr2:= (AsyReadData.pSDOData + SDOTransfer.actualRead)$^UINT, 
                            cntr:= SafetyAsyMemRead$UDINT - SDO_BLOCK_HEADERSIZE);  
                            
                    SDOTransfer.BytesInSplitBuffer  += (SafetyAsyMemRead$UINT - SDO_BLOCK_HEADERSIZE);
                    SDOTransfer.RestOfData          -= (SafetyAsyMemRead$UINT - SDO_BLOCK_HEADERSIZE);
                    SDOTransfer.actualRead          += (SafetyAsyMemRead$UINT - SDO_BLOCK_HEADERSIZE);
                  end_if;
                end_if;
          
                SDOTransfer.SplitInfo := SDOTransfer.SplitInfo AND 2#11111000;  
              end_if;
              
              if (SDOTransfer.actualRead > AsyReadData.Length + SDO_BLOCK_HEADERSIZE) then  // 4 -> size of header
                TRACE("(VaranManager_2) wrong length at the end! ");
              end_if;
                
            // read out data until the end of buffer is reached or all available data are readed out or data are splitted
            until (SDOTransfer.actualRead >= AsyReadData.Length + SDO_BLOCK_HEADERSIZE) | // 4 -> size of header
                  (SDOTransfer.actualRead = SafetyAsyMemRead) | 
                  ((SDOTransfer.SplitInfo AND 2#111) <> 0) end_repeat;
                    
            SDOTransfer.OldReadedWriteCnt += AsyReadData.Length;  // generate old counter value                                                            
            AsyWriteData.SDOHeader.ReadCnt := AsyReadData.SDOHeader.WriteCnt; // acknowledgement of successfully readed out data
            ((AsyWriteData.pSDOData + sizeof(AsyWriteData.SDOHeader.WriteCnt))$^UINT)^ := AsyWriteData.SDOHeader.ReadCnt;        
        
      end_if;

    else
      TRACE("(VaranManager_2) DataSize of RX message exceeds memory size!");
    end_if;  
  end_if;
    
  
  #ifdef SDO_TIME_MEASUREMENT
    SDOTransfer.TimeMeasure[2].Stop := OS_READMICROSEC();
    SDOTransfer.TimeMeasure[2].Diff := SDOTransfer.TimeMeasure[2].Stop - SDOTransfer.TimeMeasure[2].Start;
    
    if SDOTransfer.TimeMeasure[2].Diff > SDOTransfer.TimeMeasure[2].Maximum then
      SDOTransfer.TimeMeasure[2].Maximum := SDOTransfer.TimeMeasure[2].Diff;
    end_if; 
    
    if SDOTransfer.TimeMeasure[2].Diff < SDOTransfer.TimeMeasure[2].Minimum then
      SDOTransfer.TimeMeasure[2].Minimum:= SDOTransfer.TimeMeasure[2].Diff;
    end_if;
    
    Restore_Flg();
  #endif

END_FUNCTION


FUNCTION VaranManager_2::SendSdoData
	VAR_INPUT
		pData 	: ^void;
		uLength 	: UINT;
		Cmd 	: UINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  VAR
  	bundleLength      : UINT;
    totalBundleLength : UINT;
    DiffToEnd         : UINT;
    RestOfData        : UINT;
    #ifdef SDO_DATA_RECORDING
      ActualMicrosec : udint;
    #endif
  END_VAR
    
  
  #ifdef SDO_TIME_MEASUREMENT
    Save_Flg();  
    CLI();
    SDOTransfer.TimeMeasure[0].Start := OS_READMICROSEC();
  #endif
  
    #ifdef SDO_DATA_RECORDING
      if (SDOTransfer.Recorder.Index < (sizeof(t_SdoDataRecording.Buffer)/sizeof(t_SdoDataRecordingEntry)) )then
        if SDOTransfer.Recorder.FirstRecorded = false then
          SDOTransfer.Recorder.StartTime := OS_READMICROSEC();
          SDOTransfer.Recorder.FirstRecorded := true;

          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := 0; 
          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := 0;
        else
          ActualMicrosec := OS_READMICROSEC();
          ActualMicrosec -= SDOTransfer.Recorder.StartTime; // time to start time point
          
          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceLast := ActualMicrosec - SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index - 1].udTimeSinceStart; 
          SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].udTimeSinceStart := ActualMicrosec;
        end_if;
        
        SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].bIsTx         := true;
        SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiCmd         := Cmd$t_AsyCMDType;
        SDOTransfer.Recorder.Buffer[SDOTransfer.Recorder.Index].uiLength      := uLength;
      
        SDOTransfer.Recorder.Index += 1;
      end_if;
    #endif
  
  // no memory set to transmit something
  if SafetyAsyMemWrite = 0 then
    retval := -1;
    return;
  end_if;
  
  // if the init isn't finished, no other sdo communication is allowed
  if ((SDOTransfer.InitDone = false) & (Cmd <> CMD_SM_SDO_INIT_INFORMATION)) then
    retval := -2;
    return;
  end_if;
  
  retval := 0;  //all OK
  
  // allocate memory for the ring buffer
  if SDOTransfer.pRingBuffer = NIL then
    SDOTransfer.pRingBuffer := To_StdLib.Malloc(SDO_BUFFER_SIZE);
  end_if;
  
  // calculate bundle size information
  bundleLength      := sizeof(Cmd) + uLength;                  
  totalBundleLength := sizeof(bundleLength) + bundleLength;
                                                            
  if ((SDO_BUFFER_SIZE - SDOTransfer.bytesInBuffer) >= totalBundleLength) then  //proof if there is enough free memory in ring buffer
        
    // copy bundleLength data to ring buffer
    if (SDOTransfer.WrPlace + sizeof(BundleLength)) <= SDO_BUFFER_SIZE then
      _memcpy(ptr1:= SDOTransfer.pRingBuffer + SDOTransfer.WrPlace , 
              ptr2:= #BundleLength, 
              cntr:= sizeof(BundleLength));
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + sizeof(BundleLength)) MOD SDO_BUFFER_SIZE ; //increment WrPlace with the size off added data before 
      SDOTransfer.bytesInBuffer += sizeof(BundleLength);
    else  //data are splitted
      DiffToEnd := SDO_BUFFER_SIZE - SDOTransfer.WrPlace;
      RestOfData:= sizeof(BundleLength) - DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= #BundleLength, 
              cntr:= DiffToEnd);
      
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + DiffToEnd) MOD SDO_BUFFER_SIZE ;  //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= #BundleLength + DiffToEnd, 
              cntr:= RestOfData);
              
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + RestOfData) MOD SDO_BUFFER_SIZE;  //increment WrPlace with the size off added data before 
      SDOTransfer.bytesInBuffer += RestOfData;
    end_if;
    
    // copy Cmd data to ring buffer               
    if (SDOTransfer.WrPlace + sizeof(Cmd)) <= SDO_BUFFER_SIZE then
      _memcpy(ptr1:= SDOTransfer.pRingBuffer + SDOTransfer.WrPlace, 
              ptr2:= #Cmd, 
              cntr:= sizeof(Cmd));
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + sizeof(Cmd)) MOD SDO_BUFFER_SIZE; //increment WrPlace with the size off added data before 
      SDOTransfer.bytesInBuffer += sizeof(Cmd);
    else  //data are splitted
      DiffToEnd := SDO_BUFFER_SIZE - SDOTransfer.WrPlace;
      RestOfData:= sizeof(Cmd) - DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= #Cmd, 
              cntr:= DiffToEnd);
      
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + DiffToEnd) MOD SDO_BUFFER_SIZE; //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= #Cmd + DiffToEnd, 
              cntr:= RestOfData);
              
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + RestOfData) MOD SDO_BUFFER_SIZE;  //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += RestOfData;
    end_if;        
            
    // copy user data to ring buffer        
    if (SDOTransfer.WrPlace + uLength) <= SDO_BUFFER_SIZE then
      _memcpy(ptr1:= SDOTransfer.pRingBuffer + SDOTransfer.WrPlace, 
              ptr2:= pData, 
              cntr:= uLength);
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + uLength) MOD SDO_BUFFER_SIZE;  //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += uLength;
    else  //data are splitted
      DiffToEnd := SDO_BUFFER_SIZE - SDOTransfer.WrPlace;
      RestOfData:= uLength - DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= pData, 
              cntr:= DiffToEnd);
      
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + DiffToEnd) MOD SDO_BUFFER_SIZE; //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += DiffToEnd;
      
      _memcpy(ptr1:= (SDOTransfer.pRingBuffer + SDOTransfer.WrPlace), 
              ptr2:= pData + DiffToEnd, 
              cntr:= RestOfData);
              
      SDOTransfer.WrPlace := (SDOTransfer.WrPlace + RestOfData) MOD SDO_BUFFER_SIZE; //increment WrPlace with the size off added data before
      SDOTransfer.bytesInBuffer += RestOfData;
    end_if;        

  else
    retval := -1; //not enough memory available at ring buffer
    TRACE("(VaranManager_2::SendSdoData) SDOTransfer ERROR -> not enough memory");
  end_if;
  
  #ifdef SDO_TIME_MEASUREMENT
    SDOTransfer.TimeMeasure[0].Stop := OS_READMICROSEC();
    SDOTransfer.TimeMeasure[0].Diff := SDOTransfer.TimeMeasure[0].Stop - SDOTransfer.TimeMeasure[0].Start;
    
    if SDOTransfer.TimeMeasure[0].Diff > SDOTransfer.TimeMeasure[0].Maximum then
      SDOTransfer.TimeMeasure[0].Maximum := SDOTransfer.TimeMeasure[0].Diff;
    end_if; 
    
    if SDOTransfer.TimeMeasure[0].Diff < SDOTransfer.TimeMeasure[0].Minimum then
      SDOTransfer.TimeMeasure[0].Minimum:= SDOTransfer.TimeMeasure[0].Diff;
    end_if;
    
    Restore_Flg();
  #endif
  
END_FUNCTION


FUNCTION VaranManager_2::ResetSDODataTraffic
  
  // Reset SDO relevant data
  SDOTransfer.OldReadedWriteCnt   := 0; 

  SDOTransfer.SplitInfo           := 0;
  SDOTransfer.actualRead          := 0;
  SDOTransfer.RdPlace             := 0;
  SDOTransfer.WrPlace             := 0;
  SDOTransfer.bytesInBuffer       := 0; 

  AsyWriteData.SDOHeader.WriteCnt           := 0;
  AsyWriteData.SDOHeader.ReadCnt            := 0;
  
  if AsyWriteData.pSDOData <> NIL then
    AsyWriteData.pSDOData$^t_SdoBlockHeader^  := AsyWriteData.SDOHeader;
  end_if;

  SDOTransfer.SplitInfo           := 0;
  SDOTransfer.BytesInSplitBuffer  := 0;
  
  SDOTransfer.InitDone            := false;

END_FUNCTION
